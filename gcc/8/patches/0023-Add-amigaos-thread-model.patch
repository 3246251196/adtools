From efd4400bea195f04a0eec77be4d67a960da8c143 Mon Sep 17 00:00:00 2001
From: Sebastian Bauer <mail@sebastianbauer.info>
Date: Fri, 4 May 2018 18:22:24 +0200
Subject: [PATCH 23/23] Add amigaos thread model.

It is work in progress.
---
 config/gthr.m4                 |   1 +
 gcc/configure                  |   2 +-
 gcc/configure.ac               |   2 +-
 libgcc/config/rs6000/t-amigaos |   5 +
 libgcc/configure               |   1 +
 libgcc/gthr-amigaos-native.c   |  90 ++++++++++++
 libgcc/gthr-amigaos-single.c   | 129 ++++++++++++++++
 libgcc/gthr-amigaos.h          | 326 +++++++++++++++++++++++++++++++++++++++++
 libstdc++-v3/configure         |  15 +-
 9 files changed, 562 insertions(+), 9 deletions(-)
 create mode 100644 libgcc/gthr-amigaos-native.c
 create mode 100644 libgcc/gthr-amigaos-single.c
 create mode 100644 libgcc/gthr-amigaos.h

diff --git a/config/gthr.m4 b/config/gthr.m4
index 7b29f1f3327c9fdde23f15a507757e6a234cd196..6f61465461d6f70a717eb9205062d5aee7375726 100644
--- a/config/gthr.m4
+++ b/config/gthr.m4
@@ -9,12 +9,13 @@ dnl Define header location by thread model
 
 dnl usage: GCC_AC_THREAD_HEADER([thread_model])
 AC_DEFUN([GCC_AC_THREAD_HEADER],
 [
 case $1 in
     aix)	thread_header=config/rs6000/gthr-aix.h ;;
+    amigaos)	thread_header=gthr-amigaos.h ;;
     dce)	thread_header=config/pa/gthr-dce.h ;;
     lynx)	thread_header=config/gthr-lynx.h ;;
     mipssde)	thread_header=config/mips/gthr-mipssde.h ;;
     posix)	thread_header=gthr-posix.h ;;
     rtems)	thread_header=config/gthr-rtems.h ;;
     single)	thread_header=gthr-single.h ;;
diff --git a/gcc/configure b/gcc/configure
index 6121e163259dd6c09188b48218b3fec63d41b2f8..04f420fe61c2a65c7c4adfc36ca07ec7ab6c074b 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -11689,13 +11689,13 @@ case ${enable_threads} in
     target_thread_file='single'
     ;;
   yes)
     # default
     target_thread_file='single'
     ;;
-  aix | dce | lynx | mipssde | posix | rtems | \
+  aix | amigaos | dce | lynx | mipssde | posix | rtems | \
   single | tpf | vxworks | win32)
     target_thread_file=${enable_threads}
     ;;
   *)
     echo "${enable_threads} is an unknown thread package" 1>&2
     exit 1
diff --git a/gcc/configure.ac b/gcc/configure.ac
index b066cc609e1c2615e66307d5439f765a4f3b286b..1a10e06f5a6254864f5a7dcad0a360077d7c9d10 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -1608,13 +1608,13 @@ case ${enable_threads} in
     target_thread_file='single'
     ;;
   yes)
     # default
     target_thread_file='single'
     ;;
-  aix | dce | lynx | mipssde | posix | rtems | \
+  aix | amigaos | dce | lynx | mipssde | posix | rtems | \
   single | tpf | vxworks | win32)
     target_thread_file=${enable_threads}
     ;;
   *)
     echo "${enable_threads} is an unknown thread package" 1>&2
     exit 1
diff --git a/libgcc/config/rs6000/t-amigaos b/libgcc/config/rs6000/t-amigaos
index da1e303eed7e60df883971a610e8904db0df3e23..d36c0309d70b957d40d6746443e5f8b9162617d2 100644
--- a/libgcc/config/rs6000/t-amigaos
+++ b/libgcc/config/rs6000/t-amigaos
@@ -40,6 +40,11 @@ SHLIB_LINK = $(GCC_FOR_TARGET) -shared $(SHLIB_OBJS) -nodefaultlibs $(LIBGCC2_CF
 
 # Install the shared libgcc library, but ensure that the name is libgcc.so
 SHLIB_INSTALL = \
 	$(mkinstalldirs) $(DESTDIR)$(inst_libdir); \
 	$(INSTALL_DATA) $(SHLIB_DIR)/$(SHLIB_SONAME) \
 	  $(DESTDIR)$(inst_libdir)/libgcc$(SHLIB_EXT);
+
+EXTRA_PARTS += gthr-amigaos-single.o
+
+gthr-amigaos-single.o: $(srcdir)/gthr-amigaos-single.c $(srcdir)/gthr-amigaos.h
+	$(gcc_compile) -c $<
diff --git a/libgcc/configure b/libgcc/configure
index b2f3f8708441e473b8e2941c4748748b6c7c40b8..5e486be60eef6666e1d8c548163bce5d02b94a0a 100644
--- a/libgcc/configure
+++ b/libgcc/configure
@@ -5439,12 +5439,13 @@ tm_file="${tm_file_}"
 
 
 # Map from thread model to thread header.
 
 case $target_thread_file in
     aix)	thread_header=config/rs6000/gthr-aix.h ;;
+    amigaos)	thread_header=gthr-amigaos.h ;;
     dce)	thread_header=config/pa/gthr-dce.h ;;
     lynx)	thread_header=config/gthr-lynx.h ;;
     mipssde)	thread_header=config/mips/gthr-mipssde.h ;;
     posix)	thread_header=gthr-posix.h ;;
     rtems)	thread_header=config/gthr-rtems.h ;;
     single)	thread_header=gthr-single.h ;;
diff --git a/libgcc/gthr-amigaos-native.c b/libgcc/gthr-amigaos-native.c
new file mode 100644
index 0000000000000000000000000000000000000000..a9bb6a14382854de15cee61c0e24c2b9b1ee1758
--- /dev/null
+++ b/libgcc/gthr-amigaos-native.c
@@ -0,0 +1,90 @@
+/**
+ * This is the native implementation of gcc threads
+ * abstraction.
+ */
+
+#include "gthr-amigaos.h"
+
+int
+__gthread_active_p (void)
+{
+  return 0;
+}
+
+int
+__gthread_once (__gthread_once_t *__once UNUSED, void (*__func) (void) UNUSED)
+{
+  return 0;
+}
+
+int UNUSED
+__gthread_key_create (__gthread_key_t *__key UNUSED, void (*__func) (void *) UNUSED)
+{
+  return 0;
+}
+
+int UNUSED
+__gthread_key_delete (__gthread_key_t __key UNUSED)
+{
+  return 0;
+}
+
+void *
+__gthread_getspecific (__gthread_key_t __key UNUSED)
+{
+  return 0;
+}
+
+int
+__gthread_setspecific (__gthread_key_t __key UNUSED, const void *__v UNUSED)
+{
+  return 0;
+}
+
+int
+__gthread_mutex_destroy (__gthread_mutex_t *__mutex UNUSED)
+{
+  return 0;
+}
+
+int
+__gthread_mutex_lock (__gthread_mutex_t *__mutex UNUSED)
+{
+  return 0;
+}
+
+int
+__gthread_mutex_trylock (__gthread_mutex_t *__mutex UNUSED)
+{
+  return 0;
+}
+
+int
+__gthread_mutex_unlock (__gthread_mutex_t *__mutex UNUSED)
+{
+  return 0;
+}
+
+int
+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
+{
+  return __gthread_mutex_lock (__mutex);
+}
+
+int
+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
+{
+  return __gthread_mutex_trylock (__mutex);
+}
+
+int
+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
+{
+  return __gthread_mutex_unlock (__mutex);
+}
+
+int
+__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
+{
+  return __gthread_mutex_destroy (__mutex);
+}
diff --git a/libgcc/gthr-amigaos-single.c b/libgcc/gthr-amigaos-single.c
new file mode 100644
index 0000000000000000000000000000000000000000..ab6d5f1da3f748df163a60544bcdfa49de48ecd2
--- /dev/null
+++ b/libgcc/gthr-amigaos-single.c
@@ -0,0 +1,129 @@
+/**
+ * This is the single-thread implementation of gcc threads abstraction.
+ */
+
+#include "gthr-amigaos.h"
+
+#define UNUSED __attribute__((__unused__))
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+int
+__gthread_active_p (void)
+{
+  return 0;
+}
+
+int
+__gthread_once (__gthread_once_t *__once UNUSED, void (*__func) (void) UNUSED)
+{
+  return 0;
+}
+
+int UNUSED
+__gthread_key_create (__gthread_key_t *__key UNUSED, void (*__func) (void *) UNUSED)
+{
+  return 0;
+}
+
+int UNUSED
+__gthread_key_delete (__gthread_key_t __key UNUSED)
+{
+  return 0;
+}
+
+void *
+__gthread_getspecific (__gthread_key_t __key UNUSED)
+{
+  return 0;
+}
+
+int
+__gthread_setspecific (__gthread_key_t __key UNUSED, const void *__v UNUSED)
+{
+  return 0;
+}
+
+int
+__gthread_mutex_destroy (__gthread_mutex_t *__mutex UNUSED)
+{
+  return 0;
+}
+
+int
+__gthread_mutex_lock (__gthread_mutex_t *__mutex UNUSED)
+{
+  return 0;
+}
+
+int
+__gthread_mutex_trylock (__gthread_mutex_t *__mutex UNUSED)
+{
+  return 0;
+}
+
+int
+__gthread_mutex_unlock (__gthread_mutex_t *__mutex UNUSED)
+{
+  return 0;
+}
+
+int
+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
+{
+  return __gthread_mutex_lock (__mutex);
+}
+
+int
+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
+{
+  return __gthread_mutex_trylock (__mutex);
+}
+
+int
+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
+{
+  return __gthread_mutex_unlock (__mutex);
+}
+
+int
+__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
+{
+  return __gthread_mutex_destroy (__mutex);
+}
+
+int
+__gthread_create (__gthread_t *thread, void *(*func) (void*), void *args)
+{
+  return 0;
+}
+
+int
+__gthread_join (__gthread_t thread, void **value_ptr)
+{
+  return 0;
+}
+
+int
+__gthread_detach (__gthread_t thread)
+{
+  return 0;
+}
+
+int
+__gthread_equal (__gthread_t t1, __gthread_t t2)
+{
+  return 0;
+}
+
+__gthread_t __gthread_self (void)
+{
+  return 0;
+}
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/libgcc/gthr-amigaos.h b/libgcc/gthr-amigaos.h
new file mode 100644
index 0000000000000000000000000000000000000000..183d1aca1fdd3be69f8b058a67599a96c95afa3e
--- /dev/null
+++ b/libgcc/gthr-amigaos.h
@@ -0,0 +1,326 @@
+/* Threads compatibility routines for libgcc2 and libobjc.  */
+/* Compile this one with gcc.  */
+/* Copyright (C) 1997-2018 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_GTHR_AMIGAOS_H
+#define GCC_GTHR_AMIGAOS_H
+
+#include <stdlib.h>
+
+typedef int __gthread_key_t;
+typedef int __gthread_once_t;
+typedef int __gthread_mutex_t;
+typedef int __gthread_recursive_mutex_t;
+
+typedef int __gthread_cond_t;
+
+typedef int __gthread_t;
+typedef int __gthread_time_t;
+
+#define __GTHREADS 1
+#define __GTHREADS_CXX0X 1
+
+#define __GTHREAD_ONCE_INIT 0
+#define __GTHREAD_MUTEX_INIT 0
+#define __GTHREAD_MUTEX_INIT_FUNCTION(mx) do {} while (0)
+#define __GTHREAD_RECURSIVE_MUTEX_INIT 0
+
+#define __GTHREAD_COND_INIT 0
+#define __GTHREAD_COND_INIT_FUNCTION(cond) do {} while (0)
+
+#define UNUSED __attribute__((__unused__))
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#ifdef _LIBOBJC
+
+/* Thread local storage for a single thread */
+static void *thread_local_storage = NULL;
+
+/* Backend initialization functions */
+
+/* Initialize the threads subsystem.  */
+static inline int
+__gthread_objc_init_thread_system (void)
+{
+  /* No thread support available */
+  return -1;
+}
+
+/* Close the threads subsystem.  */
+static inline int
+__gthread_objc_close_thread_system (void)
+{
+  /* No thread support available */
+  return -1;
+}
+
+/* Backend thread functions */
+
+/* Create a new thread of execution.  */
+static inline objc_thread_t
+__gthread_objc_thread_detach (void (* func)(void *), void * arg UNUSED)
+{
+  /* No thread support available */
+  return NULL;
+}
+
+/* Set the current thread's priority.  */
+static inline int
+__gthread_objc_thread_set_priority (int priority UNUSED)
+{
+  /* No thread support available */
+  return -1;
+}
+
+/* Return the current thread's priority.  */
+static inline int
+__gthread_objc_thread_get_priority (void)
+{
+  return OBJC_THREAD_INTERACTIVE_PRIORITY;
+}
+
+/* Yield our process time to another thread.  */
+static inline void
+__gthread_objc_thread_yield (void)
+{
+  return;
+}
+
+/* Terminate the current thread.  */
+static inline int
+__gthread_objc_thread_exit (void)
+{
+  /* No thread support available */
+  /* Should we really exit the program */
+  /* exit (&__objc_thread_exit_status); */
+  return -1;
+}
+
+/* Returns an integer value which uniquely describes a thread.  */
+static inline objc_thread_t
+__gthread_objc_thread_id (void)
+{
+  /* No thread support, use 1.  */
+  return (objc_thread_t) 1;
+}
+
+/* Sets the thread's local storage pointer.  */
+static inline int
+__gthread_objc_thread_set_data (void *value)
+{
+  thread_local_storage = value;
+  return 0;
+}
+
+/* Returns the thread's local storage pointer.  */
+static inline void *
+__gthread_objc_thread_get_data (void)
+{
+  return thread_local_storage;
+}
+
+/* Backend mutex functions */
+
+/* Allocate a mutex.  */
+static inline int
+__gthread_objc_mutex_allocate (objc_mutex_t mutex UNUSED)
+{
+  return 0;
+}
+
+/* Deallocate a mutex.  */
+static inline int
+__gthread_objc_mutex_deallocate (objc_mutex_t mutex UNUSED)
+{
+  return 0;
+}
+
+/* Grab a lock on a mutex.  */
+static inline int
+__gthread_objc_mutex_lock (objc_mutex_t mutex UNUSED)
+{
+  /* There can only be one thread, so we always get the lock */
+  return 0;
+}
+
+/* Try to grab a lock on a mutex.  */
+static inline int
+__gthread_objc_mutex_trylock (objc_mutex_t mutex UNUSED)
+{
+  /* There can only be one thread, so we always get the lock */
+  return 0;
+}
+
+/* Unlock the mutex */
+static inline int
+__gthread_objc_mutex_unlock (objc_mutex_t mutex UNUSED)
+{
+  return 0;
+}
+
+/* Backend condition mutex functions */
+
+/* Allocate a condition.  */
+static inline int
+__gthread_objc_condition_allocate (objc_condition_t condition UNUSED)
+{
+  return 0;
+}
+
+/* Deallocate a condition.  */
+static inline int
+__gthread_objc_condition_deallocate (objc_condition_t condition UNUSED)
+{
+  return 0;
+}
+
+/* Wait on the condition */
+static inline int
+__gthread_objc_condition_wait (objc_condition_t condition UNUSED,
+			       objc_mutex_t mutex UNUSED)
+{
+  return 0;
+}
+
+/* Wake up all threads waiting on this condition.  */
+static inline int
+__gthread_objc_condition_broadcast (objc_condition_t condition UNUSED)
+{
+  return 0;
+}
+
+/* Wake up one thread waiting on this condition.  */
+static inline int
+__gthread_objc_condition_signal (objc_condition_t condition UNUSED)
+{
+  return 0;
+}
+
+#else /* _LIBOBJC */
+
+int
+__gthread_active_p (void);
+
+int
+__gthread_once (__gthread_once_t *__once UNUSED, void (*__func) (void) UNUSED);
+
+int UNUSED
+__gthread_key_create (__gthread_key_t *__key UNUSED, void (*__func) (void *) UNUSED);
+
+int UNUSED
+__gthread_key_delete (__gthread_key_t __key UNUSED);
+
+void *
+__gthread_getspecific (__gthread_key_t __key UNUSED);
+
+int
+__gthread_setspecific (__gthread_key_t __key UNUSED, const void *__v UNUSED);
+
+int
+__gthread_mutex_destroy (__gthread_mutex_t *__mutex UNUSED);
+
+int
+__gthread_mutex_lock (__gthread_mutex_t *__mutex UNUSED);
+
+int
+__gthread_mutex_trylock (__gthread_mutex_t *__mutex UNUSED);
+
+int
+__gthread_mutex_unlock (__gthread_mutex_t *__mutex UNUSED);
+
+int
+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex);
+
+int
+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex);
+
+int
+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex);
+
+int
+__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex);
+
+/******************************************************************************/
+
+int
+__gthread_cond_broadcast (__gthread_cond_t *cond);
+
+int
+__gthread_cond_wait (__gthread_cond_t *cond, __gthread_mutex_t *mutex);
+
+int
+__gthread_cond_wait_recursive (__gthread_cond_t *cond,
+                               __gthread_recursive_mutex_t *mutex);
+
+int
+__gthread_cond_destroy (__gthread_cond_t *__cond);
+
+/******************************************************************************/
+
+int
+__gthread_create (__gthread_t *thread, void *(*func) (void*), void *args);
+
+int
+__gthread_join (__gthread_t thread, void **value_ptr);
+
+int
+__gthread_detach (__gthread_t thread);
+
+int
+__gthread_equal (__gthread_t t1, __gthread_t t2);
+
+__gthread_t
+__gthread_self (void);
+
+int
+__gthread_yield (void);
+
+int
+__gthread_mutex_timedlock (__gthread_mutex_t *m, const __gthread_time_t *abs_timeout);
+
+int
+__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *m,
+                                    const __gthread_time_t *abs_time);
+
+int
+__gthread_cond_signal (__gthread_cond_t *cond);
+
+int
+__gthread_cond_timedwait (__gthread_cond_t *cond,
+                             __gthread_mutex_t *mutex,
+                             const __gthread_time_t *abs_timeout);
+
+#endif /* _LIBOBJC */
+
+#undef UNUSED
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ! GCC_GTHR_AMIGAOS_H */
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 0789c9f050c0e282cf99f0e1ee807b50832e00e5..22fb42c3142901a281b718ac09b04c0ad9e74627 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -15175,12 +15175,13 @@ $as_echo_n "checking for thread model used by GCC... " >&6; }
   target_thread_file=`$CXX -v 2>&1 | sed -n 's/^Thread model: //p'`
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $target_thread_file" >&5
 $as_echo "$target_thread_file" >&6; }
 
 case $target_thread_file in
     aix)	thread_header=config/rs6000/gthr-aix.h ;;
+    amigaos)	thread_header=gthr-amigaos.h ;;
     dce)	thread_header=config/pa/gthr-dce.h ;;
     lynx)	thread_header=config/gthr-lynx.h ;;
     mipssde)	thread_header=config/mips/gthr-mipssde.h ;;
     posix)	thread_header=gthr-posix.h ;;
     rtems)	thread_header=config/gthr-rtems.h ;;
     single)	thread_header=gthr-single.h ;;
@@ -15395,13 +15396,13 @@ $as_echo "$glibcxx_cv_atomic_long_long" >&6; }
   # Compile unoptimized.
   CXXFLAGS='-O0 -S'
 
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15401 "configure"
+#line 15402 "configure"
 int main()
 {
   typedef bool atomic_type;
   atomic_type c1;
   atomic_type c2;
   atomic_type c3(0);
@@ -15430,13 +15431,13 @@ $as_echo_n "checking for atomic builtins for bool... " >&6; }
     fi
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_atomic_bool" >&5
 $as_echo "$glibcxx_cv_atomic_bool" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15436 "configure"
+#line 15437 "configure"
 int main()
 {
   typedef short atomic_type;
   atomic_type c1;
   atomic_type c2;
   atomic_type c3(0);
@@ -15465,13 +15466,13 @@ $as_echo_n "checking for atomic builtins for short... " >&6; }
     fi
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_atomic_short" >&5
 $as_echo "$glibcxx_cv_atomic_short" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15471 "configure"
+#line 15472 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
   typedef int atomic_type;
   atomic_type c1;
   atomic_type c2;
@@ -15501,13 +15502,13 @@ $as_echo_n "checking for atomic builtins for int... " >&6; }
     fi
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_cv_atomic_int" >&5
 $as_echo "$glibcxx_cv_atomic_int" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15507 "configure"
+#line 15508 "configure"
 int main()
 {
   typedef long long atomic_type;
   atomic_type c1;
   atomic_type c2;
   atomic_type c3(0);
@@ -15582,13 +15583,13 @@ $as_echo "$as_me: WARNING: Performance of certain classes will degrade as a resu
 
 
   # Fake what AC_TRY_COMPILE does, without linking as this is
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15588 "configure"
+#line 15589 "configure"
 int main()
 {
   _Decimal32 d1;
   _Decimal64 d2;
   _Decimal128 d3;
   return 0;
@@ -15624,13 +15625,13 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 
 
   # Fake what AC_TRY_COMPILE does, without linking as this is
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15630 "configure"
+#line 15631 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
 
 template<typename T>
   struct same<T, T>;
@@ -15658,13 +15659,13 @@ $as_echo "#define _GLIBCXX_USE_INT128 1" >>confdefs.h
     fi
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_int128" >&5
 $as_echo "$enable_int128" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15664 "configure"
+#line 15665 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
 
 template<typename T>
   struct same<T, T>;
-- 
2.14.2

