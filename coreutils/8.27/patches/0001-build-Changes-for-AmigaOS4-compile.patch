From 03f00e295dc36ceb7640d6265f06b6b4b044386f Mon Sep 17 00:00:00 2001
From: Sebastian Bauer <mail@sebastianbauer.info>
Date: Wed, 30 May 2018 11:32:48 +0200
Subject: [PATCH 1/2] build: Changes for AmigaOS4 compile

This is based on https://github.com/adtools/coreutils commit
f94b6dd850452b3260397caee6f983ef59f25df1.
---
 AutoInstall/AutoInstall |  106 +
 AutoInstall/SubScript   |    6 +
 Makefile.am             |    3 -
 README.os4              |   54 +
 bootstrap               |    6 +-
 bootstrap.conf          |    2 -
 configure.ac            |   38 -
 src/copy.c              |    1 +
 src/cp.c                |   31 +
 src/csplit.c            |   10 +
 src/cut.c               |  875 ++++---
 src/dd.c                |    6 +
 src/fmt.c               |   44 +-
 src/force-link.c        |    7 +
 src/install.c           |   11 +-
 src/kill.c              |   10 +
 src/local.mk            |    9 -
 src/ls.c                |   20 +
 src/od.c                |   16 +-
 src/operand2sig.c       |    8 +-
 src/ptx.c               |   30 +-
 src/sort.c              | 5035 +++++++++++----------------------------
 src/split.c             | 1730 +++-----------
 src/stat.c              |    4 +
 src/stdbuf.c            |   20 +
 src/tee.c               |    2 +
 26 files changed, 2667 insertions(+), 5417 deletions(-)
 create mode 100644 AutoInstall/AutoInstall
 create mode 100644 AutoInstall/SubScript
 create mode 100644 README.os4

diff --git a/AutoInstall/AutoInstall b/AutoInstall/AutoInstall
new file mode 100644
index 0000000000000000000000000000000000000000..907b9bcf19359343b575b979592756c6abdf3137
--- /dev/null
+++ b/AutoInstall/AutoInstall
@@ -0,0 +1,106 @@
+IF EXISTS SDK:
+   ECHO "Installing GNU Coreutils"
+
+   DELETE SDK:Local/C/coreutils FORCE
+   Copy SDK/#? SDK: ALL CLONE QUIET
+
+   EXECUTE SubScript [
+   EXECUTE SubScript b2sum
+   EXECUTE SubScript base32
+   EXECUTE SubScript base64
+   EXECUTE SubScript basename
+   EXECUTE SubScript cat
+   EXECUTE SubScript chcon
+   EXECUTE SubScript chgrp
+   EXECUTE SubScript chmod
+   EXECUTE SubScript cksum
+   EXECUTE SubScript comm
+   EXECUTE SubScript cp
+   EXECUTE SubScript csplit
+   EXECUTE SubScript cut
+   EXECUTE SubScript date
+   EXECUTE SubScript dd
+   EXECUTE SubScript dir
+   EXECUTE SubScript dircolors
+   EXECUTE SubScript dirname
+   EXECUTE SubScript du
+   EXECUTE SubScript echo
+   EXECUTE SubScript env
+   EXECUTE SubScript expand
+   EXECUTE SubScript expr
+   EXECUTE SubScript factor
+   EXECUTE SubScript false
+   EXECUTE SubScript fmt
+   EXECUTE SubScript fold
+   EXECUTE SubScript ginstall
+   EXECUTE SubScript groups
+   EXECUTE SubScript head
+   EXECUTE SubScript hostid
+   EXECUTE SubScript id
+   EXECUTE SubScript join
+   EXECUTE SubScript kill
+   EXECUTE SubScript link
+   EXECUTE SubScript ln
+   EXECUTE SubScript logname
+   EXECUTE SubScript ls
+   EXECUTE SubScript md5sum
+   EXECUTE SubScript mkdir
+   EXECUTE SubScript mkfifo
+   EXECUTE SubScript mknod
+   EXECUTE SubScript mktemp
+   EXECUTE SubScript mv
+   EXECUTE SubScript nl
+   EXECUTE SubScript nproc
+   EXECUTE SubScript numfmt
+   EXECUTE SubScript od
+   EXECUTE SubScript paste
+   EXECUTE SubScript pathchk
+   EXECUTE SubScript pr
+   EXECUTE SubScript printenv
+   EXECUTE SubScript printf
+   EXECUTE SubScript ptx
+   EXECUTE SubScript pwd
+   EXECUTE SubScript readlink
+   EXECUTE SubScript realpath
+   EXECUTE SubScript rm
+   EXECUTE SubScript rmdir
+   EXECUTE SubScript runcon
+   EXECUTE SubScript seq
+   EXECUTE SubScript sha1sum
+   EXECUTE SubScript sha224sum
+   EXECUTE SubScript sha256sum
+   EXECUTE SubScript sha384sum
+   EXECUTE SubScript sha512sum
+   EXECUTE SubScript shred
+   EXECUTE SubScript shuf
+   EXECUTE SubScript sleep
+   EXECUTE SubScript sort
+   EXECUTE SubScript split
+   EXECUTE SubScript stat
+   EXECUTE SubScript stdbuf
+   EXECUTE SubScript sum
+   EXECUTE SubScript sync
+   EXECUTE SubScript tac
+   EXECUTE SubScript tail
+   EXECUTE SubScript tee
+   EXECUTE SubScript test
+   EXECUTE SubScript touch
+   EXECUTE SubScript tr
+   EXECUTE SubScript true
+   EXECUTE SubScript truncate
+   EXECUTE SubScript tsort
+   EXECUTE SubScript tty
+   EXECUTE SubScript uname
+   EXECUTE SubScript unexpand
+   EXECUTE SubScript uniq
+   EXECUTE SubScript unlink
+   EXECUTE SubScript users
+   EXECUTE SubScript vdir
+   EXECUTE SubScript wc
+   EXECUTE SubScript who
+   EXECUTE SubScript whoami
+   EXECUTE SubScript yes
+
+   ECHO "Done installing GNU Coreutils"
+
+ENDIF
\ No newline at end of file
diff --git a/AutoInstall/SubScript b/AutoInstall/SubScript
new file mode 100644
index 0000000000000000000000000000000000000000..a0172ad3ec616830b224add4417dfdcfd8b144a2
--- /dev/null
+++ b/AutoInstall/SubScript
@@ -0,0 +1,6 @@
+.KEY filename/A
+PUSHCD >NIL:
+CD SDK:Local/C
+DELETE <filename> FORCE
+MAKELINK FROM <filename> TO coreutils SOFT
+POPCD
diff --git a/Makefile.am b/Makefile.am
index 68f537cef85f0eecc8f5dadf14263a17464aca8d..e2d473f6a50d54b5304407bdf14dda8f0b675685 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -210,9 +210,6 @@ CLEANFILES =
 MOSTLYCLEANDIRS =
 
 AM_CPPFLAGS = -Ilib -I$(top_srcdir)/lib -Isrc -I$(top_srcdir)/src
 
 include $(top_srcdir)/lib/local.mk
 include $(top_srcdir)/src/local.mk
-include $(top_srcdir)/doc/local.mk
-include $(top_srcdir)/man/local.mk
-include $(top_srcdir)/tests/local.mk
diff --git a/README.os4 b/README.os4
new file mode 100644
index 0000000000000000000000000000000000000000..d2f009447c207696f11732335a55b8940591efe1
--- /dev/null
+++ b/README.os4
@@ -0,0 +1,54 @@
+coreutils 8.29 ported to AmigaOS4.
+
+The sourcecode can be found on: https://github.com/adtools/coreutils
+
+Please read the original README file that is in the same directory.
+
+Best regards,
+Henning Nielsen Lund
+hnl_dk@amigaos.dk
+
+
+
+27-08-2017 - Version 54.11
+Trust the clib2 version of getcwd.
+
+27-08-2017 - Version 54.10
+Use the clib2 versions of localtime/gettimeofday directly.
+
+25-08-2017 - Version 54.9
+Setup the environment in clib2.
+
+19-08-2017 - Version 54.8
+no need to try to open /dev/tty.
+changed the sourcecode, so it should now also be possible to compile for classic AmigaOS (using clib2).
+
+18-08-2017 - Version 54.7
+replace /dev/null with /nil.
+recognice Amiga style absolute paths.
+
+15-08-2017 - Version 54.6
+ls is now also respecting amiga style absolute paths.
+kill should now be able to kill a process.
+
+14-08-2017 - Version 54.5
+stat is now able to read the filesystem data.
+use the clib2 fseeko implementation instead of the GNUlib version.
+
+14-08-2017 - Version 54.4
+Error() has now been fixed, will no longer crash, when you for example access a nonexisting file.
+Thanks to Hubert Maier (Raziel) for reporting this problem.
+
+13-08-2017 - Version 54.3
+cp did not copy permissions correctly. Hack it to set executable, just in case. This should be fixed later.
+Revert cut to an older code, as fgetc() corrupted the stream with the newer codebase. Will look into this. Thanks to Hubert Maier (Raziel) for reporting this problem.
+
+08-08-2017 - Version 54.2
+We do not have proc filesystem. Replace with AmigaOS4 code.
+Handle paths correctly.
+Cleanup Configure.ac and Makefile.am, to disable the creation of documents (generated from the help files).
+
+06-08-2017 - Version 54.1
+Coreutils 8.29 source used for the port
+The sourcecode for Sort and Split have been replaced with the old 5.2.1-9 code.
+To compile you need libwide found on http://os4depot.net and the current clib2 code from http://github.com/adtools/clib2
diff --git a/bootstrap b/bootstrap
index 6a21392d44e99d6fd409d39c8c84050ef0c4a6ab..aa4869c1150a57aba25f75cc20404a45f9ce23fb 100755
--- a/bootstrap
+++ b/bootstrap
@@ -207,13 +207,17 @@ vc_ignore=auto
 
 # Set this to true in bootstrap.conf to enable --bootstrap-sync by
 # default.
 bootstrap_sync=false
 
 # Use git to update gnulib sources
-use_git=true
+#use_git=true
+
+# Don't use git and point to custom dir
+use_git=false
+GNULIB_SRCDIR=../../gnulib/repo
 
 check_exists() {
   if test "$1" = "--verbose"; then
     ($2 --version </dev/null) >/dev/null 2>&1
     if test $? -ge 126; then
       # If not found, run with diagnostics as one may be
diff --git a/bootstrap.conf b/bootstrap.conf
index 7def1f99a631de7a53c247ef128eeee4aa7dd642..96db8c3334c41af8312b1ab775bc480174fe4c20 100644
--- a/bootstrap.conf
+++ b/bootstrap.conf
@@ -159,15 +159,13 @@ gnulib_modules="
   memcasecmp
   memchr
   memcmp2
   mempcpy
   memrchr
   mgetgroups
-  mkancesdirs
   mkdir
-  mkdir-p
   mkfifo
   mknod
   mkstemp
   mktime
   modechange
   mountlist
diff --git a/configure.ac b/configure.ac
index 7c7c8c23829220d0459f44b12a43de61639a7a5e..7463389f7ed17add3dbed038eea7e9dc05c3302d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -245,18 +245,14 @@ if test "$gl_single_binary" = 'symlinks'; then
 fi
 AM_CONDITIONAL([SINGLE_BINARY], [test "$gl_single_binary" != no])
 
 AC_FUNC_FORK
 
 optional_bin_progs=
-AC_CHECK_FUNCS([chroot],
-        gl_ADD_PROG([optional_bin_progs], [chroot]))
 AC_CHECK_FUNCS([gethostid],
         gl_ADD_PROG([optional_bin_progs], [hostid]))
-AC_CHECK_FUNCS([sigsuspend],
-        gl_ADD_PROG([optional_bin_progs], [timeout]))
 
 gl_WINSIZE_IN_PTEM
 
 AC_MSG_CHECKING([whether localtime caches TZ])
 AC_CACHE_VAL([utils_cv_localtime_cache],
 [if test x$ac_cv_func_tzset = xyes; then
@@ -333,27 +329,19 @@ AC_CACHE_CHECK([for 3-argument setpriority function],
        [[#include <sys/time.h>
          #include <sys/resource.h>
        ]],
        [[setpriority (0, 0, 0);]])],
     [utils_cv_func_setpriority=yes],
     [utils_cv_func_setpriority=no])])
-if test $utils_cv_func_setpriority = no; then
-  AC_CHECK_FUNCS([nice])
-fi
-case $utils_cv_func_setpriority,$ac_cv_func_nice in
-*yes*)
-  gl_ADD_PROG([optional_bin_progs], [nice])
-esac
 
 AC_DEFUN([coreutils_DUMMY_1],
 [
   AC_REQUIRE([gl_READUTMP])
   if test $ac_cv_header_utmp_h = yes || test $ac_cv_header_utmpx_h = yes; then
     gl_ADD_PROG([optional_bin_progs], [who])
     gl_ADD_PROG([optional_bin_progs], [users])
-    gl_ADD_PROG([optional_bin_progs], [pinky])
   fi
 ])
 coreutils_DUMMY_1
 
 AC_MSG_CHECKING([ut_host in struct utmp])
 AC_CACHE_VAL([su_cv_func_ut_host_in_utmp],
@@ -388,14 +376,12 @@ fi
 GNULIB_BOOT_TIME([gl_ADD_PROG([optional_bin_progs], [uptime])])
 
 AC_SYS_POSIX_TERMIOS()
 gl_HEADER_TIOCGWINSZ_NEEDS_SYS_IOCTL
 
 if test $ac_cv_sys_posix_termios = yes; then
-  gl_ADD_PROG([optional_bin_progs], [stty])
-
   AC_MSG_CHECKING([whether termios.h needs _XOPEN_SOURCE])
   AC_CACHE_VAL([su_cv_sys_termios_needs_xopen_source],
   [AC_EGREP_CPP([yes], [#include <termios.h>
 #ifdef IUCLC
 yes
 #endif], su_cv_sys_termios_needs_xopen_source=no,
@@ -511,37 +497,18 @@ m4_include([m4/cu-progs.m4])
 # may need to be updated accordingly.
 case " $optional_bin_progs " in
   *' stdbuf '*) pkglibexec_PROGRAMS='src/libstdbuf.so';;
   *) pkglibexec_PROGRAMS='';;
 esac
 
-man1_MANS=`
-  for p in $optional_bin_progs; do
-    # Change "ginstall.1" to "install.1".
-    test $p = ginstall && p=install
-    # Ignore the "[" program, since writing a portable make rule to
-    # generate its manpage is not practical.
-    dnl Use the autoconf-provided quadrigraph to represent "[",
-    dnl otherwise we will incur in dreadful quoting issues.
-    test x$p = x'@<:@' && continue
-    echo "man/$p.1"
-  done`
-
-# Not installed by "make install", but must be built when creating
-# a distribution tarball.
-EXTRA_MANS=`for p in $no_install_progs_default $gl_no_install_prog; do
-              echo man/$p.1
-            done`
-
 # Replace all the programs by the single binary and symlinks if specified.
 single_binary_progs=
 single_binary_libs=
 single_binary_deps=
 single_binary_install_type=
 if test "$gl_single_binary" != no; then
-  man1_MANS="$man1_MANS man/coreutils.1"
   # Convert the list to a space separated list
   gl_single_binary_exceptions=`echo $gl_single_binary_exceptions | tr ',' ' '`
 
   single_binary_progs=`echo $optional_bin_progs`
   optional_bin_progs="coreutils"
   for prog in $gl_single_binary_exceptions; do
@@ -582,22 +549,17 @@ AC_SUBST([single_binary_install_type], [$single_binary_install_type])
 # Since this is AC_SUBST'd, Automake won't be able to perform rewrite
 # with $(EXEEXT) appending on it, so we have to do it ourselves -- in
 # this case, only for $(bin_PROGRAMS).
 bin_PROGRAMS=`
   for p in $optional_bin_progs; do echo src/"$p"'$(EXEEXT)'; done`
 
-# Normalize whitespace.
-man1_MANS=`echo $man1_MANS`
-EXTRA_MANS=`echo $EXTRA_MANS`
 bin_PROGRAMS=`echo $bin_PROGRAMS`
 pkglibexec_PROGS=`echo $pkglibexec_PROGRAMS`
 
 AC_SUBST([bin_PROGRAMS])        AM_SUBST_NOTMAKE([bin_PROGRAMS])
 AC_SUBST([pkglibexec_PROGRAMS]) AM_SUBST_NOTMAKE([pkglibexec_PROGRAMS])
-AC_SUBST([man1_MANS])           AM_SUBST_NOTMAKE([man1_MANS])
-AC_SUBST([EXTRA_MANS])          AM_SUBST_NOTMAKE([EXTRA_MANS])
 
 AC_SUBST([built_programs], [$optional_bin_progs])
 
 AM_CONDITIONAL([CROSS_COMPILING], [test "$cross_compiling" = yes])
 
 ############################################################################
diff --git a/src/copy.c b/src/copy.c
index 7bfbcfcd088df2851b135494598864f455abf7c7..a28f39f85b189de15c8560980de76988e9ffa134 100644
--- a/src/copy.c
+++ b/src/copy.c
@@ -93,12 +93,13 @@
 #ifndef HAVE_LCHOWN
 # define HAVE_LCHOWN false
 # define lchown(name, uid, gid) chown (name, uid, gid)
 #endif
 
 #ifndef HAVE_MKFIFO
+# undef mkfifo //from src/system.h
 static int
 rpl_mkfifo (char const *file, mode_t mode)
 {
   errno = ENOTSUP;
   return -1;
 }
diff --git a/src/cp.c b/src/cp.c
index a2f67d864b477738a6f36d727b660e6cb9af4703..edadf9507f0424d57b1385dc813f8dac351ea7e4 100644
--- a/src/cp.c
+++ b/src/cp.c
@@ -33,12 +33,17 @@
 #include "ignore-value.h"
 #include "quote.h"
 #include "stat-time.h"
 #include "utimens.h"
 #include "acl.h"
 
+#if defined __amigaos4__ && defined __CLIB2__ /* AmigaOS4 CLIB2 */
+# include <dos.h>
+# include <proto/dos.h>
+#endif
+
 #if ! HAVE_LCHOWN
 # define lchown(name, uid, gid) chown (name, uid, gid)
 #endif
 
 #define ASSIGN_BASENAME_STRDUPA(Dest, File_name)	\
   do							\
@@ -771,12 +776,38 @@ do_copy (int n_files, char **file, const char *target_directory,
         }
       else
         {
           new_dest = dest;
         }
 
+#if defined __amigaos4__ && defined __CLIB2__ /* AmigaOS4 CLIB2 */
+        // Hack as we do not get the correct permissions if the destination does not exist before the copy. But this results in executive permissions no matter what.
+# warning "AmigaOS4 fix me"
+	const char *amigasrc = source;
+	struct name_translation_info nti;
+
+	__translate_unix_to_amiga_path_name(&amigasrc,&nti);
+	BPTR srclock = IDOS->Lock(amigasrc, SHARED_LOCK);
+	IDOS->UnLock(srclock);
+
+        if (srclock != ZERO)
+        {
+	  const char *amigadst = new_dest;
+          struct name_translation_info nti;
+
+          __translate_unix_to_amiga_path_name(&amigadst,&nti);
+          BPTR dstlock = IDOS->Lock(amigadst, SHARED_LOCK);
+          IDOS->UnLock(dstlock);
+
+          if (dstlock == ZERO)
+          {
+            BPTR file = IDOS->Open(amigadst, MODE_NEWFILE);
+            IDOS->Close(file);
+          }
+        }
+#endif
       ok = copy (source, new_dest, 0, x, &unused, NULL);
     }
 
   return ok;
 }
 
diff --git a/src/csplit.c b/src/csplit.c
index a3f30e8745e3e70f7229c733b2c90c8b5d31d81b..6247c234211f52a3b7bdd55e28bf1670e9888662 100644
--- a/src/csplit.c
+++ b/src/csplit.c
@@ -34,12 +34,17 @@
 #include "quote.h"
 #include "safe-read.h"
 #include "stdio--.h"
 #include "xdectoint.h"
 #include "xstrtol.h"
 
+#if defined __amigaos__ && defined __CLIB2__ /* AmigaOS using CLIB2 */
+// look in lib/sigaction.c
+int sigismember(const sigset_t *set, int signo);
+#endif
+
 /* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "csplit"
 
 #define AUTHORS \
   proper_name ("Stuart Kemp"), \
   proper_name ("David MacKenzie")
@@ -1424,14 +1429,19 @@ main (int argc, char **argv)
   parse_patterns (argc, optind, argv);
 
   {
     int i;
     static int const sig[] =
       {
+#if defined __amigaos__ && defined __CLIB2__ /* AmigaOS using CLIB2 */
+        /* The usual suspects.  */
+        SIGINT, SIGTERM,
+#else
         /* The usual suspects.  */
         SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
+#endif
 #ifdef SIGPOLL
         SIGPOLL,
 #endif
 #ifdef SIGPROF
         SIGPROF,
 #endif
diff --git a/src/cut.c b/src/cut.c
index 69b9fc46e68be206762465864208171ba3a86baf..178395bc8973953f46f32831c150e7df49dba295 100644
--- a/src/cut.c
+++ b/src/cut.c
@@ -1,22 +1,23 @@
 /* cut - remove parts of lines of files
-   Copyright (C) 1997-2017 Free Software Foundation, Inc.
+   Copyright (C) 1997-2004 Free Software Foundation, Inc.
    Copyright (C) 1984 David M. Ihnat
 
-   This program is free software: you can redistribute it and/or modify
+   This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 
 /* Written by David Ihnat.  */
 
 /* POSIX changes, bug fixes, long-named options, and cleanup
    by David MacKenzie <djm@gnu.ai.mit.edu>.
 
@@ -26,43 +27,61 @@
 
 #include <stdio.h>
 #include <assert.h>
 #include <getopt.h>
 #include <sys/types.h>
 #include "system.h"
+#include <ctype.h>
 
 #include "error.h"
-#include "fadvise.h"
 #include "getndelim2.h"
 #include "hash.h"
+#include "quote.h"
 #include "xstrndup.h"
 
-#include "set-fields.h"
+# ifdef isblank
+#  define ISBLANK(c) (ISASCII (c) && isblank (c))
+# else
+#  define ISBLANK(c) ((c) == ' ' || (c) == '\t')
+# endif
 
-/* The official name of this program (e.g., no 'g' prefix).  */
+/* The official name of this program (e.g., no `g' prefix).  */
 #define PROGRAM_NAME "cut"
 
-#define AUTHORS \
-  proper_name ("David M. Ihnat"), \
-  proper_name ("David MacKenzie"), \
-  proper_name ("Jim Meyering")
+#define AUTHORS "David Ihnat", "David MacKenzie", "Jim Meyering"
 
 #define FATAL_ERROR(Message)						\
   do									\
     {									\
       error (0, 0, (Message));						\
       usage (EXIT_FAILURE);						\
     }									\
   while (0)
 
+/* Append LOW, HIGH to the list RP of range pairs, allocating additional
+   space if necessary.  Update local variable N_RP.  When allocating,
+   update global variable N_RP_ALLOCATED.  */
 
-/* Pointer inside RP.  When checking if a byte or field is selected
-   by a finite range, we check if it is between CURRENT_RP.LO
-   and CURRENT_RP.HI.  If the byte or field index is greater than
-   CURRENT_RP.HI then we make CURRENT_RP to point to the next range pair. */
-static struct field_range_pair *current_rp;
+#define ADD_RANGE_PAIR(rp, low, high)					\
+  do									\
+    {									\
+      if (n_rp >= n_rp_allocated)					\
+	{								\
+	  (rp) = x2nrealloc (rp, &n_rp_allocated, sizeof *(rp));	\
+	}								\
+      rp[n_rp].lo = (low);						\
+      rp[n_rp].hi = (high);						\
+      ++n_rp;								\
+    }									\
+  while (0)
+
+struct range_pair
+  {
+    size_t lo;
+    size_t hi;
+  };
 
 /* This buffer is used to support the semantics of the -s option
    (or lack of same) when the specified field list includes (does
    not include) the first field.  In both of those cases, the entire
    first field must be read into this buffer to determine whether it
    is followed by a delimiter or a newline before any of it may be
@@ -70,40 +89,53 @@ static struct field_range_pair *current_rp;
    buffer.  */
 static char *field_1_buffer;
 
 /* The number of bytes allocated for FIELD_1_BUFFER.  */
 static size_t field_1_bufsize;
 
+/* The largest field or byte index used as an endpoint of a closed
+   or degenerate range specification;  this doesn't include the starting
+   index of right-open-ended ranges.  For example, with either range spec
+   `2-5,9-', `2-3,5,9-' this variable would be set to 5.  */
+static size_t max_range_endpoint;
+
+/* If nonzero, this is the index of the first field in a range that goes
+   to end of line. */
+static size_t eol_range_start;
+
+/* This is a bit vector.
+   In byte mode, which bytes to output.
+   In field mode, which DELIM-separated fields to output.
+   Both bytes and fields are numbered starting with 1,
+   so the zeroth bit of this array is unused.
+   A field or byte K has been selected if
+   (K <= MAX_RANGE_ENDPOINT and is_printable_field(K))
+    || (EOL_RANGE_START > 0 && K >= EOL_RANGE_START).  */
+static unsigned char *printable_field;
+
 enum operating_mode
   {
     undefined_mode,
 
     /* Output characters that are in the given bytes. */
     byte_mode,
 
-    /* Output the given delimiter-separated fields. */
+    /* Output the given delimeter-separated fields. */
     field_mode
   };
 
 static enum operating_mode operating_mode;
 
-/* If true do not output lines containing no delimiter characters.
+/* If true do not output lines containing no delimeter characters.
    Otherwise, all such lines are printed.  This option is valid only
    with field mode.  */
 static bool suppress_non_delimited;
 
-/* If true, print all bytes, characters, or fields _except_
-   those that were specified.  */
-static bool complement;
-
-/* The delimiter character for field mode. */
+/* The delimeter character for field mode. */
 static unsigned char delim;
 
-/* The delimiter for each line/record. */
-static unsigned char line_delim = '\n';
-
 /* True if the --output-delimiter=STRING option was specified.  */
 static bool output_delimiter_specified;
 
 /* The length of output_delimiter_string.  */
 static size_t output_delimiter_length;
 
@@ -111,123 +143,369 @@ static size_t output_delimiter_length;
    string consisting of the input delimiter.  */
 static char *output_delimiter_string;
 
 /* True if we have ever read standard input. */
 static bool have_read_stdin;
 
+#define HT_RANGE_START_INDEX_INITIAL_CAPACITY 31
+
+/* The set of range-start indices.  For example, given a range-spec list like
+   `-b1,3-5,4-9,15-', the following indices will be recorded here: 1, 3, 15.
+   Note that although `4' looks like a range-start index, it is in the middle
+   of the `3-5' range, so it doesn't count.
+   This table is created/used IFF output_delimiter_specified is set.  */
+static Hash_table *range_start_ht;
+
 /* For long options that have no equivalent short option, use a
    non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
 enum
 {
-  OUTPUT_DELIMITER_OPTION = CHAR_MAX + 1,
-  COMPLEMENT_OPTION
+  OUTPUT_DELIMITER_OPTION = CHAR_MAX + 1
 };
 
 static struct option const longopts[] =
 {
-  {"bytes", required_argument, NULL, 'b'},
-  {"characters", required_argument, NULL, 'c'},
-  {"fields", required_argument, NULL, 'f'},
-  {"delimiter", required_argument, NULL, 'd'},
-  {"only-delimited", no_argument, NULL, 's'},
-  {"output-delimiter", required_argument, NULL, OUTPUT_DELIMITER_OPTION},
-  {"complement", no_argument, NULL, COMPLEMENT_OPTION},
-  {"zero-terminated", no_argument, NULL, 'z'},
+  {"bytes", required_argument, 0, 'b'},
+  {"characters", required_argument, 0, 'c'},
+  {"fields", required_argument, 0, 'f'},
+  {"delimiter", required_argument, 0, 'd'},
+  {"only-delimited", no_argument, 0, 's'},
+  {"output-delimiter", required_argument, 0, OUTPUT_DELIMITER_OPTION},
   {GETOPT_HELP_OPTION_DECL},
   {GETOPT_VERSION_OPTION_DECL},
-  {NULL, 0, NULL, 0}
+  {0, 0, 0, 0}
 };
 
 void
 usage (int status)
 {
   if (status != EXIT_SUCCESS)
-    emit_try_help ();
+    fprintf (stderr, _("Try `%s --help' for more information.\n"),
+	     program_name);
   else
     {
       printf (_("\
-Usage: %s OPTION... [FILE]...\n\
+Usage: %s [OPTION]... [FILE]...\n\
 "),
-              program_name);
+	      program_name);
       fputs (_("\
 Print selected parts of lines from each FILE to standard output.\n\
+\n\
 "), stdout);
-
-      emit_stdin_note ();
-      emit_mandatory_arg_note ();
-
       fputs (_("\
-  -b, --bytes=LIST        select only these bytes\n\
-  -c, --characters=LIST   select only these characters\n\
+Mandatory arguments to long options are mandatory for short options too.\n\
+"), stdout);
+      fputs (_("\
+  -b, --bytes=LIST        output only these bytes\n\
+  -c, --characters=LIST   output only these characters\n\
   -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n\
 "), stdout);
       fputs (_("\
-  -f, --fields=LIST       select only these fields;  also print any line\n\
+  -f, --fields=LIST       output only these fields;  also print any line\n\
                             that contains no delimiter character, unless\n\
                             the -s option is specified\n\
   -n                      (ignored)\n\
-"), stdout);
-      fputs (_("\
-      --complement        complement the set of selected bytes, characters\n\
-                            or fields\n\
 "), stdout);
       fputs (_("\
   -s, --only-delimited    do not print lines not containing delimiters\n\
       --output-delimiter=STRING  use STRING as the output delimiter\n\
                             the default is to use the input delimiter\n\
-"), stdout);
-      fputs (_("\
-  -z, --zero-terminated    line delimiter is NUL, not newline\n\
 "), stdout);
       fputs (HELP_OPTION_DESCRIPTION, stdout);
       fputs (VERSION_OPTION_DESCRIPTION, stdout);
       fputs (_("\
 \n\
 Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n\
-range, or many ranges separated by commas.  Selected input is written\n\
-in the same order that it is read, and is written exactly once.\n\
-"), stdout);
-      fputs (_("\
-Each range is one of:\n\
+range, or many ranges separated by commas.  Each range is one of:\n\
 \n\
   N     N'th byte, character or field, counted from 1\n\
   N-    from N'th byte, character or field, to end of line\n\
   N-M   from N'th to M'th (included) byte, character or field\n\
   -M    from first to M'th (included) byte, character or field\n\
+\n\
+With no FILE, or when FILE is -, read standard input.\n\
 "), stdout);
-      emit_ancillary_info (PROGRAM_NAME);
+      printf (_("\nReport bugs to <%s>.\n"), PACKAGE_BUGREPORT);
     }
   exit (status);
 }
 
+static inline void
+mark_printable_field (size_t i)
+{
+  size_t n = i / CHAR_BIT;
+  printable_field[n] |= (1 << (i % CHAR_BIT));
+}
 
-/* Increment *ITEM_IDX (i.e., a field or byte index),
-   and if required CURRENT_RP.  */
+static inline bool
+is_printable_field (size_t i)
+{
+  size_t n = i / CHAR_BIT;
+  return (printable_field[n] >> (i % CHAR_BIT)) & 1;
+}
 
-static inline void
-next_item (size_t *item_idx)
+static size_t
+hash_int (const void *x, size_t tablesize)
 {
-  (*item_idx)++;
-  if ((*item_idx) > current_rp->hi)
-    current_rp++;
+  uintptr_t y = (uintptr_t) x;
+  return y % tablesize;
 }
 
-/* Return nonzero if the K'th field or byte is printable. */
+static bool
+hash_compare_ints (void const *x, void const *y)
+{
+  return (x == y) ? true : false;
+}
 
-static inline bool
-print_kth (size_t k)
+static bool
+is_range_start_index (size_t i)
 {
-  return current_rp->lo <= k;
+  return hash_lookup (range_start_ht, (void *) i) ? true : false;
 }
 
-/* Return nonzero if K'th byte is the beginning of a range. */
+/* Return nonzero if the K'th field or byte is printable.
+   When returning nonzero, if RANGE_START is non-NULL,
+   set *RANGE_START to true if K is the beginning of a range, and to
+   false otherwise.  */
 
-static inline bool
-is_range_start_index (size_t k)
+static bool
+print_kth (size_t k, bool *range_start)
+{
+  if (0 < eol_range_start && eol_range_start <= k)
+    {
+      if (range_start)
+	*range_start = (k == eol_range_start);
+      return true;
+    }
+
+  if (k <= max_range_endpoint && is_printable_field (k))
+    {
+      if (range_start)
+	*range_start = is_range_start_index (k);
+      return true;
+    }
+
+  return false;
+}
+
+/* Given the list of field or byte range specifications FIELDSTR, set
+   MAX_RANGE_ENDPOINT and allocate and initialize the PRINTABLE_FIELD
+   array.  If there is a right-open-ended range, set EOL_RANGE_START
+   to its starting index.  FIELDSTR should be composed of one or more
+   numbers or ranges of numbers, separated by blanks or commas.
+   Incomplete ranges may be given: `-m' means `1-m'; `n-' means `n'
+   through end of line.  Return true if FIELDSTR contains at least
+   one field specification, false otherwise.  */
+
+/* FIXME-someday:  What if the user wants to cut out the 1,000,000-th
+   field of some huge input file?  This function shouldn't have to
+   allocate a table of a million bits just so we can test every
+   field < 10^6 with an array dereference.  Instead, consider using
+   an adaptive approach: if the range of selected fields is too large,
+   but only a few fields/byte-offsets are actually selected, use a
+   hash table.  If the range of selected fields is too large, and
+   too many are selected, then resort to using the range-pairs (the
+   `rp' array) directly.  */
+
+static bool
+set_fields (const char *fieldstr)
 {
-  return k == current_rp->lo;
+  size_t initial = 1;		/* Value of first number in a range.  */
+  size_t value = 0;		/* If nonzero, a number being accumulated.  */
+  bool dash_found = false;	/* True if a '-' is found in this field.  */
+  bool field_found = false;	/* True if at least one field spec
+				   has been processed.  */
+
+  struct range_pair *rp = NULL;
+  size_t n_rp = 0;
+  size_t n_rp_allocated = 0;
+  size_t i;
+  bool in_digits = false;
+
+  /* Collect and store in RP the range end points.
+     It also sets EOL_RANGE_START if appropriate.  */
+
+  for (;;)
+    {
+      if (*fieldstr == '-')
+	{
+	  in_digits = false;
+	  /* Starting a range. */
+	  if (dash_found)
+	    FATAL_ERROR (_("invalid byte or field list"));
+	  dash_found = true;
+	  fieldstr++;
+
+	  if (value)
+	    {
+	      initial = value;
+	      value = 0;
+	    }
+	  else
+	    initial = 1;
+	}
+      else if (*fieldstr == ',' || ISBLANK (*fieldstr) || *fieldstr == '\0')
+	{
+	  in_digits = false;
+	  /* Ending the string, or this field/byte sublist. */
+	  if (dash_found)
+	    {
+	      dash_found = false;
+
+	      /* A range.  Possibilites: -n, m-n, n-.
+		 In any case, `initial' contains the start of the range. */
+	      if (value == 0)
+		{
+		  /* `n-'.  From `initial' to end of line. */
+		  eol_range_start = initial;
+		  field_found = true;
+		}
+	      else
+		{
+		  /* `m-n' or `-n' (1-n). */
+		  if (value < initial)
+		    FATAL_ERROR (_("invalid byte or field list"));
+
+		  /* Is there already a range going to end of line? */
+		  if (eol_range_start != 0)
+		    {
+		      /* Yes.  Is the new sequence already contained
+			 in the old one?  If so, no processing is
+			 necessary. */
+		      if (initial < eol_range_start)
+			{
+			  /* No, the new sequence starts before the
+			     old.  Does the old range going to end of line
+			     extend into the new range?  */
+			  if (eol_range_start <= value)
+			    {
+			      /* Yes.  Simply move the end of line marker. */
+			      eol_range_start = initial;
+			    }
+			  else
+			    {
+			      /* No.  A simple range, before and disjoint from
+				 the range going to end of line.  Fill it. */
+			      ADD_RANGE_PAIR (rp, initial, value);
+			    }
+
+			  /* In any case, some fields were selected. */
+			  field_found = true;
+			}
+		    }
+		  else
+		    {
+		      /* There is no range going to end of line. */
+		      ADD_RANGE_PAIR (rp, initial, value);
+		      field_found = true;
+		    }
+		  value = 0;
+		}
+	    }
+	  else if (value != 0)
+	    {
+	      /* A simple field number, not a range. */
+	      ADD_RANGE_PAIR (rp, value, value);
+	      value = 0;
+	      field_found = true;
+	    }
+
+	  if (*fieldstr == '\0')
+	    {
+	      break;
+	    }
+
+	  fieldstr++;
+	}
+      else if (ISDIGIT (*fieldstr))
+	{
+	  size_t new_v;
+	  /* Record beginning of digit string, in case we have to
+	     complain about it.  */
+	  static char const *num_start;
+	  if (!in_digits || !num_start)
+	    num_start = fieldstr;
+	  in_digits = true;
+
+	  /* Detect overflow.  */
+	  new_v = 10 * value + *fieldstr - '0';
+	  if (SIZE_MAX / 10 < value || new_v < value * 10)
+	    {
+	      /* In case the user specified -c4294967296-22,
+		 complain only about the first number.  */
+	      /* Determine the length of the offending number.  */
+	      size_t len = strspn (num_start, "0123456789");
+	      char *bad_num = xstrndup (num_start, len);
+	      if (operating_mode == byte_mode)
+		error (0, 0,
+		       _("byte offset %s is too large"), quote (bad_num));
+	      else
+		error (0, 0,
+		       _("field number %s is too large"), quote (bad_num));
+	      free (bad_num);
+	      exit (EXIT_FAILURE);
+	    }
+	  value = new_v;
+
+	  fieldstr++;
+	}
+      else
+	FATAL_ERROR (_("invalid byte or field list"));
+    }
+
+  max_range_endpoint = 0;
+  for (i = 0; i < n_rp; i++)
+    {
+      if (rp[i].hi > max_range_endpoint)
+	max_range_endpoint = rp[i].hi;
+    }
+
+  /* Allocate an array large enough so that it may be indexed by
+     the field numbers corresponding to all finite ranges
+     (i.e. `2-6' or `-4', but not `5-') in FIELDSTR.  */
+
+  printable_field = xzalloc (max_range_endpoint / CHAR_BIT + 1);
+
+  /* Set the array entries corresponding to integers in the ranges of RP.  */
+  for (i = 0; i < n_rp; i++)
+    {
+      size_t j;
+      for (j = rp[i].lo; j <= rp[i].hi; j++)
+	{
+	  mark_printable_field (j);
+	}
+    }
+
+  if (output_delimiter_specified)
+    {
+      /* Record the range-start indices.  */
+      for (i = 0; i < n_rp; i++)
+	{
+	  size_t j;
+	  for (j = rp[i].lo; j <= rp[i].hi; j++)
+	    {
+	      if (0 < j && is_printable_field (j)
+		  && !is_printable_field (j - 1))
+		{
+		  /* Record the fact that `j' is a range-start index.  */
+		  void *ent_from_table = hash_insert (range_start_ht,
+						      (void*) j);
+		  if (ent_from_table == NULL)
+		    {
+		      /* Insertion failed due to lack of memory.  */
+		      xalloc_die ();
+		    }
+		  assert ((size_t) ent_from_table == j);
+		}
+	    }
+	}
+    }
+
+  free (rp);
+
+  return field_found;
 }
 
 /* Read from stream STREAM, printing to standard output any selected bytes.  */
 
 static void
 cut_bytes (FILE *stream)
@@ -236,50 +514,45 @@ cut_bytes (FILE *stream)
   /* Whether to begin printing delimiters between ranges for the current line.
      Set after we've begun printing data corresponding to the first range.  */
   bool print_delimiter;
 
   byte_idx = 0;
   print_delimiter = false;
-  current_rp = frp;
-  while (true)
+  while (1)
     {
-      int c;		/* Each character from the file. */
+      register int c;		/* Each character from the file. */
 
       c = getc (stream);
 
-      if (c == line_delim)
-        {
-          putchar (c);
-          byte_idx = 0;
-          print_delimiter = false;
-          current_rp = frp;
-        }
+      if (c == '\n')
+	{
+	  putchar ('\n');
+	  byte_idx = 0;
+	  print_delimiter = false;
+	}
       else if (c == EOF)
-        {
-          if (byte_idx > 0)
-            putchar (line_delim);
-          break;
-        }
+	{
+	  if (byte_idx > 0)
+	    putchar ('\n');
+	  break;
+	}
       else
-        {
-          next_item (&byte_idx);
-          if (print_kth (byte_idx))
-            {
-              if (output_delimiter_specified)
-                {
-                  if (print_delimiter && is_range_start_index (byte_idx))
-                    {
-                      fwrite (output_delimiter_string, sizeof (char),
-                              output_delimiter_length, stdout);
-                    }
-                  print_delimiter = true;
-                }
-
-              putchar (c);
-            }
-        }
+	{
+	  bool range_start;
+	  bool *rs = output_delimiter_specified ? &range_start : NULL;
+	  if (print_kth (++byte_idx, rs))
+	    {
+	      if (rs && *rs && print_delimiter)
+		{
+		  fwrite (output_delimiter_string, sizeof (char),
+			  output_delimiter_length, stdout);
+		}
+	      print_delimiter = true;
+	      putchar (c);
+	    }
+	}
     }
 }
 
 /* Read from stream STREAM, printing to standard output any selected fields.  */
 
 static void
@@ -287,144 +560,118 @@ cut_fields (FILE *stream)
 {
   int c;
   size_t field_idx = 1;
   bool found_any_selected_field = false;
   bool buffer_first_field;
 
-  current_rp = frp;
-
   c = getc (stream);
   if (c == EOF)
     return;
 
   ungetc (c, stream);
-  c = 0;
 
   /* To support the semantics of the -s flag, we may have to buffer
-     all of the first field to determine whether it is 'delimited.'
+     all of the first field to determine whether it is `delimited.'
      But that is unnecessary if all non-delimited lines must be printed
      and the first field has been selected, or if non-delimited lines
      must be suppressed and the first field has *not* been selected.
      That is because a non-delimited line has exactly one field.  */
-  buffer_first_field = (suppress_non_delimited ^ !print_kth (1));
+  buffer_first_field = (suppress_non_delimited ^ !print_kth (1, NULL));
 
   while (1)
     {
       if (field_idx == 1 && buffer_first_field)
-        {
-          ssize_t len;
-          size_t n_bytes;
-
-          len = getndelim2 (&field_1_buffer, &field_1_bufsize, 0,
-                            GETNLINE_NO_LIMIT, delim, line_delim, stream);
-          if (len < 0)
-            {
-              free (field_1_buffer);
-              field_1_buffer = NULL;
-              if (ferror (stream) || feof (stream))
-                break;
-              xalloc_die ();
-            }
-
-          n_bytes = len;
-          assert (n_bytes != 0);
-
-          c = 0;
-
-          /* If the first field extends to the end of line (it is not
-             delimited) and we are printing all non-delimited lines,
-             print this one.  */
-          if (to_uchar (field_1_buffer[n_bytes - 1]) != delim)
-            {
-              if (suppress_non_delimited)
-                {
-                  /* Empty.  */
-                }
-              else
-                {
-                  fwrite (field_1_buffer, sizeof (char), n_bytes, stdout);
-                  /* Make sure the output line is newline terminated.  */
-                  if (field_1_buffer[n_bytes - 1] != line_delim)
-                    putchar (line_delim);
-                  c = line_delim;
-                }
-              continue;
-            }
-          if (print_kth (1))
-            {
-              /* Print the field, but not the trailing delimiter.  */
-              fwrite (field_1_buffer, sizeof (char), n_bytes - 1, stdout);
-
-              /* With -d$'\n' don't treat the last '\n' as a delimiter.  */
-              if (delim == line_delim)
-                {
-                  int last_c = getc (stream);
-                  if (last_c != EOF)
-                    {
-                      ungetc (last_c, stream);
-                      found_any_selected_field = true;
-                    }
-                }
-              else
-                found_any_selected_field = true;
-            }
-          next_item (&field_idx);
-        }
-
-      int prev_c = c;
-
-      if (print_kth (field_idx))
-        {
-          if (found_any_selected_field)
-            {
-              fwrite (output_delimiter_string, sizeof (char),
-                      output_delimiter_length, stdout);
-            }
-          found_any_selected_field = true;
-
-          while ((c = getc (stream)) != delim && c != line_delim && c != EOF)
-            {
-              putchar (c);
-              prev_c = c;
-            }
-        }
-      else
-        {
-          while ((c = getc (stream)) != delim && c != line_delim && c != EOF)
-            {
-              prev_c = c;
-            }
-        }
-
-      /* With -d$'\n' don't treat the last '\n' as a delimiter.  */
-      if (delim == line_delim && c == delim)
-        {
-          int last_c = getc (stream);
-          if (last_c != EOF)
-            ungetc (last_c, stream);
-          else
-            c = last_c;
-        }
+	{
+	  ssize_t len;
+	  size_t n_bytes;
+
+	  len = getndelim2 (&field_1_buffer, &field_1_bufsize, 0, SIZE_MAX, delim, '\n', stream);
+	  if (len < 0)
+	    {
+	      if (ferror (stream) || feof (stream))
+		break;
+	      xalloc_die ();
+	    }
+
+	  n_bytes = len;
+	  assert (n_bytes != 0);
+
+	  /* If the first field extends to the end of line (it is not
+	     delimited) and we are printing all non-delimited lines,
+	     print this one.  */
+	  if ((unsigned char) field_1_buffer[n_bytes - 1] != delim)
+	    {
+	      if (suppress_non_delimited)
+		{
+		  /* Empty.  */
+		}
+	      else
+		{
+		  fwrite (field_1_buffer, sizeof (char), n_bytes, stdout);
+		  /* Make sure the output line is newline terminated.  */
+		  if (field_1_buffer[n_bytes - 1] != '\n')
+		    putchar ('\n');
+		}
+	      continue;
+	    }
+	  if (print_kth (1, NULL))
+	    {
+	      /* Print the field, but not the trailing delimiter.  */
+	      fwrite (field_1_buffer, sizeof (char), n_bytes - 1, stdout);
+	      found_any_selected_field = true;
+	    }
+	  ++field_idx;
+	}
+
+      if (c != EOF)
+	{
+	  if (print_kth (field_idx, NULL))
+	    {
+	      if (found_any_selected_field)
+		{
+		  fwrite (output_delimiter_string, sizeof (char),
+			  output_delimiter_length, stdout);
+		}
+	      found_any_selected_field = true;
+
+	      while ((c = getc (stream)) != delim && c != '\n' && c != EOF)
+		{
+		  putchar (c);
+		}
+	    }
+	  else
+	    {
+	      while ((c = getc (stream)) != delim && c != '\n' && c != EOF)
+		{
+		  /* Empty.  */
+		}
+	    }
+	}
+
+      if (c == '\n')
+	{
+	  c = getc (stream);
+	  if (c != EOF)
+	    {
+	      ungetc (c, stream);
+	      c = '\n';
+	    }
+	}
 
       if (c == delim)
-        next_item (&field_idx);
-      else if (c == line_delim || c == EOF)
-        {
-          if (found_any_selected_field
-              || !(suppress_non_delimited && field_idx == 1))
-            {
-              if (c == line_delim || prev_c != line_delim
-                  || delim == line_delim)
-                putchar (line_delim);
-            }
-          if (c == EOF)
-            break;
-          field_idx = 1;
-          current_rp = frp;
-          found_any_selected_field = false;
-        }
+	++field_idx;
+      else if (c == '\n' || c == EOF)
+	{
+	  if (found_any_selected_field
+	      || !(suppress_non_delimited && field_idx == 1))
+	    putchar ('\n');
+	  if (c == EOF)
+	    break;
+	  field_idx = 1;
+	  found_any_selected_field = false;
+	}
     }
 }
 
 static void
 cut_stream (FILE *stream)
 {
@@ -432,63 +679,60 @@ cut_stream (FILE *stream)
     cut_bytes (stream);
   else
     cut_fields (stream);
 }
 
 /* Process file FILE to standard output.
-   Return true if successful.  */
+   Return 0 if successful, 1 if not. */
 
-static bool
-cut_file (char const *file)
+static int
+cut_file (char *file)
 {
   FILE *stream;
 
   if (STREQ (file, "-"))
     {
       have_read_stdin = true;
       stream = stdin;
     }
   else
     {
       stream = fopen (file, "r");
       if (stream == NULL)
-        {
-          error (0, errno, "%s", quotef (file));
-          return false;
-        }
+	{
+	  error (0, errno, "%s", file);
+	  return 1;
+	}
     }
 
-  fadvise (stream, FADVISE_SEQUENTIAL);
-
   cut_stream (stream);
 
   if (ferror (stream))
     {
-      error (0, errno, "%s", quotef (file));
-      return false;
+      error (0, errno, "%s", file);
+      return 1;
     }
   if (STREQ (file, "-"))
     clearerr (stream);		/* Also clear EOF. */
   else if (fclose (stream) == EOF)
     {
-      error (0, errno, "%s", quotef (file));
-      return false;
+      error (0, errno, "%s", file);
+      return 1;
     }
-  return true;
+  return 0;
 }
 
 int
 main (int argc, char **argv)
 {
-  int optc;
-  bool ok;
+  int optc, exit_status = 0;
   bool delim_specified = false;
-  char *spec_list_string IF_LINT ( = NULL);
+  char *spec_list_string IF_LINT(= NULL);
 
   initialize_main (&argc, &argv);
-  set_program_name (argv[0]);
+  program_name = argv[0];
   setlocale (LC_ALL, "");
   bindtextdomain (PACKAGE, LOCALEDIR);
   textdomain (PACKAGE);
 
   atexit (close_stdout);
 
@@ -497,89 +741,98 @@ main (int argc, char **argv)
   /* By default, all non-delimited lines are printed.  */
   suppress_non_delimited = false;
 
   delim = '\0';
   have_read_stdin = false;
 
-  while ((optc = getopt_long (argc, argv, "b:c:d:f:nsz", longopts, NULL)) != -1)
+  while ((optc = getopt_long (argc, argv, "b:c:d:f:ns", longopts, NULL)) != -1)
     {
       switch (optc)
-        {
-        case 'b':
-        case 'c':
-          /* Build the byte list. */
-          if (operating_mode != undefined_mode)
-            FATAL_ERROR (_("only one type of list may be specified"));
-          operating_mode = byte_mode;
-          spec_list_string = optarg;
-          break;
-
-        case 'f':
-          /* Build the field list. */
-          if (operating_mode != undefined_mode)
-            FATAL_ERROR (_("only one type of list may be specified"));
-          operating_mode = field_mode;
-          spec_list_string = optarg;
-          break;
-
-        case 'd':
-          /* New delimiter. */
-          /* Interpret -d '' to mean 'use the NUL byte as the delimiter.'  */
-          if (optarg[0] != '\0' && optarg[1] != '\0')
-            FATAL_ERROR (_("the delimiter must be a single character"));
-          delim = optarg[0];
-          delim_specified = true;
-          break;
-
-        case OUTPUT_DELIMITER_OPTION:
-          output_delimiter_specified = true;
-          /* Interpret --output-delimiter='' to mean
-             'use the NUL byte as the delimiter.'  */
-          output_delimiter_length = (optarg[0] == '\0'
-                                     ? 1 : strlen (optarg));
-          output_delimiter_string = xstrdup (optarg);
-          break;
-
-        case 'n':
-          break;
-
-        case 's':
-          suppress_non_delimited = true;
-          break;
-
-        case 'z':
-          line_delim = '\0';
-          break;
-
-        case COMPLEMENT_OPTION:
-          complement = true;
-          break;
-
-        case_GETOPT_HELP_CHAR;
-
-        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
-
-        default:
-          usage (EXIT_FAILURE);
-        }
+	{
+	case 0:
+	  break;
+
+	case 'b':
+	case 'c':
+	  /* Build the byte list. */
+	  if (operating_mode != undefined_mode)
+	    FATAL_ERROR (_("only one type of list may be specified"));
+	  operating_mode = byte_mode;
+	  spec_list_string = optarg;
+	  break;
+
+	case 'f':
+	  /* Build the field list. */
+	  if (operating_mode != undefined_mode)
+	    FATAL_ERROR (_("only one type of list may be specified"));
+	  operating_mode = field_mode;
+	  spec_list_string = optarg;
+	  break;
+
+	case 'd':
+	  /* New delimiter. */
+	  /* Interpret -d '' to mean `use the NUL byte as the delimiter.'  */
+	  if (optarg[0] != '\0' && optarg[1] != '\0')
+	    FATAL_ERROR (_("the delimiter must be a single character"));
+	  delim = optarg[0];
+	  delim_specified = true;
+	  break;
+
+	case OUTPUT_DELIMITER_OPTION:
+	  output_delimiter_specified = true;
+	  /* Interpret --output-delimiter='' to mean
+	     `use the NUL byte as the delimiter.'  */
+	  output_delimiter_length = (optarg[0] == '\0'
+				     ? 1 : strlen (optarg));
+	  output_delimiter_string = xstrdup (optarg);
+	  break;
+
+	case 'n':
+	  break;
+
+	case 's':
+	  suppress_non_delimited = true;
+	  break;
+
+	case_GETOPT_HELP_CHAR;
+
+	case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
+
+	default:
+	  usage (EXIT_FAILURE);
+	}
     }
 
   if (operating_mode == undefined_mode)
     FATAL_ERROR (_("you must specify a list of bytes, characters, or fields"));
 
-  if (delim_specified && operating_mode != field_mode)
+  if (delim != '\0' && operating_mode != field_mode)
     FATAL_ERROR (_("an input delimiter may be specified only\
  when operating on fields"));
 
   if (suppress_non_delimited && operating_mode != field_mode)
     FATAL_ERROR (_("suppressing non-delimited lines makes sense\n\
 \tonly when operating on fields"));
 
-  set_fields (spec_list_string,
-              ( (operating_mode == field_mode) ? 0 : SETFLD_ERRMSG_USE_POS)
-              | (complement ? SETFLD_COMPLEMENT : 0) );
+  if (output_delimiter_specified)
+    {
+      range_start_ht = hash_initialize (HT_RANGE_START_INDEX_INITIAL_CAPACITY,
+					NULL, hash_int,
+					hash_compare_ints, NULL);
+      if (range_start_ht == NULL)
+	xalloc_die ();
+
+    }
+
+  if (! set_fields (spec_list_string))
+    {
+      if (operating_mode == field_mode)
+	FATAL_ERROR (_("missing list of fields"));
+      else
+	FATAL_ERROR (_("missing list of positions"));
+    }
 
   if (!delim_specified)
     delim = '\t';
 
   if (output_delimiter_string == NULL)
     {
@@ -588,22 +841,22 @@ main (int argc, char **argv)
       dummy[1] = '\0';
       output_delimiter_string = dummy;
       output_delimiter_length = 1;
     }
 
   if (optind == argc)
-    ok = cut_file ("-");
+    exit_status |= cut_file ("-");
   else
-    for (ok = true; optind < argc; optind++)
-      ok &= cut_file (argv[optind]);
+    for (; optind < argc; optind++)
+      exit_status |= cut_file (argv[optind]);
 
+  if (range_start_ht)
+    hash_free (range_start_ht);
 
   if (have_read_stdin && fclose (stdin) == EOF)
     {
       error (0, errno, "-");
-      ok = false;
+      exit_status = 1;
     }
 
-  IF_LINT (reset_fields ());
-
-  return ok ? EXIT_SUCCESS : EXIT_FAILURE;
+  exit (exit_status == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
 }
diff --git a/src/dd.c b/src/dd.c
index 3638a0a28ce11625fe982e86914e8355d22867af..525c37c01e34b7782bf2200e768a5452343d8248 100644
--- a/src/dd.c
+++ b/src/dd.c
@@ -58,12 +58,18 @@
 
 /* NonStop circa 2011 lacks SA_RESETHAND; see Bug#9076.  */
 #ifndef SA_RESETHAND
 # define SA_RESETHAND 0
 #endif
 
+#if defined __amigaos__ && defined __CLIB2__ /* AmigaOS using CLIB2 */
+# ifndef SIGUSR1
+#  define SIGUSR1 7
+# endif
+#endif
+
 #ifndef SIGINFO
 # define SIGINFO SIGUSR1
 #endif
 
 /* This may belong in GNULIB's fcntl module instead.
    Define O_CIO to 0 if it is not supported by this OS. */
diff --git a/src/fmt.c b/src/fmt.c
index 772b65e2e7e9f40f2c3a5eb6a6c496b67d452d95..1cd8d4cf62b0707899f17ea5402fde502d896c62 100644
--- a/src/fmt.c
+++ b/src/fmt.c
@@ -123,13 +123,13 @@ typedef long int COST;
 /* Size of a tab stop, for expansion on input and re-introduction on
    output.  */
 #define TABWIDTH	8
 
 /* Word descriptor structure.  */
 
-typedef struct Word WORD;
+typedef struct Word fmt_WORD;
 
 struct Word
   {
 
     /* Static attributes determined during input.  */
 
@@ -142,13 +142,13 @@ struct Word
     unsigned int final:1;	/* end of sentence */
 
     /* The remaining fields are computed during the optimization.  */
 
     int line_length;		/* length of the best line starting here */
     COST best_cost;		/* cost of best paragraph starting here */
-    WORD *next_break;		/* break which achieves best_cost */
+    fmt_WORD *next_break;		/* break which achieves best_cost */
   };
 
 /* Forward declarations.  */
 
 static void set_prefix (char *p);
 static void fmt (FILE *f);
@@ -157,18 +157,18 @@ static int get_line (FILE *f, int c);
 static int get_prefix (FILE *f);
 static int get_space (FILE *f, int c);
 static int copy_rest (FILE *f, int c);
 static bool same_para (int c);
 static void flush_paragraph (void);
 static void fmt_paragraph (void);
-static void check_punctuation (WORD *w);
-static COST base_cost (WORD *this);
-static COST line_cost (WORD *next, int len);
-static void put_paragraph (WORD *finish);
-static void put_line (WORD *w, int indent);
-static void put_word (WORD *w);
+static void check_punctuation (fmt_WORD *w);
+static COST base_cost (fmt_WORD *this);
+static COST line_cost (fmt_WORD *next, int len);
+static void put_paragraph (fmt_WORD *finish);
+static void put_line (fmt_WORD *w, int indent);
+static void put_word (fmt_WORD *w);
 static void put_space (int space);
 
 /* Option values.  */
 
 /* If true, first 2 lines may have different indent (default false).  */
 static bool crown;
@@ -217,18 +217,18 @@ static char parabuf[MAXCHARS];
 
 /* A pointer into parabuf, indicating the first unused character position.  */
 static char *wptr;
 
 /* The words of a paragraph -- longer paragraphs are handled neatly
    (cf. flush_paragraph()).  */
-static WORD word[MAXWORDS];
+static fmt_WORD word[MAXWORDS];
 
 /* A pointer into the above word array, indicating the first position
    after the last complete word.  Sometimes it will point at an incomplete
    word.  */
-static WORD *word_limit;
+static fmt_WORD *word_limit;
 
 /* If true, current input file contains tab characters, and so tabs can be
    used for white space on output.  */
 static bool tabs;
 
 /* Space before trimmed prefix on each line of the current paragraph.  */
@@ -661,13 +661,13 @@ same_para (int c)
 
 static int
 get_line (FILE *f, int c)
 {
   int start;
   char *end_of_parabuf;
-  WORD *end_of_word;
+  fmt_WORD *end_of_word;
 
   end_of_parabuf = &parabuf[MAXCHARS];
   end_of_word = &word[MAXWORDS - 2];
 
   do
     {				/* for each word in a line */
@@ -761,13 +761,13 @@ get_space (FILE *f, int c)
     }
 }
 
 /* Set extra fields in word W describing any attached punctuation.  */
 
 static void
-check_punctuation (WORD *w)
+check_punctuation (fmt_WORD *w)
 {
   char const *start = w->text;
   char const *finish = start + (w->length - 1);
   unsigned char fin = *finish;
 
   w->paren = isopen (*start);
@@ -780,14 +780,14 @@ check_punctuation (WORD *w)
 /* Flush part of the paragraph to make room.  This function is called on
    hitting the limit on the number of words or characters.  */
 
 static void
 flush_paragraph (void)
 {
-  WORD *split_point;
-  WORD *w;
+  fmt_WORD *split_point;
+  fmt_WORD *w;
   int shift;
   COST best_break;
 
   /* In the special case where it's all one word, just flush it.  */
 
   if (word_limit == word)
@@ -844,13 +844,13 @@ flush_paragraph (void)
    and remembering the optimal formatting for each suffix from the empty
    one to the whole paragraph.  */
 
 static void
 fmt_paragraph (void)
 {
-  WORD *start, *w;
+  fmt_WORD *start, *w;
   int len;
   COST wcost, best;
   int saved_length;
 
   word_limit->best_cost = 0;
   saved_length = word_limit->length;
@@ -898,13 +898,13 @@ fmt_paragraph (void)
 }
 
 /* Return the constant component of the cost of breaking before the
    word THIS.  */
 
 static COST
-base_cost (WORD *this)
+base_cost (fmt_WORD *this)
 {
   COST cost;
 
   cost = LINE_COST;
 
   if (this > word)
@@ -931,13 +931,13 @@ base_cost (WORD *this)
 }
 
 /* Return the component of the cost of breaking before word NEXT that
    depends on LEN, the length of the line beginning there.  */
 
 static COST
-line_cost (WORD *next, int len)
+line_cost (fmt_WORD *next, int len)
 {
   int n;
   COST cost;
 
   if (next == word_limit)
     return 0;
@@ -952,28 +952,28 @@ line_cost (WORD *next, int len)
 }
 
 /* Output to stdout a paragraph from word up to (but not including)
    FINISH, which must be in the next_break chain from word.  */
 
 static void
-put_paragraph (WORD *finish)
+put_paragraph (fmt_WORD *finish)
 {
-  WORD *w;
+  fmt_WORD *w;
 
   put_line (word, first_indent);
   for (w = word->next_break; w != finish; w = w->next_break)
     put_line (w, other_indent);
 }
 
 /* Output to stdout the line beginning with word W, beginning in column
    INDENT, including the prefix (if any).  */
 
 static void
-put_line (WORD *w, int indent)
+put_line (fmt_WORD *w, int indent)
 {
-  WORD *endline;
+  fmt_WORD *endline;
 
   out_column = 0;
   put_space (prefix_indent);
   fputs (prefix, stdout);
   out_column += prefix_length;
   put_space (indent - out_column);
@@ -989,13 +989,13 @@ put_line (WORD *w, int indent)
   putchar ('\n');
 }
 
 /* Output to stdout the word W.  */
 
 static void
-put_word (WORD *w)
+put_word (fmt_WORD *w)
 {
   const char *s;
   int n;
 
   s = w->text;
   for (n = w->length; n != 0; n--)
diff --git a/src/force-link.c b/src/force-link.c
index 15ebb8c187f8ada532197d944e680dd98366896e..cf0a41b6384e55c797fff0e76d2986a7c13c9673 100644
--- a/src/force-link.c
+++ b/src/force-link.c
@@ -27,12 +27,19 @@
 #include "system.h"
 
 #include "force-link.h"
 
 #include <tempname.h>
 
+#if defined __amigaos__ && defined __CLIB2__ /* AmigaOS using CLIB2 */
+#include "openat-priv.h"
+int renameat(int oldfd, const char *old, int newfd, const char *new){
+  return at_func2 (oldfd, old, newfd, new, rename);
+}
+#endif
+
 /* A basename pattern suitable for a temporary file.  It should work
    even on file systems like FAT that support only short names.
    "Cu" is short for "Coreutils" or for "Changeable unstable",
    take your pick....  */
 
 static char const simple_pattern[] = "CuXXXXXX";
diff --git a/src/install.c b/src/install.c
index 592c3452aec829f857a151a60e63f1209fb66720..839837f8dee8c8302d521751ac74eefc15518099 100644
--- a/src/install.c
+++ b/src/install.c
@@ -21,13 +21,15 @@
 #include <getopt.h>
 #include <sys/types.h>
 #include <signal.h>
 #include <pwd.h>
 #include <grp.h>
 #include <selinux/selinux.h>
-#include <sys/wait.h>
+#if !defined __amigaos__ /* AmigaOS */
+# include <sys/wait.h>
+#endif
 
 #include "system.h"
 #include "backupfile.h"
 #include "error.h"
 #include "cp-hash.h"
 #include "copy.h"
@@ -543,12 +545,18 @@ change_timestamps (struct stat const *src_sb, char const *dest)
    magic numbers vary so much from system to system that making
    it portable would be very difficult.  Not worth the effort. */
 
 static bool
 strip (char const *name)
 {
+#ifdef __amigaos__
+  char buffer[1024];
+  sprintf(buffer, "strip %s\n", name);
+
+  return system(buffer);
+#else
   int status;
   bool ok = false;
   pid_t pid = fork ();
 
   switch (pid)
     {
@@ -565,12 +573,13 @@ strip (char const *name)
         error (0, 0, _("strip process terminated abnormally"));
       else
         ok = true;      /* strip succeeded */
       break;
     }
   return ok;
+#endif
 }
 
 /* Initialize the user and group ownership of the files to install. */
 
 static void
 get_ids (void)
diff --git a/src/kill.c b/src/kill.c
index fd998790db4e8d49220a754df9e72b01a3a6471f..999d1eb611fd955b3b0e9e4d667f0c6eac57959f 100644
--- a/src/kill.c
+++ b/src/kill.c
@@ -19,12 +19,16 @@
 #include <config.h>
 #include <stdio.h>
 #include <getopt.h>
 #include <sys/types.h>
 #include <signal.h>
 
+#ifdef __amigaos4__
+#include <proto/dos.h>
+#endif
+
 #include "system.h"
 #include "error.h"
 #include "sig2str.h"
 #include "operand2sig.h"
 #include "quote.h"
 
@@ -198,13 +202,19 @@ send_signals (int signum, char *const *argv)
   do
     {
       char *endp;
       intmax_t n = (errno = 0, strtoimax (arg, &endp, 10));
       pid_t pid = n;
 
+#ifdef __amigaos4__
+      /* Convert the given process id (Cli number) to an address */
+      pid = (pid_t)IDOS->FindCliProc((uint32)n);
+      if (errno == ERANGE || arg == endp || *endp)
+#else
       if (errno == ERANGE || pid != n || arg == endp || *endp)
+#endif
         {
           error (0, 0, _("%s: invalid process id"), quote (arg));
           status = EXIT_FAILURE;
         }
       else if (kill (pid, signum) != 0)
         {
diff --git a/src/local.mk b/src/local.mk
index 9b2b172d264de43bcae36225c3cc1fa169c391a7..a48711208ab127b7f9044543f801d85a11e372ee 100644
--- a/src/local.mk
+++ b/src/local.mk
@@ -100,13 +100,12 @@ src_base32_LDADD = $(LDADD)
 src_basename_LDADD = $(LDADD)
 src_cat_LDADD = $(LDADD)
 src_chcon_LDADD = $(LDADD)
 src_chgrp_LDADD = $(LDADD)
 src_chmod_LDADD = $(LDADD)
 src_chown_LDADD = $(LDADD)
-src_chroot_LDADD = $(LDADD)
 src_cksum_LDADD = $(LDADD)
 src_comm_LDADD = $(LDADD)
 src_nproc_LDADD = $(LDADD)
 src_cp_LDADD = $(LDADD)
 if !SINGLE_BINARY
 src_coreutils_LDADD = $(LDADD)
@@ -150,20 +149,17 @@ src_make_prime_list_LDADD =
 src_md5sum_LDADD = $(LDADD)
 src_mkdir_LDADD = $(LDADD)
 src_mkfifo_LDADD = $(LDADD)
 src_mknod_LDADD = $(LDADD)
 src_mktemp_LDADD = $(LDADD)
 src_mv_LDADD = $(LDADD)
-src_nice_LDADD = $(LDADD)
 src_nl_LDADD = $(LDADD)
-src_nohup_LDADD = $(LDADD)
 src_numfmt_LDADD = $(LDADD)
 src_od_LDADD = $(LDADD)
 src_paste_LDADD = $(LDADD)
 src_pathchk_LDADD = $(LDADD)
-src_pinky_LDADD = $(LDADD)
 src_pr_LDADD = $(LDADD)
 src_printenv_LDADD = $(LDADD)
 src_printf_LDADD = $(LDADD)
 src_ptx_LDADD = $(LDADD)
 src_pwd_LDADD = $(LDADD)
 src_readlink_LDADD = $(LDADD)
@@ -181,20 +177,18 @@ src_shred_LDADD = $(LDADD)
 src_shuf_LDADD = $(LDADD)
 src_sleep_LDADD = $(LDADD)
 src_sort_LDADD = $(LDADD)
 src_split_LDADD = $(LDADD)
 src_stat_LDADD = $(LDADD)
 src_stdbuf_LDADD = $(LDADD)
-src_stty_LDADD = $(LDADD)
 src_sum_LDADD = $(LDADD)
 src_sync_LDADD = $(LDADD)
 src_tac_LDADD = $(LDADD)
 src_tail_LDADD = $(LDADD)
 src_tee_LDADD = $(LDADD)
 src_test_LDADD = $(LDADD)
-src_timeout_LDADD = $(LDADD)
 src_touch_LDADD = $(LDADD)
 src_tr_LDADD = $(LDADD)
 src_true_LDADD = $(LDADD)
 src_truncate_LDADD = $(LDADD)
 src_tsort_LDADD = $(LDADD)
 src_tty_LDADD = $(LDADD)
@@ -251,13 +245,12 @@ src_stat_LDADD += $(LIB_NVPAIR)
 # for gettime, settime, utimecmp, utimens
 copy_ldadd += $(LIB_CLOCK_GETTIME)
 src_date_LDADD += $(LIB_CLOCK_GETTIME)
 src_ginstall_LDADD += $(LIB_CLOCK_GETTIME)
 src_ls_LDADD += $(LIB_CLOCK_GETTIME)
 src_pr_LDADD += $(LIB_CLOCK_GETTIME)
-src_timeout_LDADD += $(LIB_TIMER_TIME)
 src_touch_LDADD += $(LIB_CLOCK_GETTIME)
 
 # for gethrxtime
 src_dd_LDADD += $(LIB_GETHRXTIME)
 
 # for cap_get_file
@@ -299,13 +292,12 @@ src_sha1sum_LDADD += $(LIB_CRYPTO)
 src_sha224sum_LDADD += $(LIB_CRYPTO)
 src_sha256sum_LDADD += $(LIB_CRYPTO)
 src_sha384sum_LDADD += $(LIB_CRYPTO)
 src_sha512sum_LDADD += $(LIB_CRYPTO)
 
 # for canon_host
-src_pinky_LDADD += $(GETADDRINFO_LIB)
 src_who_LDADD += $(GETADDRINFO_LIB)
 
 # for gethostname, uname
 src_hostname_LDADD += $(GETHOSTNAME_LIB)
 src_uname_LDADD += $(GETHOSTNAME_LIB)
 
@@ -363,13 +355,12 @@ src_ln_SOURCES = src/ln.c \
   src/force-link.c src/force-link.h \
   src/relpath.c src/relpath.h
 src_chown_SOURCES = src/chown.c src/chown-core.c
 src_chgrp_SOURCES = src/chgrp.c src/chown-core.c
 src_kill_SOURCES = src/kill.c src/operand2sig.c
 src_realpath_SOURCES = src/realpath.c src/relpath.c src/relpath.h
-src_timeout_SOURCES = src/timeout.c src/operand2sig.c
 
 src_mv_SOURCES = src/mv.c src/remove.c $(copy_sources) $(selinux_sources)
 src_rm_SOURCES = src/rm.c src/remove.c
 
 src_mkdir_SOURCES = src/mkdir.c src/prog-fprintf.c $(selinux_sources)
 src_rmdir_SOURCES = src/rmdir.c src/prog-fprintf.c
diff --git a/src/ls.c b/src/ls.c
index 73498181eda4b8fa7304229d2c3ebe138e3309fa..295983523d9998e4fc1c48e1f5c396d4d985b00e 100644
--- a/src/ls.c
+++ b/src/ls.c
@@ -59,12 +59,21 @@
 #include <wchar.h>
 
 #if HAVE_LANGINFO_CODESET
 # include <langinfo.h>
 #endif
 
+#if defined __amigaos__ && defined __CLIB2__ /* AmigaOS using CLIB2 */
+#ifndef SIGSTOP
+# define SIGSTOP (-1)
+#endif
+#ifndef SIGTSTP
+# define SIGTSTP (-1)
+#endif
+#endif
+
 /* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
    present.  */
 #ifndef SA_NOCLDSTOP
 # define SA_NOCLDSTOP 0
 # define sigprocmask(How, Set, Oset) /* empty */
 # define sigset_t int
@@ -1330,17 +1339,22 @@ process_signals (void)
 static void
 signal_setup (bool init)
 {
   /* The signals that are trapped, and the number of such signals.  */
   static int const sig[] =
     {
+#if defined __amigaos__ && defined __CLIB2__ /* AmigaOS using CLIB2 */
+      /* The usual suspects.  */
+      SIGINT, SIGTERM,
+#else
       /* This one is handled specially.  */
       SIGTSTP,
 
       /* The usual suspects.  */
       SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
+#endif
 #ifdef SIGPOLL
       SIGPOLL,
 #endif
 #ifdef SIGPROF
       SIGPROF,
 #endif
@@ -4864,14 +4878,20 @@ attach (char *dest, const char *dirname, const char *name)
   /* Copy dirname if it is not ".".  */
   if (dirname[0] != '.' || dirname[1] != 0)
     {
       while (*dirnamep)
         *dest++ = *dirnamep++;
       /* Add '/' if 'dirname' doesn't already end with it.  */
+#ifdef __amigaos__
+      /* For AmigaOS, we also need to check if there's a colon */
+      if (dirnamep > dirname && dirnamep[-1] != '/' && dirnamep[-1] != ':')
+        *dest++ = '/';
+#else
       if (dirnamep > dirname && dirnamep[-1] != '/')
         *dest++ = '/';
+#endif
     }
   while (*name)
     *dest++ = *name++;
   *dest = 0;
 }
 
diff --git a/src/od.c b/src/od.c
index f469326ffe841a39e02b48e2ec59f925a7dc0777..648a0a393fecda7f5053f6c099bb8aa22a1deac2 100644
--- a/src/od.c
+++ b/src/od.c
@@ -50,15 +50,15 @@ typedef unsigned long int unsigned_long_long_int;
 #endif
 
 enum size_spec
   {
     NO_SIZE,
     CHAR,
-    SHORT,
+    od_SHORT,
     INT,
-    LONG,
+    od_LONG,
     LONG_LONG,
     /* FIXME: add INTMAX support, too */
     FLOAT_SINGLE,
     FLOAT_DOUBLE,
     FLOAT_LONG_DOUBLE,
     N_SIZE_SPECS
@@ -616,13 +616,13 @@ simple_strtoul (const char *s, const char **p, unsigned long int *val)
    character following the just-decoded format (if *NEXT is non-NULL),
    and return true.  If S is not valid, don't modify *NEXT or *TSPEC,
    give a diagnostic, and return false.  For example, if S were
    "d4afL" *NEXT would be set to "afL" and *TSPEC would be
      {
        fmt = SIGNED_DECIMAL;
-       size = INT or LONG; (whichever integral_type_size[4] resolves to)
+       size = INT or od_LONG; (whichever integral_type_size[4] resolves to)
        print_function = print_int; (assuming size == INT)
        field_width = 11;
        fmt_string = "%*d";
       }
    pad_width is determined later, but is at least as large as the
    number of fields printed per row.
@@ -700,13 +700,13 @@ decode_one_format (const char *s_orig, const char *s, const char **next,
             }
           break;
         }
 
 #define ISPEC_TO_FORMAT(Spec, Min_format, Long_format, Max_format)	\
   ((Spec) == LONG_LONG ? (Max_format)					\
-   : ((Spec) == LONG ? (Long_format)					\
+   : ((Spec) == od_LONG ? (Long_format)					\
       : (Min_format)))							\
 
       size_spec = integral_type_size[size];
 
       switch (c)
         {
@@ -749,23 +749,23 @@ decode_one_format (const char *s_orig, const char *s, const char **next,
         case CHAR:
           print_function = (fmt == SIGNED_DECIMAL
                             ? print_s_char
                             : print_char);
           break;
 
-        case SHORT:
+        case od_SHORT:
           print_function = (fmt == SIGNED_DECIMAL
                             ? print_s_short
                             : print_short);
           break;
 
         case INT:
           print_function = print_int;
           break;
 
-        case LONG:
+        case od_LONG:
           print_function = print_long;
           break;
 
         case LONG_LONG:
           print_function = print_long_long;
           break;
@@ -1588,15 +1588,15 @@ main (int argc, char **argv)
   atexit (close_stdout);
 
   for (i = 0; i <= MAX_INTEGRAL_TYPE_SIZE; i++)
     integral_type_size[i] = NO_SIZE;
 
   integral_type_size[sizeof (char)] = CHAR;
-  integral_type_size[sizeof (short int)] = SHORT;
+  integral_type_size[sizeof (short int)] = od_SHORT;
   integral_type_size[sizeof (int)] = INT;
-  integral_type_size[sizeof (long int)] = LONG;
+  integral_type_size[sizeof (long int)] = od_LONG;
 #if HAVE_UNSIGNED_LONG_LONG_INT
   /* If 'long int' and 'long long int' have the same size, it's fine
      to overwrite the entry for 'long' with this one.  */
   integral_type_size[sizeof (unsigned_long_long_int)] = LONG_LONG;
 #endif
 
diff --git a/src/operand2sig.c b/src/operand2sig.c
index d59ccb927902a5590ae9c80f5285de680df7a13e..96cccb4547d6adb951f60ea97d8173742fb29f9c 100644
--- a/src/operand2sig.c
+++ b/src/operand2sig.c
@@ -21,13 +21,15 @@
 /* Convert OPERAND to a signal number with printable representation SIGNAME.
    Return the signal number, or -1 if unsuccessful.  */
 
 #include <config.h>
 #include <stdio.h>
 #include <sys/types.h>
-#include <sys/wait.h>
+#if !(defined __amigaos__ && defined __CLIB2__) /* AmigaOS using CLIB2 */
+# include <sys/wait.h>
+#endif
 
 #include "system.h"
 #include "error.h"
 #include "quote.h"
 #include "sig2str.h"
 #include "operand2sig.h"
@@ -50,12 +52,16 @@ operand2sig (char const *operand, char *signame)
          wider exit status values as discussed at
          http://austingroupbugs.net/view.php?id=947  */
 
       char *endp;
       long int l = (errno = 0, strtol (operand, &endp, 10));
       int i = l;
+#if defined __amigaos__ && defined __CLIB2__ /* AmigaOS using CLIB2 */
+# define WIFSIGNALED(x)	(((x) & 0177) != 0177 && ((x) & 0177) != 0)
+# define WTERMSIG(x)	((x) & 0177)
+#endif
       signum = (operand == endp || *endp || errno || i != l ? -1
                 : WIFSIGNALED (i) ? WTERMSIG (i) : i);
     }
   else
     {
       /* Convert signal to upper case in the C locale, not in the
diff --git a/src/ptx.c b/src/ptx.c
index c0c9733a2b17398c55b7c6ead1d88b00740bb9b0..19856b743122f42251e269eb8338033404172c2e 100644
--- a/src/ptx.c
+++ b/src/ptx.c
@@ -102,14 +102,14 @@ struct regex_data
 };
 
 static struct regex_data context_regex;	/* end of context */
 static struct regex_data word_regex;	/* keyword */
 
 /* A BLOCK delimit a region in memory of arbitrary size, like the copy of a
-   whole file.  A WORD is something smaller, its length should fit in a
-   short integer.  A WORD_TABLE may contain several WORDs.  */
+   whole file.  A ptx_WORD is something smaller, its length should fit in a
+   short integer.  A ptx_WORD_TABLE may contain several ptx_WORDs.  */
 
 typedef struct
   {
     char *start;		/* pointer to beginning of region */
     char *end;			/* pointer to end + 1 of region */
   }
@@ -117,21 +117,21 @@ BLOCK;
 
 typedef struct
   {
     char *start;		/* pointer to beginning of region */
     short int size;		/* length of the region */
   }
-WORD;
+ptx_WORD;
 
 typedef struct
   {
-    WORD *start;		/* array of WORDs */
+    ptx_WORD *start;		/* array of ptx_WORDs */
     size_t alloc;		/* allocated length */
     size_t length;		/* number of used entries */
   }
-WORD_TABLE;
+ptx_WORD_TABLE;
 
 /* Pattern description tables.  */
 
 /* For each character, provide its folded equivalent.  */
 static unsigned char folded_chars[CHAR_SET_SIZE];
 
@@ -153,14 +153,14 @@ static int maximum_word_length;
 
 /* Maximum width of any reference used.  */
 static int reference_max_width;
 
 /* Ignore and Only word tables.  */
 
-static WORD_TABLE ignore_table;	/* table of words to ignore */
-static WORD_TABLE only_table;		/* table of words to select */
+static ptx_WORD_TABLE ignore_table;	/* table of words to ignore */
+static ptx_WORD_TABLE only_table;		/* table of words to select */
 
 /* Source text table, and scanning macros.  */
 
 static int number_input_files;	/* number of text input files */
 static int total_line_count;	/* total number of lines seen so far */
 static const char **input_file_name;	/* array of text input file names */
@@ -225,13 +225,13 @@ static BLOCK *text_buffers;	/* files to study */
    negative.  */
 
 typedef short int DELTA;	/* to hold displacement within one context */
 
 typedef struct
   {
-    WORD key;			/* description of the keyword */
+    ptx_WORD key;			/* description of the keyword */
     DELTA left;			/* distance to left context start */
     DELTA right;		/* distance to right context end */
     int reference;		/* reference descriptor */
     size_t file_index;		/* corresponding file  */
   }
 OCCURS;
@@ -535,14 +535,14 @@ swallow_file_in_memory (const char *file_name, BLOCK *block)
 | If a word is indeed a prefix of the other, the shorter should go first.   |
 `--------------------------------------------------------------------------*/
 
 static int
 compare_words (const void *void_first, const void *void_second)
 {
-#define first ((const WORD *) void_first)
-#define second ((const WORD *) void_second)
+#define first ((const ptx_WORD *) void_first)
+#define second ((const ptx_WORD *) void_second)
   int length;			/* minimum of two lengths */
   int counter;			/* cursor in words */
   int value;			/* value of comparison */
 
   length = first->size < second->size ? first->size : second->size;
 
@@ -589,17 +589,17 @@ compare_occurs (const void *void_first, const void *void_second)
   return value == 0 ? first->key.start - second->key.start : value;
 #undef first
 #undef second
 }
 
 /*------------------------------------------------------------.
-| Return !0 if WORD appears in TABLE.  Uses a binary search.  |
+| Return !0 if ptx_WORD appears in TABLE.  Uses a binary search.  |
 `------------------------------------------------------------*/
 
 static int _GL_ATTRIBUTE_PURE
-search_table (WORD *word, WORD_TABLE *table)
+search_table (ptx_WORD *word, ptx_WORD_TABLE *table)
 {
   int lowest;			/* current lowest possible index */
   int highest;			/* current highest possible index */
   int middle;			/* current middle index */
   int value;			/* value from last comparison */
 
@@ -675,19 +675,19 @@ digest_break_file (const char *file_name)
 
   free (file_contents.start);
 }
 
 /*-----------------------------------------------------------------------.
 | Read a file named FILE_NAME, containing one word per line, then	 |
-| construct in TABLE a table of WORD descriptors for them.  The routine	 |
+| construct in TABLE a table of ptx_WORD descriptors for them.  The routine	 |
 | swallows the whole file in memory; this is at the expense of space	 |
 | needed for newlines, which are useless; however, the reading is fast.	 |
 `-----------------------------------------------------------------------*/
 
 static void
-digest_word_file (const char *file_name, WORD_TABLE *table)
+digest_word_file (const char *file_name, ptx_WORD_TABLE *table)
 {
   BLOCK file_contents;		/* to receive a copy of the file */
   char *cursor;			/* cursor in file copy */
   char *word_start;		/* start of the current word */
 
   swallow_file_in_memory (file_name, &file_contents);
@@ -748,13 +748,13 @@ find_occurs_in_text (size_t file_index)
 {
   char *cursor;			/* for scanning the source text */
   char *scan;			/* for scanning the source text also */
   char *line_start;		/* start of the current input line */
   char *line_scan;		/* newlines scanned until this point */
   int reference_length;		/* length of reference in input mode */
-  WORD possible_key;		/* possible key, to ease searches */
+  ptx_WORD possible_key;		/* possible key, to ease searches */
   OCCURS *occurs_cursor;	/* current OCCURS under construction */
 
   char *context_start;		/* start of left context */
   char *context_end;		/* end of right context */
   char *word_start;		/* start of word */
   char *word_end;		/* end of word */
diff --git a/src/sort.c b/src/sort.c
index 94315d2a1bf28e3459486fe49164a5190a92701d..a5a82bcca07e0675c7d6a46f37be61776131bc18 100644
--- a/src/sort.c
+++ b/src/sort.c
@@ -1,180 +1,123 @@
 /* sort - sort lines of text (with all kinds of options).
-   Copyright (C) 1988-2017 Free Software Foundation, Inc.
+   Copyright (C) 88, 1991-2004 Free Software Foundation, Inc.
 
-   This program is free software: you can redistribute it and/or modify
+   This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
    Written December 1988 by Mike Haertel.
    The author may be reached (Email) at the address mike@gnu.ai.mit.edu,
    or (US mail) as Mike Haertel c/o Free Software Foundation.
 
    Ørn E. Hansen added NLS support in 1997.  */
 
 #include <config.h>
 
 #include <getopt.h>
-#include <pthread.h>
-#include <sys/resource.h>
 #include <sys/types.h>
-#include <sys/wait.h>
 #include <signal.h>
-#include <assert.h>
+#include <stdio.h>
 #include "system.h"
-#include "argmatch.h"
-#include "die.h"
 #include "error.h"
-#include "fadvise.h"
-#include "filevercmp.h"
-#include "flexmember.h"
 #include "hard-locale.h"
-#include "hash.h"
-#include "heap.h"
-#include "ignore-value.h"
-#include "md5.h"
-#include "mbswidth.h"
-#include "nproc.h"
+#include "inttostr.h"
+#include "long-options.h"
 #include "physmem.h"
 #include "posixver.h"
-#include "quote.h"
-#include "randread.h"
-#include "readtokens0.h"
-#include "stdio--.h"
-#include "stdlib--.h"
-#include "strnumcmp.h"
+#include "stdio-safer.h"
 #include "xmemcoll.h"
-#include "xnanosleep.h"
 #include "xstrtol.h"
 
+#include <sys/resource.h>
+
+#if !defined __amigaos__ /* AmigaOS */
 #ifndef RLIMIT_DATA
 struct rlimit { size_t rlim_cur; };
 # define getrlimit(Resource, Rlp) (-1)
 #endif
+#else
+# define RLIMIT_DATA RLIM_DATA
+#endif
+
+#if defined __amigaos4__ && defined __NEWLIB__
+#undef SA_NOCLDSTOP
+#endif
 
-/* The official name of this program (e.g., no 'g' prefix).  */
+/* The official name of this program (e.g., no `g' prefix).  */
 #define PROGRAM_NAME "sort"
 
-#define AUTHORS \
-  proper_name ("Mike Haertel"), \
-  proper_name ("Paul Eggert")
+#define AUTHORS "Mike Haertel", "Paul Eggert"
 
 #if HAVE_LANGINFO_CODESET
 # include <langinfo.h>
 #endif
 
-/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
-   present.  */
 #ifndef SA_NOCLDSTOP
-# define SA_NOCLDSTOP 0
-/* No sigprocmask.  Always 'return' zero. */
-# define sigprocmask(How, Set, Oset) (0)
+# define sigprocmask(How, Set, Oset) /* empty */
 # define sigset_t int
-# if ! HAVE_SIGINTERRUPT
-#  define siginterrupt(sig, flag) /* empty */
-# endif
 #endif
 
-#if !defined OPEN_MAX && defined NR_OPEN
-# define OPEN_MAX NR_OPEN
-#endif
-#if !defined OPEN_MAX
-# define OPEN_MAX 20
+#ifndef STDC_HEADERS
+double strtod ();
 #endif
 
 #define UCHAR_LIM (UCHAR_MAX + 1)
-
-#if HAVE_C99_STRTOLD
-# define long_double long double
-#else
-# define long_double double
-# undef strtold
-# define strtold strtod
-#endif
+#define UCHAR(c) ((unsigned char) (c))
 
 #ifndef DEFAULT_TMPDIR
 # define DEFAULT_TMPDIR "/tmp"
 #endif
 
-/* Maximum number of lines to merge every time a NODE is taken from
-   the merge queue.  Node is at LEVEL in the binary merge tree,
-   and is responsible for merging TOTAL lines. */
-#define MAX_MERGE(total, level) (((total) >> (2 * ((level) + 1))) + 1)
-
-/* Heuristic value for the number of lines for which it is worth creating
-   a subthread, during an internal merge sort.  I.e., it is a small number
-   of "average" lines for which sorting via two threads is faster than
-   sorting via one on an "average" system.  On a dual-core 2.0 GHz i686
-   system with 3GB of RAM and 2MB of L2 cache, a file containing 128K
-   lines of gensort -a output is sorted slightly faster with --parallel=2
-   than with --parallel=1.  By contrast, using --parallel=1 is about 10%
-   faster than using --parallel=2 with a 64K-line input.  */
-enum { SUBTHREAD_LINES_HEURISTIC = 128 * 1024 };
-verify (4 <= SUBTHREAD_LINES_HEURISTIC);
-
-/* The number of threads after which there are
-   diminishing performance gains.  */
-enum { DEFAULT_MAX_THREADS = 8 };
-
 /* Exit statuses.  */
 enum
   {
     /* POSIX says to exit with status 1 if invoked with -c and the
        input is not properly sorted.  */
     SORT_OUT_OF_ORDER = 1,
 
     /* POSIX says any other irregular exit must exit with a status
        code greater than 1.  */
     SORT_FAILURE = 2
   };
 
-enum
-  {
-    /* The number of times we should try to fork a compression process
-       (we retry if the fork call fails).  We don't _need_ to compress
-       temp files, this is just to reduce disk access, so this number
-       can be small.  Each retry doubles in duration.  */
-    MAX_FORK_TRIES_COMPRESS = 4,
-
-    /* The number of times we should try to fork a decompression process.
-       If we can't fork a decompression process, we can't sort, so this
-       number should be big.  Each retry doubles in duration.  */
-    MAX_FORK_TRIES_DECOMPRESS = 9
-  };
-
-enum
-  {
-    /* Level of the end-of-merge node, one level above the root. */
-    MERGE_END = 0,
-
-    /* Level of the root node in merge tree. */
-    MERGE_ROOT = 1
-  };
+#define C_DECIMAL_POINT '.'
+#define NEGATION_SIGN   '-'
+#define NUMERIC_ZERO    '0'
 
-/* The representation of the decimal point in the current locale.  */
-static int decimal_point;
+#if HAVE_SETLOCALE
 
-/* Thousands separator; if -1, then there isn't one.  */
-static int thousands_sep;
+static char decimal_point;
+static int th_sep; /* if CHAR_MAX + 1, then there is no thousands separator */
 
 /* Nonzero if the corresponding locales are hard.  */
 static bool hard_LC_COLLATE;
-#if HAVE_NL_LANGINFO
+# if HAVE_NL_LANGINFO
 static bool hard_LC_TIME;
+# endif
+
+# define IS_THOUSANDS_SEP(x) ((x) == th_sep)
+
+#else
+
+# define decimal_point C_DECIMAL_POINT
+# define IS_THOUSANDS_SEP(x) 0
+
 #endif
 
-#define NONZERO(x) ((x) != 0)
+#define NONZERO(x) (x != 0)
 
 /* The kind of blanks for '-b' to skip in various options. */
 enum blanktype { bl_start, bl_end, bl_both };
 
 /* The character marking end of line. Default to \n. */
 static char eolchar = '\n';
@@ -189,89 +132,53 @@ struct line
 };
 
 /* Input buffers. */
 struct buffer
 {
   char *buf;			/* Dynamically allocated buffer,
-                                   partitioned into 3 regions:
-                                   - input data;
-                                   - unused area;
-                                   - an array of lines, in reverse order.  */
+				   partitioned into 3 regions:
+				   - input data;
+				   - unused area;
+				   - an array of lines, in reverse order.  */
   size_t used;			/* Number of bytes used for input data.  */
   size_t nlines;		/* Number of lines in the line array.  */
   size_t alloc;			/* Number of bytes allocated. */
   size_t left;			/* Number of bytes left from previous reads. */
   size_t line_bytes;		/* Number of bytes to reserve for each line. */
   bool eof;			/* An EOF has been read.  */
 };
 
-/* Sort key.  */
 struct keyfield
 {
   size_t sword;			/* Zero-origin 'word' to start at. */
   size_t schar;			/* Additional characters to skip. */
-  size_t eword;			/* Zero-origin last 'word' of key. */
+  size_t eword;			/* Zero-origin first word after field. */
   size_t echar;			/* Additional characters in field. */
   bool const *ignore;		/* Boolean array of characters to ignore. */
   char const *translate;	/* Translation applied to characters. */
-  bool skipsblanks;		/* Skip leading blanks when finding start.  */
-  bool skipeblanks;		/* Skip leading blanks when finding end.  */
+  bool skipsblanks;		/* Skip leading blanks at start. */
+  bool skipeblanks;		/* Skip trailing blanks at finish. */
   bool numeric;			/* Flag for numeric comparison.  Handle
-                                   strings of digits with optional decimal
-                                   point, but no exponential notation. */
-  bool random;			/* Sort by random hash of key.  */
+				   strings of digits with optional decimal
+				   point, but no exponential notation. */
   bool general_numeric;		/* Flag for general, numeric comparison.
-                                   Handle numbers in exponential notation. */
-  bool human_numeric;		/* Flag for sorting by human readable
-                                   units with either SI or IEC prefixes. */
+				   Handle numbers in exponential notation. */
   bool month;			/* Flag for comparison by month name. */
   bool reverse;			/* Reverse the sense of comparison. */
-  bool version;			/* sort by version number */
-  bool traditional_used;	/* Traditional key option format is used. */
   struct keyfield *next;	/* Next keyfield to try. */
 };
 
 struct month
 {
   char const *name;
   int val;
 };
 
-/* Binary merge tree node. */
-struct merge_node
-{
-  struct line *lo;              /* Lines to merge from LO child node. */
-  struct line *hi;              /* Lines to merge from HI child node. */
-  struct line *end_lo;          /* End of available lines from LO. */
-  struct line *end_hi;          /* End of available lines from HI. */
-  struct line **dest;           /* Pointer to destination of merge. */
-  size_t nlo;                   /* Total Lines remaining from LO. */
-  size_t nhi;                   /* Total lines remaining from HI. */
-  struct merge_node *parent;    /* Parent node. */
-  struct merge_node *lo_child;  /* LO child node. */
-  struct merge_node *hi_child;  /* HI child node. */
-  unsigned int level;           /* Level in merge tree. */
-  bool queued;                  /* Node is already in heap. */
-  pthread_mutex_t lock;         /* Lock for node operations. */
-};
-
-/* Priority queue of merge nodes. */
-struct merge_node_queue
-{
-  struct heap *priority_queue;  /* Priority queue of merge tree nodes. */
-  pthread_mutex_t mutex;        /* Lock for queue operations. */
-  pthread_cond_t cond;          /* Conditional wait for empty queue to populate
-                                   when popping. */
-};
-
-/* Used to implement --unique (-u).  */
-static struct line saved_line;
-
 /* FIXME: None of these tables work with multibyte character sets.
    Also, there are many other bugs when handling multibyte characters.
-   One way to fix this is to rewrite 'sort' to use wide characters
+   One way to fix this is to rewrite `sort' to use wide characters
    internally, but doing this with good performance is a bit
    tricky.  */
 
 /* Table of blanks.  */
 static bool blanks[UCHAR_LIM];
 
@@ -302,35 +209,31 @@ static struct month monthtab[] =
   {"NOV", 11},
   {"OCT", 10},
   {"SEP", 9}
 };
 
 /* During the merge phase, the number of files to merge at once. */
-#define NMERGE_DEFAULT 16
+#define NMERGE 16
 
 /* Minimum size for a merge or check buffer.  */
 #define MIN_MERGE_BUFFER_SIZE (2 + sizeof (struct line))
 
 /* Minimum sort size; the code might not work with smaller sizes.  */
-#define MIN_SORT_SIZE (nmerge * MIN_MERGE_BUFFER_SIZE)
+#define MIN_SORT_SIZE (NMERGE * MIN_MERGE_BUFFER_SIZE)
 
 /* The number of bytes needed for a merge or check buffer, which can
    function relatively efficiently even if it holds only one line.  If
    a longer line is seen, this value is increased.  */
 static size_t merge_buffer_size = MAX (MIN_MERGE_BUFFER_SIZE, 256 * 1024);
 
 /* The approximate maximum number of bytes of main memory to use, as
    specified by the user.  Zero if the user has not specified a size.  */
 static size_t sort_size;
 
-/* The initial allocation factor for non-regular files.
-   This is used, e.g., when reading from a pipe.
-   Don't make it too big, since it is multiplied by ~130 to
-   obtain the size of the actual buffer sort will allocate.
-   Also, there may be 8 threads all doing this at the same time.  */
-#define INPUT_FILE_SIZE_GUESS (128 * 1024)
+/* The guessed size for non-regular files.  */
+#define INPUT_FILE_SIZE_GUESS (1024 * 1024)
 
 /* Array of directory names in which any temporary files are to be created. */
 static char const **temp_dirs;
 
 /* Number of temporary directory names used.  */
 static size_t temp_dir_count;
@@ -361,907 +264,289 @@ static bool unique;
 /* Nonzero if any of the input files are the standard input. */
 static bool have_read_stdin;
 
 /* List of key field comparisons to be tried.  */
 static struct keyfield *keylist;
 
-/* Program used to (de)compress temp files.  Must accept -d.  */
-static char const *compress_program;
-
-/* Annotate the output with extra info to aid the user.  */
-static bool debug;
-
-/* Maximum number of files to merge in one go.  If more than this
-   number are present, temp files will be used. */
-static unsigned int nmerge = NMERGE_DEFAULT;
-
-/* Output an error to stderr using async-signal-safe routines, and _exit().
-   This can be used safely from signal handlers,
-   and between fork() and exec() of multithreaded processes.  */
-
-static void async_safe_die (int, const char *) ATTRIBUTE_NORETURN;
-static void
-async_safe_die (int errnum, const char *errstr)
-{
-  ignore_value (write (STDERR_FILENO, errstr, strlen (errstr)));
-
-  /* Even if defined HAVE_STRERROR_R, we can't use it,
-     as it may return a translated string etc. and even if not
-     may malloc() which is unsafe.  We might improve this
-     by testing for sys_errlist and using that if available.
-     For now just report the error number.  */
-  if (errnum)
-    {
-      char errbuf[INT_BUFSIZE_BOUND (errnum)];
-      char *p = inttostr (errnum, errbuf);
-      ignore_value (write (STDERR_FILENO, ": errno ", 8));
-      ignore_value (write (STDERR_FILENO, p, strlen (p)));
-    }
-
-  ignore_value (write (STDERR_FILENO, "\n", 1));
+static void sortlines_temp (struct line *, size_t, struct line *);
 
-  _exit (SORT_FAILURE);
-}
 
-/* Report MESSAGE for FILE, then clean up and exit.
-   If FILE is null, it represents standard output.  */
+#ifdef __amigaos__ /* AmigaOS */
+int stdout_is_closed = 0;
 
-static void sort_die (char const *, char const *) ATTRIBUTE_NORETURN;
-static void
-sort_die (char const *message, char const *file)
+void my_close_stdout(void)
 {
-  die (SORT_FAILURE, errno, "%s: %s", message,
-       quotef (file ? file : _("standard output")));
+  if (stdout_is_closed == 0)
+	close_stdout();
 }
+#endif
 
 void
 usage (int status)
 {
   if (status != EXIT_SUCCESS)
-    emit_try_help ();
+    fprintf (stderr, _("Try `%s --help' for more information.\n"),
+	     program_name);
   else
     {
       printf (_("\
 Usage: %s [OPTION]... [FILE]...\n\
-  or:  %s [OPTION]... --files0-from=F\n\
 "),
-              program_name, program_name);
+	      program_name);
       fputs (_("\
 Write sorted concatenation of all FILE(s) to standard output.\n\
-"), stdout);
-
-      emit_stdin_note ();
-      emit_mandatory_arg_note ();
-
-      fputs (_("\
+\n\
 Ordering options:\n\
 \n\
 "), stdout);
       fputs (_("\
-  -b, --ignore-leading-blanks  ignore leading blanks\n\
-  -d, --dictionary-order      consider only blanks and alphanumeric characters\
-\n\
+Mandatory arguments to long options are mandatory for short options too.\n\
+"), stdout);
+      fputs (_("\
+  -b, --ignore-leading-blanks ignore leading blanks\n\
+  -d, --dictionary-order      consider only blanks and alphanumeric characters\n\
   -f, --ignore-case           fold lower case to upper case characters\n\
 "), stdout);
       fputs (_("\
   -g, --general-numeric-sort  compare according to general numerical value\n\
   -i, --ignore-nonprinting    consider only printable characters\n\
-  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n\
-"), stdout);
-      fputs (_("\
-  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n\
-"), stdout);
-      fputs (_("\
+  -M, --month-sort            compare (unknown) < `JAN' < ... < `DEC'\n\
   -n, --numeric-sort          compare according to string numerical value\n\
-  -R, --random-sort           shuffle, but group identical keys.  See shuf(1)\n\
-      --random-source=FILE    get random bytes from FILE\n\
   -r, --reverse               reverse the result of comparisons\n\
-"), stdout);
-      fputs (_("\
-      --sort=WORD             sort according to WORD:\n\
-                                general-numeric -g, human-numeric -h, month -M,\
-\n\
-                                numeric -n, random -R, version -V\n\
-  -V, --version-sort          natural sort of (version) numbers within text\n\
 \n\
 "), stdout);
       fputs (_("\
 Other options:\n\
 \n\
-"), stdout);
-      fputs (_("\
-      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n\
-                            for more use temp files\n\
-"), stdout);
-      fputs (_("\
-  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n\
-  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\
-\n\
-      --compress-program=PROG  compress temporaries with PROG;\n\
-                              decompress them with PROG -d\n\
-"), stdout);
-      fputs (_("\
-      --debug               annotate the part of the line used to sort,\n\
-                              and warn about questionable usage to stderr\n\
-      --files0-from=F       read input from the files specified by\n\
-                            NUL-terminated names in file F;\n\
-                            If F is - then read names from standard input\n\
-"), stdout);
-      fputs (_("\
-  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n\
+  -c, --check               check whether input is sorted; do not sort\n\
+  -k, --key=POS1[,POS2]     start a key at POS1, end it at POS 2 (origin 1)\n\
   -m, --merge               merge already sorted files; do not sort\n\
-"), stdout);
-      fputs (_("\
   -o, --output=FILE         write result to FILE instead of standard output\n\
-  -s, --stable              stabilize sort by disabling last-resort comparison\
-\n\
+  -s, --stable              stabilize sort by disabling last-resort comparison\n\
   -S, --buffer-size=SIZE    use SIZE for main memory buffer\n\
 "), stdout);
       printf (_("\
-  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n\
+  -t, --field-separator=SEP use SEP instead of non-blank to blank transition\n\
   -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n\
                               multiple options specify multiple directories\n\
-      --parallel=N          change the number of sorts run concurrently to N\n\
   -u, --unique              with -c, check for strict ordering;\n\
-                              without -c, output only the first of an equal run\
-\n\
+                              without -c, output only the first of an equal run\n\
 "), DEFAULT_TMPDIR);
       fputs (_("\
-  -z, --zero-terminated     line delimiter is NUL, not newline\n\
+  -z, --zero-terminated     end lines with 0 byte, not newline\n\
 "), stdout);
       fputs (HELP_OPTION_DESCRIPTION, stdout);
       fputs (VERSION_OPTION_DESCRIPTION, stdout);
       fputs (_("\
 \n\
-KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\n\
-field number and C a character position in the field; both are origin 1, and\n\
-the stop position defaults to the line's end.  If neither -t nor -b is in\n\
-effect, characters in a field are counted from the beginning of the preceding\n\
-whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\
-\n\
-which override global ordering options for that key.  If no key is given, use\n\
-the entire line as the key.  Use --debug to diagnose incorrect key usage.\n\
+POS is F[.C][OPTS], where F is the field number and C the character position\n\
+in the field.  OPTS is one or more single-letter ordering options, which\n\
+override global ordering options for that key.  If no key is given, use the\n\
+entire line as the key.\n\
 \n\
 SIZE may be followed by the following multiplicative suffixes:\n\
 "), stdout);
       fputs (_("\
 % 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n\
 \n\
+With no FILE, or when FILE is -, read standard input.\n\
+\n\
 *** WARNING ***\n\
 The locale specified by the environment affects sort order.\n\
 Set LC_ALL=C to get the traditional sort order that uses\n\
 native byte values.\n\
 "), stdout );
-      emit_ancillary_info (PROGRAM_NAME);
+      printf (_("\nReport bugs to <%s>.\n"), PACKAGE_BUGREPORT);
     }
 
   exit (status);
 }
 
-/* For long options that have no equivalent short option, use a
-   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
-enum
-{
-  CHECK_OPTION = CHAR_MAX + 1,
-  COMPRESS_PROGRAM_OPTION,
-  DEBUG_PROGRAM_OPTION,
-  FILES0_FROM_OPTION,
-  NMERGE_OPTION,
-  RANDOM_SOURCE_OPTION,
-  SORT_OPTION,
-  PARALLEL_OPTION
-};
-
-static char const short_options[] = "-bcCdfghik:mMno:rRsS:t:T:uVy:z";
+#define COMMON_SHORT_OPTIONS "-bcdfgik:mMno:rsS:t:T:uz"
 
 static struct option const long_options[] =
 {
   {"ignore-leading-blanks", no_argument, NULL, 'b'},
-  {"check", optional_argument, NULL, CHECK_OPTION},
-  {"compress-program", required_argument, NULL, COMPRESS_PROGRAM_OPTION},
-  {"debug", no_argument, NULL, DEBUG_PROGRAM_OPTION},
+  {"check", no_argument, NULL, 'c'},
   {"dictionary-order", no_argument, NULL, 'd'},
   {"ignore-case", no_argument, NULL, 'f'},
-  {"files0-from", required_argument, NULL, FILES0_FROM_OPTION},
   {"general-numeric-sort", no_argument, NULL, 'g'},
   {"ignore-nonprinting", no_argument, NULL, 'i'},
   {"key", required_argument, NULL, 'k'},
   {"merge", no_argument, NULL, 'm'},
   {"month-sort", no_argument, NULL, 'M'},
   {"numeric-sort", no_argument, NULL, 'n'},
-  {"human-numeric-sort", no_argument, NULL, 'h'},
-  {"version-sort", no_argument, NULL, 'V'},
-  {"random-sort", no_argument, NULL, 'R'},
-  {"random-source", required_argument, NULL, RANDOM_SOURCE_OPTION},
-  {"sort", required_argument, NULL, SORT_OPTION},
   {"output", required_argument, NULL, 'o'},
   {"reverse", no_argument, NULL, 'r'},
   {"stable", no_argument, NULL, 's'},
-  {"batch-size", required_argument, NULL, NMERGE_OPTION},
   {"buffer-size", required_argument, NULL, 'S'},
   {"field-separator", required_argument, NULL, 't'},
   {"temporary-directory", required_argument, NULL, 'T'},
   {"unique", no_argument, NULL, 'u'},
   {"zero-terminated", no_argument, NULL, 'z'},
-  {"parallel", required_argument, NULL, PARALLEL_OPTION},
   {GETOPT_HELP_OPTION_DECL},
   {GETOPT_VERSION_OPTION_DECL},
-  {NULL, 0, NULL, 0},
-};
-
-#define CHECK_TABLE \
-  _ct_("quiet",          'C') \
-  _ct_("silent",         'C') \
-  _ct_("diagnose-first", 'c')
-
-static char const *const check_args[] =
-{
-#define _ct_(_s, _c) _s,
-  CHECK_TABLE NULL
-#undef  _ct_
-};
-static char const check_types[] =
-{
-#define _ct_(_s, _c) _c,
-  CHECK_TABLE
-#undef  _ct_
-};
-
-#define SORT_TABLE \
-  _st_("general-numeric", 'g') \
-  _st_("human-numeric",   'h') \
-  _st_("month",           'M') \
-  _st_("numeric",         'n') \
-  _st_("random",          'R') \
-  _st_("version",         'V')
-
-static char const *const sort_args[] =
-{
-#define _st_(_s, _c) _s,
-  SORT_TABLE NULL
-#undef  _st_
-};
-static char const sort_types[] =
-{
-#define _st_(_s, _c) _c,
-  SORT_TABLE
-#undef  _st_
+  {0, 0, 0, 0},
 };
 
 /* The set of signals that are caught.  */
 static sigset_t caught_signals;
 
-/* Critical section status.  */
-struct cs_status
-{
-  bool valid;
-  sigset_t sigs;
-};
-
-/* Enter a critical section.  */
-static struct cs_status
-cs_enter (void)
-{
-  struct cs_status status;
-  status.valid = (sigprocmask (SIG_BLOCK, &caught_signals, &status.sigs) == 0);
-  return status;
-}
-
-/* Leave a critical section.  */
-static void
-cs_leave (struct cs_status status)
-{
-  if (status.valid)
-    {
-      /* Ignore failure when restoring the signal mask. */
-      sigprocmask (SIG_SETMASK, &status.sigs, NULL);
-    }
-}
-
-/* Possible states for a temp file.  If compressed, the file's status
-   is unreaped or reaped, depending on whether 'sort' has waited for
-   the subprocess to finish.  */
-enum { UNCOMPRESSED, UNREAPED, REAPED };
-
 /* The list of temporary files. */
 struct tempnode
 {
   struct tempnode *volatile next;
-  pid_t pid;     /* The subprocess PID; undefined if state == UNCOMPRESSED.  */
-  char state;
-  char name[FLEXIBLE_ARRAY_MEMBER];
+  char name[1];  /* Actual size is 1 + file name length.  */
 };
 static struct tempnode *volatile temphead;
-static struct tempnode *volatile *temptail = &temphead;
-
-/* A file to be sorted.  */
-struct sortfile
-{
-  /* The file's name.  */
-  char const *name;
-
-  /* Non-null if this is a temporary file, in which case NAME == TEMP->name.  */
-  struct tempnode *temp;
-};
-
-/* Map PIDs of unreaped subprocesses to their struct tempnode objects.  */
-static Hash_table *proctab;
-
-enum { INIT_PROCTAB_SIZE = 47 };
-
-static size_t
-proctab_hasher (void const *entry, size_t tabsize)
-{
-  struct tempnode const *node = entry;
-  return node->pid % tabsize;
-}
-
-static bool
-proctab_comparator (void const *e1, void const *e2)
-{
-  struct tempnode const *n1 = e1;
-  struct tempnode const *n2 = e2;
-  return n1->pid == n2->pid;
-}
-
-/* The number of unreaped child processes.  */
-static pid_t nprocs;
-
-static bool delete_proc (pid_t);
-
-/* If PID is positive, wait for the child process with that PID to
-   exit, and assume that PID has already been removed from the process
-   table.  If PID is 0 or -1, clean up some child that has exited (by
-   waiting for it, and removing it from the proc table) and return the
-   child's process ID.  However, if PID is 0 and no children have
-   exited, return 0 without waiting.  */
-
-static pid_t
-reap (pid_t pid)
-{
-  int status;
-  pid_t cpid = waitpid ((pid ? pid : -1), &status, (pid ? 0 : WNOHANG));
-
-  if (cpid < 0)
-    die (SORT_FAILURE, errno, _("waiting for %s [-d]"),
-         quoteaf (compress_program));
-  else if (0 < cpid && (0 < pid || delete_proc (cpid)))
-    {
-      if (! WIFEXITED (status) || WEXITSTATUS (status))
-        die (SORT_FAILURE, 0, _("%s [-d] terminated abnormally"),
-             quoteaf (compress_program));
-      --nprocs;
-    }
-
-  return cpid;
-}
-
-/* TEMP represents a new process; add it to the process table.  Create
-   the process table the first time it's called.  */
-
-static void
-register_proc (struct tempnode *temp)
-{
-  if (! proctab)
-    {
-      proctab = hash_initialize (INIT_PROCTAB_SIZE, NULL,
-                                 proctab_hasher,
-                                 proctab_comparator,
-                                 NULL);
-      if (! proctab)
-        xalloc_die ();
-    }
-
-  temp->state = UNREAPED;
-
-  if (! hash_insert (proctab, temp))
-    xalloc_die ();
-}
-
-/* If PID is in the process table, remove it and return true.
-   Otherwise, return false.  */
-
-static bool
-delete_proc (pid_t pid)
-{
-  struct tempnode test;
-
-  test.pid = pid;
-  struct tempnode *node = hash_delete (proctab, &test);
-  if (! node)
-    return false;
-  node->state = REAPED;
-  return true;
-}
-
-/* Remove PID from the process table, and wait for it to exit if it
-   hasn't already.  */
-
-static void
-wait_proc (pid_t pid)
-{
-  if (delete_proc (pid))
-    reap (pid);
-}
-
-/* Reap any exited children.  Do not block; reap only those that have
-   already exited.  */
-
-static void
-reap_exited (void)
-{
-  while (0 < nprocs && reap (0))
-    continue;
-}
-
-/* Reap at least one exited child, waiting if necessary.  */
-
-static void
-reap_some (void)
-{
-  reap (-1);
-  reap_exited ();
-}
-
-/* Reap all children, waiting if necessary.  */
-
-static void
-reap_all (void)
-{
-  while (0 < nprocs)
-    reap (-1);
-}
 
-/* Clean up any remaining temporary files.  */
+/* Clean up any remaining temporary files. */
 
 static void
 cleanup (void)
 {
   struct tempnode const *node;
 
   for (node = temphead; node; node = node->next)
     unlink (node->name);
-  temphead = NULL;
 }
 
-/* Cleanup actions to take when exiting.  */
+/* Report MESSAGE for FILE, then clean up and exit.  */
 
+static void die (char const *, char const *) ATTRIBUTE_NORETURN;
 static void
-exit_cleanup (void)
+die (char const *message, char const *file)
 {
-  if (temphead)
-    {
-      /* Clean up any remaining temporary files in a critical section so
-         that a signal handler does not try to clean them too.  */
-      struct cs_status cs = cs_enter ();
-      cleanup ();
-      cs_leave (cs);
-    }
-
-  close_stdout ();
+  error (0, errno, "%s: %s", message, file);
+  exit (SORT_FAILURE);
 }
 
-/* Create a new temporary file, returning its newly allocated tempnode.
-   Store into *PFD the file descriptor open for writing.
-   If the creation fails, return NULL and store -1 into *PFD if the
-   failure is due to file descriptor exhaustion and
-   SURVIVE_FD_EXHAUSTION; otherwise, die.  */
+/* Create a new temporary file, returning its newly allocated name.
+   Store into *PFP a stream open for writing.  */
 
-static struct tempnode *
-create_temp_file (int *pfd, bool survive_fd_exhaustion)
+static char *
+create_temp_file (FILE **pfp)
 {
   static char const slashbase[] = "/sortXXXXXX";
   static size_t temp_dir_index;
+  sigset_t oldset;
   int fd;
   int saved_errno;
   char const *temp_dir = temp_dirs[temp_dir_index];
   size_t len = strlen (temp_dir);
   struct tempnode *node =
-    xmalloc (FLEXSIZEOF (struct tempnode, name, len + sizeof slashbase));
+    xmalloc (sizeof node->next + len + sizeof slashbase);
   char *file = node->name;
-  struct cs_status cs;
 
   memcpy (file, temp_dir, len);
   memcpy (file + len, slashbase, sizeof slashbase);
-  node->next = NULL;
+  node->next = temphead;
   if (++temp_dir_index == temp_dir_count)
     temp_dir_index = 0;
 
   /* Create the temporary file in a critical section, to avoid races.  */
-  cs = cs_enter ();
+  sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
   fd = mkstemp (file);
   if (0 <= fd)
-    {
-      *temptail = node;
-      temptail = &node->next;
-    }
+    temphead = node;
   saved_errno = errno;
-  cs_leave (cs);
+  sigprocmask (SIG_SETMASK, &oldset, NULL);
   errno = saved_errno;
 
-  if (fd < 0)
-    {
-      if (! (survive_fd_exhaustion && errno == EMFILE))
-        die (SORT_FAILURE, errno, _("cannot create temporary file in %s"),
-             quoteaf (temp_dir));
-      free (node);
-      node = NULL;
-    }
+  if (fd < 0 || (*pfp = fdopen (fd, "w")) == NULL)
+    die (_("cannot create temporary file"), file);
 
-  *pfd = fd;
-  return node;
+  return file;
 }
 
-/* Return a stream for FILE, opened with mode HOW.  A null FILE means
-   standard output; HOW should be "w".  When opening for input, "-"
-   means standard input.  To avoid confusion, do not return file
-   descriptors STDIN_FILENO, STDOUT_FILENO, or STDERR_FILENO when
-   opening an ordinary FILE.  Return NULL if unsuccessful.
-
-   fadvise() is used to specify an access pattern for input files.
-   There are a few hints we could possibly provide,
-   and after careful testing it was decided that
-   specifying POSIX_FADV_SEQUENTIAL was not detrimental
-   to any cases.  On Linux 2.6.31, this option doubles
-   the size of read ahead performed and thus was seen to
-   benefit these cases:
-     Merging
-     Sorting with a smaller internal buffer
-     Reading from faster flash devices
-
-   In _addition_ one could also specify other hints...
-
-   POSIX_FADV_WILLNEED was tested, but Linux 2.6.31
-   at least uses that to _synchronously_ prepopulate the cache
-   with the specified range.  While sort does need to
-   read all of its input before outputting, a synchronous
-   read of the whole file up front precludes any processing
-   that sort could do in parallel with the system doing
-   read ahead of the data. This was seen to have negative effects
-   in a couple of cases:
-     Merging
-     Sorting with a smaller internal buffer
-   Note this option was seen to shorten the runtime for sort
-   on a multicore system with lots of RAM and other processes
-   competing for CPU.  It could be argued that more explicit
-   scheduling hints with 'nice' et. al. are more appropriate
-   for this situation.
-
-   POSIX_FADV_NOREUSE is a possibility as it could lower
-   the priority of input data in the cache as sort will
-   only need to process it once.  However its functionality
-   has changed over Linux kernel versions and as of 2.6.31
-   it does nothing and thus we can't depend on what it might
-   do in future.
-
-   POSIX_FADV_DONTNEED is not appropriate for user specified
-   input files, but for temp files we do want to drop the
-   cache immediately after processing.  This is done implicitly
-   however when the files are unlinked.  */
-
 static FILE *
-stream_open (char const *file, char const *how)
+xfopen (const char *file, const char *how)
 {
   FILE *fp;
 
-  if (*how == 'r')
+  if (STREQ (file, "-"))
     {
-      if (STREQ (file, "-"))
-        {
-          have_read_stdin = true;
-          fp = stdin;
-        }
+      if (*how == 'r')
+	{
+	  have_read_stdin = true;
+	  fp = stdin;
+	}
       else
-        fp = fopen (file, how);
-      fadvise (fp, FADVISE_SEQUENTIAL);
+	fp = stdout;
     }
-  else if (*how == 'w')
+  else
     {
-      if (file && ftruncate (STDOUT_FILENO, 0) != 0)
-        die (SORT_FAILURE, errno, _("%s: error truncating"),
-             quotef (file));
-      fp = stdout;
+      if ((fp = fopen_safer (file, how)) == NULL)
+	die (_("open failed"), file);
     }
-  else
-    assert (!"unexpected mode passed to stream_open");
-
-  return fp;
-}
 
-/* Same as stream_open, except always return a non-null value; die on
-   failure.  */
-
-static FILE *
-xfopen (char const *file, char const *how)
-{
-  FILE *fp = stream_open (file, how);
-  if (!fp)
-    sort_die (_("open failed"), file);
   return fp;
 }
 
 /* Close FP, whose name is FILE, and report any errors.  */
 
 static void
 xfclose (FILE *fp, char const *file)
 {
-  switch (fileno (fp))
+#ifdef __amigaos__ /* AmigaOS */
+  if (fp == stdout)
+	stdout_is_closed = 1;
+#endif
+  if (fp == stdin)
     {
-    case STDIN_FILENO:
-      /* Allow reading stdin from tty more than once.  */
+      /* Allow reading stdin from tty more than once. */
       if (feof (fp))
-        clearerr (fp);
-      break;
-
-    case STDOUT_FILENO:
-      /* Don't close stdout just yet.  close_stdout does that.  */
-      if (fflush (fp) != 0)
-        sort_die (_("fflush failed"), file);
-      break;
-
-    default:
-      if (fclose (fp) != 0)
-        sort_die (_("close failed"), file);
-      break;
-    }
-}
-
-static void
-move_fd_or_die (int oldfd, int newfd)
-{
-  if (oldfd != newfd)
-    {
-      /* This should never fail for our usage.  */
-      dup2 (oldfd, newfd);
-      close (oldfd);
-    }
-}
-
-/* Fork a child process for piping to and do common cleanup.  The
-   TRIES parameter tells us how many times to try to fork before
-   giving up.  Return the PID of the child, or -1 (setting errno)
-   on failure. */
-
-static pid_t
-pipe_fork (int pipefds[2], size_t tries)
-{
-#if HAVE_WORKING_FORK
-  struct tempnode *saved_temphead;
-  int saved_errno;
-  double wait_retry = 0.25;
-  pid_t pid IF_LINT ( = -1);
-  struct cs_status cs;
-
-  if (pipe (pipefds) < 0)
-    return -1;
-
-  /* At least NMERGE + 1 subprocesses are needed.  More could be created, but
-     uncontrolled subprocess generation can hurt performance significantly.
-     Allow at most NMERGE + 2 subprocesses, on the theory that there
-     may be some useful parallelism by letting compression for the
-     previous merge finish (1 subprocess) in parallel with the current
-     merge (NMERGE + 1 subprocesses).  */
-
-  if (nmerge + 1 < nprocs)
-    reap_some ();
-
-  while (tries--)
-    {
-      /* This is so the child process won't delete our temp files
-         if it receives a signal before exec-ing.  */
-      cs = cs_enter ();
-      saved_temphead = temphead;
-      temphead = NULL;
-
-      pid = fork ();
-      saved_errno = errno;
-      if (pid)
-        temphead = saved_temphead;
-
-      cs_leave (cs);
-      errno = saved_errno;
-
-      if (0 <= pid || errno != EAGAIN)
-        break;
-      else
-        {
-          xnanosleep (wait_retry);
-          wait_retry *= 2;
-          reap_exited ();
-        }
-    }
-
-  if (pid < 0)
-    {
-      saved_errno = errno;
-      close (pipefds[0]);
-      close (pipefds[1]);
-      errno = saved_errno;
-    }
-  else if (pid == 0)
-    {
-      close (STDIN_FILENO);
-      close (STDOUT_FILENO);
+	clearerr (fp);
     }
   else
-    ++nprocs;
-
-  return pid;
-
-#else  /* ! HAVE_WORKING_FORK */
-  return -1;
-#endif
-}
-
-/* Create a temporary file and, if asked for, start a compressor
-   to that file.  Set *PFP to the file handle and return
-   the address of the new temp node.  If the creation
-   fails, return NULL if the failure is due to file descriptor
-   exhaustion and SURVIVE_FD_EXHAUSTION; otherwise, die.  */
-
-static struct tempnode *
-maybe_create_temp (FILE **pfp, bool survive_fd_exhaustion)
-{
-  int tempfd;
-  struct tempnode *node = create_temp_file (&tempfd, survive_fd_exhaustion);
-  if (! node)
-    return NULL;
-
-  node->state = UNCOMPRESSED;
-
-  if (compress_program)
     {
-      int pipefds[2];
-
-      node->pid = pipe_fork (pipefds, MAX_FORK_TRIES_COMPRESS);
-      if (0 < node->pid)
-        {
-          close (tempfd);
-          close (pipefds[0]);
-          tempfd = pipefds[1];
-
-          register_proc (node);
-        }
-      else if (node->pid == 0)
-        {
-          /* Being the child of a multithreaded program before exec(),
-             we're restricted to calling async-signal-safe routines here.  */
-          close (pipefds[1]);
-          move_fd_or_die (tempfd, STDOUT_FILENO);
-          move_fd_or_die (pipefds[0], STDIN_FILENO);
-
-          execlp (compress_program, compress_program, (char *) NULL);
-
-          async_safe_die (errno, "couldn't execute compress program");
-        }
+      if (fclose (fp) != 0)
+	die (_("close failed"), file);
     }
-
-  *pfp = fdopen (tempfd, "w");
-  if (! *pfp)
-    sort_die (_("couldn't create temporary file"), node->name);
-
-  return node;
 }
 
-/* Create a temporary file and, if asked for, start a compressor
-   to that file.  Set *PFP to the file handle and return the address
-   of the new temp node.  Die on failure.  */
-
-static struct tempnode *
-create_temp (FILE **pfp)
-{
-  return maybe_create_temp (pfp, false);
-}
-
-/* Open a compressed temp file and start a decompression process through
-   which to filter the input.  Return NULL (setting errno to
-   EMFILE) if we ran out of file descriptors, and die on any other
-   kind of failure.  */
-
-static FILE *
-open_temp (struct tempnode *temp)
+static void
+write_bytes (const char *buf, size_t n_bytes, FILE *fp, const char *output_file)
 {
-  int tempfd, pipefds[2];
-  FILE *fp = NULL;
-
-  if (temp->state == UNREAPED)
-    wait_proc (temp->pid);
-
-  tempfd = open (temp->name, O_RDONLY);
-  if (tempfd < 0)
-    return NULL;
-
-  pid_t child = pipe_fork (pipefds, MAX_FORK_TRIES_DECOMPRESS);
-
-  switch (child)
-    {
-    case -1:
-      if (errno != EMFILE)
-        die (SORT_FAILURE, errno, _("couldn't create process for %s -d"),
-             quoteaf (compress_program));
-      close (tempfd);
-      errno = EMFILE;
-      break;
-
-    case 0:
-      /* Being the child of a multithreaded program before exec(),
-         we're restricted to calling async-signal-safe routines here.  */
-      close (pipefds[0]);
-      move_fd_or_die (tempfd, STDIN_FILENO);
-      move_fd_or_die (pipefds[1], STDOUT_FILENO);
-
-      execlp (compress_program, compress_program, "-d", (char *) NULL);
-
-      async_safe_die (errno, "couldn't execute compress program (with -d)");
-
-    default:
-      temp->pid = child;
-      register_proc (temp);
-      close (tempfd);
-      close (pipefds[1]);
-
-      fp = fdopen (pipefds[0], "r");
-      if (! fp)
-        {
-          int saved_errno = errno;
-          close (pipefds[0]);
-          errno = saved_errno;
-        }
-      break;
-    }
-
-  return fp;
+  if (fwrite (buf, 1, n_bytes, fp) != n_bytes)
+    die (_("write failed"), output_file);
 }
 
 /* Append DIR to the array of temporary directory names.  */
 static void
 add_temp_dir (char const *dir)
 {
   if (temp_dir_count == temp_dir_alloc)
-    temp_dirs = X2NREALLOC (temp_dirs, &temp_dir_alloc);
+    temp_dirs = x2nrealloc (temp_dirs, &temp_dir_alloc, sizeof *temp_dirs);
 
   temp_dirs[temp_dir_count++] = dir;
 }
 
-/* Remove NAME from the list of temporary files.  */
+/* Search through the list of temporary files for NAME;
+   remove it if it is found on the list. */
 
 static void
-zaptemp (char const *name)
+zaptemp (const char *name)
 {
   struct tempnode *volatile *pnode;
   struct tempnode *node;
-  struct tempnode *next;
-  int unlink_status;
-  int unlink_errno = 0;
-  struct cs_status cs;
-
-  for (pnode = &temphead; (node = *pnode)->name != name; pnode = &node->next)
-    continue;
 
-  if (node->state == UNREAPED)
-    wait_proc (node->pid);
-
-  /* Unlink the temporary file in a critical section to avoid races.  */
-  next = node->next;
-  cs = cs_enter ();
-  unlink_status = unlink (name);
-  unlink_errno = errno;
-  *pnode = next;
-  cs_leave (cs);
-
-  if (unlink_status != 0)
-    error (0, unlink_errno, _("warning: cannot remove: %s"), quotef (name));
-  if (! next)
-    temptail = pnode;
-  free (node);
+  for (pnode = &temphead; (node = *pnode); pnode = &node->next)
+    if (node->name == name)
+      {
+	unlink (name);
+	*pnode = node->next;
+	free (node);
+	break;
+      }
 }
 
 #if HAVE_NL_LANGINFO
 
 static int
-struct_month_cmp (void const *m1, void const *m2)
+struct_month_cmp (const void *m1, const void *m2)
 {
   struct month const *month1 = m1;
   struct month const *month2 = m2;
   return strcmp (month1->name, month2->name);
 }
 
@@ -1269,192 +554,131 @@ struct_month_cmp (void const *m1, void const *m2)
 
 /* Initialize the character class tables. */
 
 static void
 inittables (void)
 {
-  size_t i;
+  int i;
 
   for (i = 0; i < UCHAR_LIM; ++i)
     {
-      blanks[i] = field_sep (i);
-      nonprinting[i] = ! isprint (i);
-      nondictionary[i] = ! isalnum (i) && ! field_sep (i);
-      fold_toupper[i] = toupper (i);
+      blanks[i] = !!isblank(i);
+      nonprinting[i] = !isprint(i);
+      nondictionary[i] = !isalnum(i) && !isblank(i);
+      fold_toupper[i] = (islower(i) ? toupper (i) : i);
     }
 
 #if HAVE_NL_LANGINFO
   /* If we're not in the "C" locale, read different names for months.  */
   if (hard_LC_TIME)
     {
       for (i = 0; i < MONTHS_PER_YEAR; i++)
-        {
-          char const *s;
-          size_t s_len;
-          size_t j, k;
-          char *name;
-
-          s = nl_langinfo (ABMON_1 + i);
-          s_len = strlen (s);
-          monthtab[i].name = name = xmalloc (s_len + 1);
-          monthtab[i].val = i + 1;
-
-          for (j = k = 0; j < s_len; j++)
-            if (! isblank (to_uchar (s[j])))
-              name[k++] = fold_toupper[to_uchar (s[j])];
-          name[k] = '\0';
-        }
-      qsort (monthtab, MONTHS_PER_YEAR, sizeof *monthtab, struct_month_cmp);
+	{
+	  char const *s;
+	  size_t s_len;
+	  size_t j;
+	  char *name;
+
+	  s = (char *) nl_langinfo (ABMON_1 + i);
+	  s_len = strlen (s);
+	  monthtab[i].name = name = xmalloc (s_len + 1);
+	  monthtab[i].val = i + 1;
+
+	  for (j = 0; j < s_len; j++)
+	    name[j] = fold_toupper[UCHAR (s[j])];
+	  name[j] = '\0';
+	}
+      qsort ((void *) monthtab, MONTHS_PER_YEAR,
+	     sizeof *monthtab, struct_month_cmp);
     }
 #endif
 }
 
-/* Specify how many inputs may be merged at once.
-   This may be set on the command-line with the
-   --batch-size option. */
+/* Specify the amount of main memory to use when sorting.  */
 static void
-specify_nmerge (int oi, char c, char const *s)
+specify_sort_size (char const *s)
 {
   uintmax_t n;
-  struct rlimit rlimit;
-  enum strtol_error e = xstrtoumax (s, NULL, 10, &n, NULL);
-
-  /* Try to find out how many file descriptors we'll be able
-     to open.  We need at least nmerge + 3 (STDIN_FILENO,
-     STDOUT_FILENO and STDERR_FILENO). */
-  unsigned int max_nmerge = ((getrlimit (RLIMIT_NOFILE, &rlimit) == 0
-                              ? rlimit.rlim_cur
-                              : OPEN_MAX)
-                             - 3);
+  char *suffix;
+  enum strtol_error e = xstrtoumax (s, &suffix, 10, &n, "EgGkKmMPtTYZ");
 
-  if (e == LONGINT_OK)
+  /* The default unit is KiB.  */
+  if (e == LONGINT_OK && ISDIGIT (suffix[-1]))
     {
-      nmerge = n;
-      if (nmerge != n)
-        e = LONGINT_OVERFLOW;
+      if (n <= UINTMAX_MAX / 1024)
+	n *= 1024;
       else
-        {
-          if (nmerge < 2)
-            {
-              error (0, 0, _("invalid --%s argument %s"),
-                     long_options[oi].name, quote (s));
-              die (SORT_FAILURE, 0,
-                   _("minimum --%s argument is %s"),
-                   long_options[oi].name, quote ("2"));
-            }
-          else if (max_nmerge < nmerge)
-            {
-              e = LONGINT_OVERFLOW;
-            }
-          else
-            return;
-        }
-    }
-
-  if (e == LONGINT_OVERFLOW)
-    {
-      char max_nmerge_buf[INT_BUFSIZE_BOUND (max_nmerge)];
-      error (0, 0, _("--%s argument %s too large"),
-             long_options[oi].name, quote (s));
-      die (SORT_FAILURE, 0,
-           _("maximum --%s argument with current rlimit is %s"),
-           long_options[oi].name,
-           uinttostr (max_nmerge, max_nmerge_buf));
-    }
-  else
-    xstrtol_fatal (e, oi, c, long_options, s);
-}
-
-/* Specify the amount of main memory to use when sorting.  */
-static void
-specify_sort_size (int oi, char c, char const *s)
-{
-  uintmax_t n;
-  char *suffix;
-  enum strtol_error e = xstrtoumax (s, &suffix, 10, &n, "EgGkKmMPtTYZ");
-
-  /* The default unit is KiB.  */
-  if (e == LONGINT_OK && ISDIGIT (suffix[-1]))
-    {
-      if (n <= UINTMAX_MAX / 1024)
-        n *= 1024;
-      else
-        e = LONGINT_OVERFLOW;
+	e = LONGINT_OVERFLOW;
     }
 
   /* A 'b' suffix means bytes; a '%' suffix means percent of memory.  */
   if (e == LONGINT_INVALID_SUFFIX_CHAR && ISDIGIT (suffix[-1]) && ! suffix[1])
     switch (suffix[0])
       {
       case 'b':
-        e = LONGINT_OK;
-        break;
+	e = LONGINT_OK;
+	break;
 
       case '%':
-        {
-          double mem = physmem_total () * n / 100;
-
-          /* Use "<", not "<=", to avoid problems with rounding.  */
-          if (mem < UINTMAX_MAX)
-            {
-              n = mem;
-              e = LONGINT_OK;
-            }
-          else
-            e = LONGINT_OVERFLOW;
-        }
-        break;
+	{
+	  double mem = physmem_total () * n / 100;
+
+	  /* Use "<", not "<=", to avoid problems with rounding.  */
+	  if (mem < UINTMAX_MAX)
+	    {
+	      n = mem;
+	      e = LONGINT_OK;
+	    }
+	  else
+	    e = LONGINT_OVERFLOW;
+	}
+	break;
       }
 
   if (e == LONGINT_OK)
     {
       /* If multiple sort sizes are specified, take the maximum, so
-         that option order does not matter.  */
+	 that option order does not matter.  */
       if (n < sort_size)
-        return;
+	return;
 
       sort_size = n;
       if (sort_size == n)
-        {
-          sort_size = MAX (sort_size, MIN_SORT_SIZE);
-          return;
-        }
+	{
+	  sort_size = MAX (sort_size, MIN_SORT_SIZE);
+	  return;
+	}
 
       e = LONGINT_OVERFLOW;
     }
 
-  xstrtol_fatal (e, oi, c, long_options, s);
-}
-
-/* Specify the number of threads to spawn during internal sort.  */
-static size_t
-specify_nthreads (int oi, char c, char const *s)
-{
-  unsigned long int nthreads;
-  enum strtol_error e = xstrtoul (s, NULL, 10, &nthreads, "");
-  if (e == LONGINT_OVERFLOW)
-    return SIZE_MAX;
-  if (e != LONGINT_OK)
-    xstrtol_fatal (e, oi, c, long_options, s);
-  if (SIZE_MAX < nthreads)
-    nthreads = SIZE_MAX;
-  if (nthreads == 0)
-    die (SORT_FAILURE, 0, _("number in parallel must be nonzero"));
-  return nthreads;
+#if !(defined __amigaos__ && defined __CLIB2__) /* AmigaOS using CLIB2 */
+#warning "implement in clib2 for AmigaOS"
+  STRTOL_FATAL_ERROR (s, _("sort size"), e);
+#endif
 }
 
 /* Return the default sort size.  */
 static size_t
 default_sort_size (void)
 {
-  /* Let SIZE be MEM, but no more than the maximum object size,
-     total memory, or system resource limits.  Don't bother to check
-     for values like RLIM_INFINITY since in practice they are not much
-     less than SIZE_MAX.  */
-  size_t size = SIZE_MAX;
+  /* Let MEM be available memory or 1/8 of total memory, whichever
+     is greater.  */
+  double avail = physmem_available ();
+  double total = physmem_total ();
+  double mem = MAX (avail, total / 8);
   struct rlimit rlimit;
+
+  /* Let SIZE be MEM, but no more than the maximum object size or
+     system resource limits.  Avoid the MIN macro here, as it is not
+     quite right when only one argument is floating point.  Don't
+     bother to check for values like RLIM_INFINITY since in practice
+     they are not much less than SIZE_MAX.  */
+  size_t size = SIZE_MAX;
+  if (mem < size)
+    size = mem;
   if (getrlimit (RLIMIT_DATA, &rlimit) == 0 && rlimit.rlim_cur < size)
     size = rlimit.rlim_cur;
 #ifdef RLIMIT_AS
   if (getrlimit (RLIMIT_AS, &rlimit) == 0 && rlimit.rlim_cur < size)
     size = rlimit.rlim_cur;
 #endif
@@ -1467,92 +691,78 @@ default_sort_size (void)
   /* Leave a 1/16 margin for RSS to leave room for code, stack, etc.
      Exceeding RSS is not fatal, but can be quite slow.  */
   if (getrlimit (RLIMIT_RSS, &rlimit) == 0 && rlimit.rlim_cur / 16 * 15 < size)
     size = rlimit.rlim_cur / 16 * 15;
 #endif
 
-  /* Let MEM be available memory or 1/8 of total memory, whichever
-     is greater.  */
-  double avail = physmem_available ();
-  double total = physmem_total ();
-  double mem = MAX (avail, total / 8);
-
-  /* Leave a 1/4 margin for physical memory.  */
-  if (total * 0.75 < size)
-    size = total * 0.75;
-
-  /* Return the minimum of MEM and SIZE, but no less than
-     MIN_SORT_SIZE.  Avoid the MIN macro here, as it is not quite
-     right when only one argument is floating point.  */
-  if (mem < size)
-    size = mem;
+  /* Use no less than the minimum.  */
   return MAX (size, MIN_SORT_SIZE);
 }
 
 /* Return the sort buffer size to use with the input files identified
-   by FPS and FILES, which are alternate names of the same files.
+   by FPS and FILES, which are alternate paths to the same files.
    NFILES gives the number of input files; NFPS may be less.  Assume
    that each input line requires LINE_BYTES extra bytes' worth of line
-   information.  Do not exceed the size bound specified by the user
-   (or a default size bound, if the user does not specify one).  */
+   information.  Do not exceed a bound on the size: if the bound is
+   not specified by the user, use a default.  */
 
 static size_t
-sort_buffer_size (FILE *const *fps, size_t nfps,
-                  char *const *files, size_t nfiles,
-                  size_t line_bytes)
+sort_buffer_size (FILE *const *fps, int nfps,
+		  char *const *files, int nfiles,
+		  size_t line_bytes)
 {
   /* A bound on the input size.  If zero, the bound hasn't been
      determined yet.  */
   static size_t size_bound;
 
   /* In the worst case, each input byte is a newline.  */
   size_t worst_case_per_input_byte = line_bytes + 1;
 
   /* Keep enough room for one extra input line and an extra byte.
      This extra room might be needed when preparing to read EOF.  */
   size_t size = worst_case_per_input_byte + 1;
 
-  size_t i;
+  int i;
 
   for (i = 0; i < nfiles; i++)
     {
       struct stat st;
       off_t file_size;
       size_t worst_case;
 
       if ((i < nfps ? fstat (fileno (fps[i]), &st)
-           : STREQ (files[i], "-") ? fstat (STDIN_FILENO, &st)
-           : stat (files[i], &st))
-          != 0)
-        sort_die (_("stat failed"), files[i]);
+	   : strcmp (files[i], "-") == 0 ? fstat (STDIN_FILENO, &st)
+	   : stat (files[i], &st))
+	  != 0)
+	die (_("stat failed"), files[i]);
 
       if (S_ISREG (st.st_mode))
-        file_size = st.st_size;
+	file_size = st.st_size;
       else
-        {
-          /* The file has unknown size.  If the user specified a sort
-             buffer size, use that; otherwise, guess the size.  */
-          if (sort_size)
-            return sort_size;
-          file_size = INPUT_FILE_SIZE_GUESS;
-        }
+	{
+	  /* The file has unknown size.  If the user specified a sort
+	     buffer size, use that; otherwise, guess the size.  */
+	  if (sort_size)
+	    return sort_size;
+	  file_size = INPUT_FILE_SIZE_GUESS;
+	}
 
       if (! size_bound)
-        {
-          size_bound = sort_size;
-          if (! size_bound)
-            size_bound = default_sort_size ();
-        }
+	{
+	  size_bound = sort_size;
+	  if (! size_bound)
+	    size_bound = default_sort_size ();
+	}
 
       /* Add the amount of memory needed to represent the worst case
-         where the input consists entirely of newlines followed by a
-         single non-newline.  Check for overflow.  */
+	 where the input consists entirely of newlines followed by a
+	 single non-newline.  Check for overflow.  */
       worst_case = file_size * worst_case_per_input_byte + 1;
       if (file_size != worst_case / worst_case_per_input_byte
-          || size_bound - size <= worst_case)
-        return size_bound;
+	  || size_bound - size <= worst_case)
+	return size_bound;
       size += worst_case;
     }
 
   return size;
 }
 
@@ -1564,21 +774,21 @@ static void
 initbuf (struct buffer *buf, size_t line_bytes, size_t alloc)
 {
   /* Ensure that the line array is properly aligned.  If the desired
      size cannot be allocated, repeatedly halve it until allocation
      succeeds.  The smaller allocation may hurt overall performance,
      but that's better than failing.  */
-  while (true)
+  for (;;)
     {
       alloc += sizeof (struct line) - alloc % sizeof (struct line);
       buf->buf = malloc (alloc);
       if (buf->buf)
-        break;
+	break;
       alloc /= 2;
       if (alloc <= line_bytes + 1)
-        xalloc_die ();
+	xalloc_die ();
     }
 
   buf->line_bytes = line_bytes;
   buf->alloc = alloc;
   buf->used = buf->left = buf->nlines = 0;
   buf->eof = false;
@@ -1586,105 +796,105 @@ initbuf (struct buffer *buf, size_t line_bytes, size_t alloc)
 
 /* Return one past the limit of the line array.  */
 
 static inline struct line *
 buffer_linelim (struct buffer const *buf)
 {
-  void *linelim = buf->buf + buf->alloc;
-  return linelim;
+  return (struct line *) (buf->buf + buf->alloc);
 }
 
 /* Return a pointer to the first character of the field specified
    by KEY in LINE. */
 
 static char *
-begfield (struct line const *line, struct keyfield const *key)
+begfield (const struct line *line, const struct keyfield *key)
 {
-  char *ptr = line->text, *lim = ptr + line->length - 1;
-  size_t sword = key->sword;
-  size_t schar = key->schar;
+  register char *ptr = line->text, *lim = ptr + line->length - 1;
+  register size_t sword = key->sword;
+  register size_t schar = key->schar;
+  register size_t remaining_bytes;
 
   /* The leading field separator itself is included in a field when -t
      is absent.  */
 
   if (tab != TAB_DEFAULT)
     while (ptr < lim && sword--)
       {
-        while (ptr < lim && *ptr != tab)
-          ++ptr;
-        if (ptr < lim)
-          ++ptr;
+	while (ptr < lim && *ptr != tab)
+	  ++ptr;
+	if (ptr < lim)
+	  ++ptr;
       }
   else
     while (ptr < lim && sword--)
       {
-        while (ptr < lim && blanks[to_uchar (*ptr)])
-          ++ptr;
-        while (ptr < lim && !blanks[to_uchar (*ptr)])
-          ++ptr;
+	while (ptr < lim && blanks[UCHAR (*ptr)])
+	  ++ptr;
+	while (ptr < lim && !blanks[UCHAR (*ptr)])
+	  ++ptr;
       }
 
-  /* If we're ignoring leading blanks when computing the Start
-     of the field, skip past them here.  */
   if (key->skipsblanks)
-    while (ptr < lim && blanks[to_uchar (*ptr)])
+    while (ptr < lim && blanks[UCHAR (*ptr)])
       ++ptr;
 
   /* Advance PTR by SCHAR (if possible), but no further than LIM.  */
-  ptr = MIN (lim, ptr + schar);
+  remaining_bytes = lim - ptr;
+  if (schar < remaining_bytes)
+    ptr += schar;
+  else
+    ptr = lim;
 
   return ptr;
 }
 
 /* Return the limit of (a pointer to the first character after) the field
    in LINE specified by KEY. */
 
 static char *
-limfield (struct line const *line, struct keyfield const *key)
+limfield (const struct line *line, const struct keyfield *key)
 {
-  char *ptr = line->text, *lim = ptr + line->length - 1;
-  size_t eword = key->eword, echar = key->echar;
-
-  if (echar == 0)
-    eword++; /* Skip all of end field.  */
+  register char *ptr = line->text, *lim = ptr + line->length - 1;
+  register size_t eword = key->eword, echar = key->echar;
+  register size_t remaining_bytes;
 
   /* Move PTR past EWORD fields or to one past the last byte on LINE,
      whichever comes first.  If there are more than EWORD fields, leave
      PTR pointing at the beginning of the field having zero-based index,
      EWORD.  If a delimiter character was specified (via -t), then that
-     'beginning' is the first character following the delimiting TAB.
-     Otherwise, leave PTR pointing at the first 'blank' character after
+     `beginning' is the first character following the delimiting TAB.
+     Otherwise, leave PTR pointing at the first `blank' character after
      the preceding field.  */
   if (tab != TAB_DEFAULT)
     while (ptr < lim && eword--)
       {
-        while (ptr < lim && *ptr != tab)
-          ++ptr;
-        if (ptr < lim && (eword || echar))
-          ++ptr;
+	while (ptr < lim && *ptr != tab)
+	  ++ptr;
+	if (ptr < lim && (eword | echar))
+	  ++ptr;
       }
   else
     while (ptr < lim && eword--)
       {
-        while (ptr < lim && blanks[to_uchar (*ptr)])
-          ++ptr;
-        while (ptr < lim && !blanks[to_uchar (*ptr)])
-          ++ptr;
+	while (ptr < lim && blanks[UCHAR (*ptr)])
+	  ++ptr;
+	while (ptr < lim && !blanks[UCHAR (*ptr)])
+	  ++ptr;
       }
 
 #ifdef POSIX_UNSPECIFIED
   /* The following block of code makes GNU sort incompatible with
      standard Unix sort, so it's ifdef'd out for now.
      The POSIX spec isn't clear on how to interpret this.
      FIXME: request clarification.
 
      From: kwzh@gnu.ai.mit.edu (Karl Heuer)
      Date: Thu, 30 May 96 12:20:41 -0400
      [Translated to POSIX 1003.1-2001 terminology by Paul Eggert.]
 
-     [...]I believe I've found another bug in 'sort'.
+     [...]I believe I've found another bug in `sort'.
 
      $ cat /tmp/sort.in
      a b c 2 d
      pq rs 1 t
      $ textutils-1.15/src/sort -k1.7,1.7 </tmp/sort.in
      a b c 2 d
@@ -1705,49 +915,61 @@ limfield (struct line const *line, struct keyfield const *key)
   /* Make LIM point to the end of (one byte past) the current field.  */
   if (tab != TAB_DEFAULT)
     {
       char *newlim;
       newlim = memchr (ptr, tab, lim - ptr);
       if (newlim)
-        lim = newlim;
+	lim = newlim;
     }
   else
     {
       char *newlim;
       newlim = ptr;
-      while (newlim < lim && blanks[to_uchar (*newlim)])
-        ++newlim;
-      while (newlim < lim && !blanks[to_uchar (*newlim)])
-        ++newlim;
+      while (newlim < lim && blanks[UCHAR (*newlim)])
+	++newlim;
+      while (newlim < lim && !blanks[UCHAR (*newlim)])
+	++newlim;
       lim = newlim;
     }
 #endif
 
-  if (echar != 0) /* We need to skip over a portion of the end field.  */
-    {
-      /* If we're ignoring leading blanks when computing the End
-         of the field, skip past them here.  */
-      if (key->skipeblanks)
-        while (ptr < lim && blanks[to_uchar (*ptr)])
-          ++ptr;
+  /* If we're skipping leading blanks, don't start counting characters
+     until after skipping past any leading blanks.  */
+  if (key->skipsblanks)
+    while (ptr < lim && blanks[UCHAR (*ptr)])
+      ++ptr;
 
-      /* Advance PTR by ECHAR (if possible), but no further than LIM.  */
-      ptr = MIN (lim, ptr + echar);
-    }
+  /* Advance PTR by ECHAR (if possible), but no further than LIM.  */
+  remaining_bytes = lim - ptr;
+  if (echar < remaining_bytes)
+    ptr += echar;
+  else
+    ptr = lim;
 
   return ptr;
 }
 
+/* Return the number of trailing blanks in FIELD, with LEN bytes.  */
+
+static size_t
+trailing_blanks (char const *field, size_t len)
+{
+  size_t i;
+  for (i = len; 0 < i && blanks[UCHAR (field[i - 1])]; i--)
+    continue;
+  return len - i;
+}
+
 /* Fill BUF reading from FP, moving buf->left bytes from the end
    of buf->buf to the beginning first.  If EOF is reached and the
    file wasn't terminated by a newline, supply one.  Set up BUF's line
    table too.  FILE is the name of the file corresponding to FP.
    Return true if some input was read.  */
 
 static bool
-fillbuf (struct buffer *buf, FILE *fp, char const *file)
+fillbuf (struct buffer *buf, register FILE *fp, char const *file)
 {
   struct keyfield const *key = keylist;
   char eol = eolchar;
   size_t line_bytes = buf->line_bytes;
   size_t mergesize = merge_buffer_size - MIN_MERGE_BUFFER_SIZE;
 
@@ -1758,956 +980,548 @@ fillbuf (struct buffer *buf, FILE *fp, char const *file)
     {
       memmove (buf->buf, buf->buf + buf->used - buf->left, buf->left);
       buf->used = buf->left;
       buf->nlines = 0;
     }
 
-  while (true)
+  for (;;)
     {
       char *ptr = buf->buf + buf->used;
       struct line *linelim = buffer_linelim (buf);
       struct line *line = linelim - buf->nlines;
       size_t avail = (char *) linelim - buf->nlines * line_bytes - ptr;
       char *line_start = buf->nlines ? line->text + line->length : buf->buf;
 
       while (line_bytes + 1 < avail)
-        {
-          /* Read as many bytes as possible, but do not read so many
-             bytes that there might not be enough room for the
-             corresponding line array.  The worst case is when the
-             rest of the input file consists entirely of newlines,
-             except that the last byte is not a newline.  */
-          size_t readsize = (avail - 1) / (line_bytes + 1);
-          size_t bytes_read = fread (ptr, 1, readsize, fp);
-          char *ptrlim = ptr + bytes_read;
-          char *p;
-          avail -= bytes_read;
-
-          if (bytes_read != readsize)
-            {
-              if (ferror (fp))
-                sort_die (_("read failed"), file);
-              if (feof (fp))
-                {
-                  buf->eof = true;
-                  if (buf->buf == ptrlim)
-                    return false;
-                  if (line_start != ptrlim && ptrlim[-1] != eol)
-                    *ptrlim++ = eol;
-                }
-            }
-
-          /* Find and record each line in the just-read input.  */
-          while ((p = memchr (ptr, eol, ptrlim - ptr)))
-            {
-              /* Delimit the line with NUL. This eliminates the need to
-                 temporarily replace the last byte with NUL when calling
-                 xmemcoll(), which increases performance.  */
-              *p = '\0';
-              ptr = p + 1;
-              line--;
-              line->text = line_start;
-              line->length = ptr - line_start;
-              mergesize = MAX (mergesize, line->length);
-              avail -= line_bytes;
-
-              if (key)
-                {
-                  /* Precompute the position of the first key for
-                     efficiency.  */
-                  line->keylim = (key->eword == SIZE_MAX
-                                  ? p
-                                  : limfield (line, key));
-
-                  if (key->sword != SIZE_MAX)
-                    line->keybeg = begfield (line, key);
-                  else
-                    {
-                      if (key->skipsblanks)
-                        while (blanks[to_uchar (*line_start)])
-                          line_start++;
-                      line->keybeg = line_start;
-                    }
-                }
-
-              line_start = ptr;
-            }
-
-          ptr = ptrlim;
-          if (buf->eof)
-            break;
-        }
+	{
+	  /* Read as many bytes as possible, but do not read so many
+	     bytes that there might not be enough room for the
+	     corresponding line array.  The worst case is when the
+	     rest of the input file consists entirely of newlines,
+	     except that the last byte is not a newline.  */
+	  size_t readsize = (avail - 1) / (line_bytes + 1);
+	  size_t bytes_read = fread (ptr, 1, readsize, fp);
+	  char *ptrlim = ptr + bytes_read;
+	  char *p;
+	  avail -= bytes_read;
+
+	  if (bytes_read != readsize)
+	    {
+	      if (ferror (fp))
+		die (_("read failed"), file);
+	      if (feof (fp))
+		{
+		  buf->eof = true;
+		  if (buf->buf == ptrlim)
+		    return false;
+		  if (ptrlim[-1] != eol)
+		    *ptrlim++ = eol;
+		}
+	    }
+
+	  /* Find and record each line in the just-read input.  */
+	  while ((p = memchr (ptr, eol, ptrlim - ptr)))
+	    {
+	      ptr = p + 1;
+	      line--;
+	      line->text = line_start;
+	      line->length = ptr - line_start;
+	      mergesize = MAX (mergesize, line->length);
+	      avail -= line_bytes;
+
+	      if (key)
+		{
+		  /* Precompute the position of the first key for
+                     efficiency. */
+		  line->keylim = (key->eword == SIZE_MAX
+				  ? p
+				  : limfield (line, key));
+
+		  if (key->sword != SIZE_MAX)
+		    line->keybeg = begfield (line, key);
+		  else
+		    {
+		      if (key->skipsblanks)
+			while (blanks[UCHAR (*line_start)])
+			  line_start++;
+		      line->keybeg = line_start;
+		    }
+		  if (key->skipeblanks)
+		    {
+		      size_t keylen = line->keylim - line->keybeg;
+		      line->keylim -= trailing_blanks (line->keybeg, keylen);
+		    }
+		}
+
+	      line_start = ptr;
+	    }
+
+	  ptr = ptrlim;
+	  if (buf->eof)
+	    break;
+	}
 
       buf->used = ptr - buf->buf;
       buf->nlines = buffer_linelim (buf) - line;
       if (buf->nlines != 0)
-        {
-          buf->left = ptr - line_start;
-          merge_buffer_size = mergesize + MIN_MERGE_BUFFER_SIZE;
-          return true;
-        }
+	{
+	  buf->left = ptr - line_start;
+	  merge_buffer_size = mergesize + MIN_MERGE_BUFFER_SIZE;
+	  return true;
+	}
+
+      /* The current input line is too long to fit in the buffer.
+	 Double the buffer size and try again.  */
+      buf->buf = x2nrealloc (buf->buf, &buf->alloc, sizeof *(buf->buf));
+    }
+}
+
+/* Compare strings A and B containing decimal fractions < 1.  Each string
+   should begin with a decimal point followed immediately by the digits
+   of the fraction.  Strings not of this form are considered to be zero. */
+
+/* The goal here, is to take two numbers a and b... compare these
+   in parallel.  Instead of converting each, and then comparing the
+   outcome.  Most likely stopping the comparison before the conversion
+   is complete.  The algorithm used, in the old sort:
+
+   Algorithm: fraccompare
+   Action   : compare two decimal fractions
+   accepts  : char *a, char *b
+   returns  : -1 if a<b, 0 if a=b, 1 if a>b.
+   implement:
+
+   if *a == decimal_point AND *b == decimal_point
+     find first character different in a and b.
+     if both are digits, return the difference *a - *b.
+     if *a is a digit
+       skip past zeros
+       if digit return 1, else 0
+     if *b is a digit
+       skip past zeros
+       if digit return -1, else 0
+   if *a is a decimal_point
+     skip past decimal_point and zeros
+     if digit return 1, else 0
+   if *b is a decimal_point
+     skip past decimal_point and zeros
+     if digit return -1, else 0
+   return 0 */
 
-      {
-        /* The current input line is too long to fit in the buffer.
-           Increase the buffer size and try again, keeping it properly
-           aligned.  */
-        size_t line_alloc = buf->alloc / sizeof (struct line);
-        buf->buf = x2nrealloc (buf->buf, &line_alloc, sizeof (struct line));
-        buf->alloc = line_alloc * sizeof (struct line);
-      }
+static int
+fraccompare (register const char *a, register const char *b)
+{
+  if (*a == decimal_point && *b == decimal_point)
+    {
+      while (*++a == *++b)
+	if (! ISDIGIT (*a))
+	  return 0;
+      if (ISDIGIT (*a) && ISDIGIT (*b))
+	return *a - *b;
+      if (ISDIGIT (*a))
+	goto a_trailing_nonzero;
+      if (ISDIGIT (*b))
+	goto b_trailing_nonzero;
+      return 0;
+    }
+  else if (*a++ == decimal_point)
+    {
+    a_trailing_nonzero:
+      while (*a == NUMERIC_ZERO)
+	a++;
+      return ISDIGIT (*a);
+    }
+  else if (*b++ == decimal_point)
+    {
+    b_trailing_nonzero:
+      while (*b == NUMERIC_ZERO)
+	b++;
+      return - ISDIGIT (*b);
     }
+  return 0;
 }
 
-/* Table that maps characters to order-of-magnitude values.  */
-static char const unit_order[UCHAR_LIM] =
-  {
-#if ! ('K' == 75 && 'M' == 77 && 'G' == 71 && 'T' == 84 && 'P' == 80 \
-     && 'E' == 69 && 'Z' == 90 && 'Y' == 89 && 'k' == 107)
-    /* This initializer syntax works on all C99 hosts.  For now, use
-       it only on non-ASCII hosts, to ease the pain of porting to
-       pre-C99 ASCII hosts.  */
-    ['K']=1, ['M']=2, ['G']=3, ['T']=4, ['P']=5, ['E']=6, ['Z']=7, ['Y']=8,
-    ['k']=1,
-#else
-    /* Generate the following table with this command:
-       perl -e 'my %a=(k=>1, K=>1, M=>2, G=>3, T=>4, P=>5, E=>6, Z=>7, Y=>8);
-       foreach my $i (0..255) {my $c=chr($i); $a{$c} ||= 0;print "$a{$c}, "}'\
-       |fmt  */
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 3,
-    0, 0, 0, 1, 0, 2, 0, 0, 5, 0, 0, 0, 4, 0, 0, 0, 0, 8, 7, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
-#endif
-  };
+/* Compare strings A and B as numbers without explicitly converting them to
+   machine numbers.  Comparatively slow for short strings, but asymptotically
+   hideously fast. */
 
-/* Traverse number given as *number consisting of digits, thousands_sep, and
-   decimal_point chars only.  Returns the highest digit found in the number,
-   or '\0' if no digit has been found.  Upon return *number points at the
-   character that immediately follows after the given number.  */
-static unsigned char
-traverse_raw_number (char const **number)
+static int
+numcompare (register const char *a, register const char *b)
 {
-  char const *p = *number;
-  unsigned char ch;
-  unsigned char max_digit = '\0';
-  bool ends_with_thousands_sep = false;
-
-  /* Scan to end of number.
-     Decimals or separators not followed by digits stop the scan.
-     Numbers ending in decimals or separators are thus considered
-     to be lacking in units.
-     FIXME: add support for multibyte thousands_sep and decimal_point.  */
-
-  while (ISDIGIT (ch = *p++))
-    {
-      if (max_digit < ch)
-        max_digit = ch;
-
-      /* Allow to skip only one occurrence of thousands_sep to avoid finding
-         the unit in the next column in case thousands_sep matches as blank
-         and is used as column delimiter.  */
-      ends_with_thousands_sep = (*p == thousands_sep);
-      if (ends_with_thousands_sep)
-        ++p;
-    }
+  register int tmpa, tmpb, tmp;
+  register size_t log_a, log_b;
+
+  tmpa = *a;
+  tmpb = *b;
 
-  if (ends_with_thousands_sep)
+  while (blanks[UCHAR (tmpa)])
+    tmpa = *++a;
+  while (blanks[UCHAR (tmpb)])
+    tmpb = *++b;
+
+  if (tmpa == NEGATION_SIGN)
     {
-      /* thousands_sep not followed by digit is not allowed.  */
-      *number = p - 2;
-      return max_digit;
-    }
+      do
+	tmpa = *++a;
+      while (tmpa == NUMERIC_ZERO || IS_THOUSANDS_SEP (tmpa));
+      if (tmpb != NEGATION_SIGN)
+	{
+	  if (tmpa == decimal_point)
+	    do
+	      tmpa = *++a;
+	    while (tmpa == NUMERIC_ZERO);
+	  if (ISDIGIT (tmpa))
+	    return -1;
+	  while (tmpb == NUMERIC_ZERO || IS_THOUSANDS_SEP (tmpb))
+	    tmpb = *++b;
+	  if (tmpb == decimal_point)
+	    do
+	      tmpb = *++b;
+	    while (tmpb == NUMERIC_ZERO);
+	  if (ISDIGIT (tmpb))
+	    return -1;
+	  return 0;
+	}
+      do
+	tmpb = *++b;
+      while (tmpb == NUMERIC_ZERO || IS_THOUSANDS_SEP (tmpb));
 
-  if (ch == decimal_point)
-    while (ISDIGIT (ch = *p++))
-      if (max_digit < ch)
-        max_digit = ch;
+      while (tmpa == tmpb && ISDIGIT (tmpa))
+	{
+	  do
+	    tmpa = *++a;
+	  while (IS_THOUSANDS_SEP (tmpa));
+	  do
+	    tmpb = *++b;
+	  while (IS_THOUSANDS_SEP (tmpb));
+	}
 
-  *number = p - 1;
-  return max_digit;
-}
+      if ((tmpa == decimal_point && !ISDIGIT (tmpb))
+	  || (tmpb == decimal_point && !ISDIGIT (tmpa)))
+	return -fraccompare (a, b);
 
-/* Return an integer that represents the order of magnitude of the
-   unit following the number.  The number may contain thousands
-   separators and a decimal point, but it may not contain leading blanks.
-   Negative numbers get negative orders; zero numbers have a zero order.  */
+      tmp = tmpb - tmpa;
 
-static int _GL_ATTRIBUTE_PURE
-find_unit_order (char const *number)
-{
-  bool minus_sign = (*number == '-');
-  char const *p = number + minus_sign;
-  unsigned char max_digit = traverse_raw_number (&p);
-  if ('0' < max_digit)
+      for (log_a = 0; ISDIGIT (tmpa); ++log_a)
+	do
+	  tmpa = *++a;
+	while (IS_THOUSANDS_SEP (tmpa));
+
+      for (log_b = 0; ISDIGIT (tmpb); ++log_b)
+	do
+	  tmpb = *++b;
+	while (IS_THOUSANDS_SEP (tmpb));
+
+      if (log_a != log_b)
+	return log_a < log_b ? 1 : -1;
+
+      if (!log_a)
+	return 0;
+
+      return tmp;
+    }
+  else if (tmpb == NEGATION_SIGN)
     {
-      unsigned char ch = *p;
-      int order = unit_order[ch];
-      return (minus_sign ? -order : order);
+      do
+	tmpb = *++b;
+      while (tmpb == NUMERIC_ZERO || IS_THOUSANDS_SEP (tmpb));
+      if (tmpb == decimal_point)
+	do
+	  tmpb = *++b;
+	while (tmpb == NUMERIC_ZERO);
+      if (ISDIGIT (tmpb))
+	return 1;
+      while (tmpa == NUMERIC_ZERO || IS_THOUSANDS_SEP (tmpa))
+	tmpa = *++a;
+      if (tmpa == decimal_point)
+	do
+	  tmpa = *++a;
+	while (tmpa == NUMERIC_ZERO);
+      if (ISDIGIT (tmpa))
+	return 1;
+      return 0;
     }
   else
-    return 0;
-}
+    {
+      while (tmpa == NUMERIC_ZERO || IS_THOUSANDS_SEP (tmpa))
+	tmpa = *++a;
+      while (tmpb == NUMERIC_ZERO || IS_THOUSANDS_SEP (tmpb))
+	tmpb = *++b;
 
-/* Compare numbers A and B ending in units with SI or IEC prefixes
-       <none/unknown> < K/k < M < G < T < P < E < Z < Y  */
+      while (tmpa == tmpb && ISDIGIT (tmpa))
+	{
+	  do
+	    tmpa = *++a;
+	  while (IS_THOUSANDS_SEP (tmpa));
+	  do
+	    tmpb = *++b;
+	  while (IS_THOUSANDS_SEP (tmpb));
+	}
 
-static int
-human_numcompare (char const *a, char const *b)
-{
-  while (blanks[to_uchar (*a)])
-    a++;
-  while (blanks[to_uchar (*b)])
-    b++;
+      if ((tmpa == decimal_point && !ISDIGIT (tmpb))
+	  || (tmpb == decimal_point && !ISDIGIT (tmpa)))
+	return fraccompare (a, b);
 
-  int diff = find_unit_order (a) - find_unit_order (b);
-  return (diff ? diff : strnumcmp (a, b, decimal_point, thousands_sep));
-}
+      tmp = tmpa - tmpb;
 
-/* Compare strings A and B as numbers without explicitly converting them to
-   machine numbers.  Comparatively slow for short strings, but asymptotically
-   hideously fast. */
+      for (log_a = 0; ISDIGIT (tmpa); ++log_a)
+	do
+	  tmpa = *++a;
+	while (IS_THOUSANDS_SEP (tmpa));
 
-static int
-numcompare (char const *a, char const *b)
-{
-  while (blanks[to_uchar (*a)])
-    a++;
-  while (blanks[to_uchar (*b)])
-    b++;
+      for (log_b = 0; ISDIGIT (tmpb); ++log_b)
+	do
+	  tmpb = *++b;
+	while (IS_THOUSANDS_SEP (tmpb));
 
-  return strnumcmp (a, b, decimal_point, thousands_sep);
-}
-
-/* Work around a problem whereby the long double value returned by glibc's
-   strtold ("NaN", ...) contains uninitialized bits: clear all bytes of
-   A and B before calling strtold.  FIXME: remove this function once
-   gnulib guarantees that strtold's result is always well defined.  */
-static int
-nan_compare (char const *sa, char const *sb)
-{
-  long_double a;
-  memset (&a, 0, sizeof a);
-  a = strtold (sa, NULL);
+      if (log_a != log_b)
+	return log_a < log_b ? -1 : 1;
 
-  long_double b;
-  memset (&b, 0, sizeof b);
-  b = strtold (sb, NULL);
+      if (!log_a)
+	return 0;
 
-  return memcmp (&a, &b, sizeof a);
+      return tmp;
+    }
 }
 
 static int
-general_numcompare (char const *sa, char const *sb)
+general_numcompare (const char *sa, const char *sb)
 {
+  /* FIXME: add option to warn about failed conversions.  */
   /* FIXME: maybe add option to try expensive FP conversion
      only if A and B can't be compared more cheaply/accurately.  */
 
   char *ea;
   char *eb;
-  long_double a = strtold (sa, &ea);
-  long_double b = strtold (sb, &eb);
+  double a = strtod (sa, &ea);
+  double b = strtod (sb, &eb);
 
   /* Put conversion errors at the start of the collating sequence.  */
   if (sa == ea)
     return sb == eb ? 0 : -1;
   if (sb == eb)
     return 1;
 
   /* Sort numbers in the usual way, where -0 == +0.  Put NaNs after
      conversion errors but before numbers; sort them by internal
      bit-pattern, for lack of a more portable alternative.  */
   return (a < b ? -1
-          : a > b ? 1
-          : a == b ? 0
-          : b == b ? -1
-          : a == a ? 1
-          : nan_compare (sa, sb));
+	  : a > b ? 1
+	  : a == b ? 0
+	  : b == b ? -1
+	  : a == a ? 1
+	  : memcmp ((char *) &a, (char *) &b, sizeof a));
 }
 
-/* Return an integer in 1..12 of the month name MONTH.
+/* Return an integer in 1..12 of the month name S with length LEN.
    Return 0 if the name in S is not recognized.  */
 
 static int
-getmonth (char const *month, char **ea)
+getmonth (const char *s, size_t len)
 {
-  size_t lo = 0;
-  size_t hi = MONTHS_PER_YEAR;
+  char *month;
+  register size_t i;
+  register int lo = 0, hi = MONTHS_PER_YEAR, result;
 
-  while (blanks[to_uchar (*month)])
-    month++;
-
-  do
+  while (len > 0 && blanks[UCHAR (*s)])
     {
-      size_t ix = (lo + hi) / 2;
-      char const *m = month;
-      char const *n = monthtab[ix].name;
-
-      for (;; m++, n++)
-        {
-          if (!*n)
-            {
-              if (ea)
-                *ea = (char *) m;
-              return monthtab[ix].val;
-            }
-          if (to_uchar (fold_toupper[to_uchar (*m)]) < to_uchar (*n))
-            {
-              hi = ix;
-              break;
-            }
-          else if (to_uchar (fold_toupper[to_uchar (*m)]) > to_uchar (*n))
-            {
-              lo = ix + 1;
-              break;
-            }
-        }
-    }
-  while (lo < hi);
-
-  return 0;
-}
-
-/* A randomly chosen MD5 state, used for random comparison.  */
-static struct md5_ctx random_md5_state;
-
-/* Initialize the randomly chosen MD5 state.  */
-
-static void
-random_md5_state_init (char const *random_source)
-{
-  unsigned char buf[MD5_DIGEST_SIZE];
-  struct randread_source *r = randread_new (random_source, sizeof buf);
-  if (! r)
-    sort_die (_("open failed"), random_source);
-  randread (r, buf, sizeof buf);
-  if (randread_free (r) != 0)
-    sort_die (_("close failed"), random_source);
-  md5_init_ctx (&random_md5_state);
-  md5_process_bytes (buf, sizeof buf, &random_md5_state);
-}
-
-/* This is like strxfrm, except it reports any error and exits.  */
-
-static size_t
-xstrxfrm (char *restrict dest, char const *restrict src, size_t destsize)
-{
-  errno = 0;
-  size_t translated_size = strxfrm (dest, src, destsize);
-
-  if (errno)
-    {
-      error (0, errno, _("string transformation failed"));
-      error (0, 0, _("set LC_ALL='C' to work around the problem"));
-      die (SORT_FAILURE, 0,
-           _("the untransformed string was %s"),
-           quotearg_n_style (0, locale_quoting_style, src));
-    }
-
-  return translated_size;
-}
-
-/* Compare the keys TEXTA (of length LENA) and TEXTB (of length LENB)
-   using one or more random hash functions.  TEXTA[LENA] and
-   TEXTB[LENB] must be zero.  */
-
-static int
-compare_random (char *restrict texta, size_t lena,
-                char *restrict textb, size_t lenb)
-{
-  /* XFRM_DIFF records the equivalent of memcmp on the transformed
-     data.  This is used to break ties if there is a checksum
-     collision, and this is good enough given the astronomically low
-     probability of a collision.  */
-  int xfrm_diff = 0;
-
-  char stackbuf[4000];
-  char *buf = stackbuf;
-  size_t bufsize = sizeof stackbuf;
-  void *allocated = NULL;
-  uint32_t dig[2][MD5_DIGEST_SIZE / sizeof (uint32_t)];
-  struct md5_ctx s[2];
-  s[0] = s[1] = random_md5_state;
-
-  if (hard_LC_COLLATE)
-    {
-      char const *lima = texta + lena;
-      char const *limb = textb + lenb;
-
-      while (true)
-        {
-          /* Transform the text into the basis of comparison, so that byte
-             strings that would otherwise considered to be equal are
-             considered equal here even if their bytes differ.
-
-             Each time through this loop, transform one
-             null-terminated string's worth from TEXTA or from TEXTB
-             or both.  That way, there's no need to store the
-             transformation of the whole line, if it contains many
-             null-terminated strings.  */
-
-          /* Store the transformed data into a big-enough buffer.  */
-
-          /* A 3X size guess avoids the overhead of calling strxfrm
-             twice on typical implementations.  Don't worry about
-             size_t overflow, as the guess need not be correct.  */
-          size_t guess_bufsize = 3 * (lena + lenb) + 2;
-          if (bufsize < guess_bufsize)
-            {
-              bufsize = MAX (guess_bufsize, bufsize * 3 / 2);
-              free (allocated);
-              buf = allocated = malloc (bufsize);
-              if (! buf)
-                {
-                  buf = stackbuf;
-                  bufsize = sizeof stackbuf;
-                }
-            }
-
-          size_t sizea =
-            (texta < lima ? xstrxfrm (buf, texta, bufsize) + 1 : 0);
-          bool a_fits = sizea <= bufsize;
-          size_t sizeb =
-            (textb < limb
-             ? (xstrxfrm ((a_fits ? buf + sizea : NULL), textb,
-                          (a_fits ? bufsize - sizea : 0))
-                + 1)
-             : 0);
-
-          if (! (a_fits && sizea + sizeb <= bufsize))
-            {
-              bufsize = sizea + sizeb;
-              if (bufsize < SIZE_MAX / 3)
-                bufsize = bufsize * 3 / 2;
-              free (allocated);
-              buf = allocated = xmalloc (bufsize);
-              if (texta < lima)
-                strxfrm (buf, texta, sizea);
-              if (textb < limb)
-                strxfrm (buf + sizea, textb, sizeb);
-            }
-
-          /* Advance past NULs to the next part of each input string,
-             exiting the loop if both strings are exhausted.  When
-             exiting the loop, prepare to finish off the tiebreaker
-             comparison properly.  */
-          if (texta < lima)
-            texta += strlen (texta) + 1;
-          if (textb < limb)
-            textb += strlen (textb) + 1;
-          if (! (texta < lima || textb < limb))
-            {
-              lena = sizea; texta = buf;
-              lenb = sizeb; textb = buf + sizea;
-              break;
-            }
-
-          /* Accumulate the transformed data in the corresponding
-             checksums.  */
-          md5_process_bytes (buf, sizea, &s[0]);
-          md5_process_bytes (buf + sizea, sizeb, &s[1]);
-
-          /* Update the tiebreaker comparison of the transformed data.  */
-          if (! xfrm_diff)
-            {
-              xfrm_diff = memcmp (buf, buf + sizea, MIN (sizea, sizeb));
-              if (! xfrm_diff)
-                xfrm_diff = (sizea > sizeb) - (sizea < sizeb);
-            }
-        }
-    }
-
-  /* Compute and compare the checksums.  */
-  md5_process_bytes (texta, lena, &s[0]); md5_finish_ctx (&s[0], dig[0]);
-  md5_process_bytes (textb, lenb, &s[1]); md5_finish_ctx (&s[1], dig[1]);
-  int diff = memcmp (dig[0], dig[1], sizeof dig[0]);
-
-  /* Fall back on the tiebreaker if the checksums collide.  */
-  if (! diff)
-    {
-      if (! xfrm_diff)
-        {
-          xfrm_diff = memcmp (texta, textb, MIN (lena, lenb));
-          if (! xfrm_diff)
-            xfrm_diff = (lena > lenb) - (lena < lenb);
-        }
-
-      diff = xfrm_diff;
+      ++s;
+      --len;
     }
 
-  free (allocated);
-
-  return diff;
-}
-
-/* Return the printable width of the block of memory starting at
-   TEXT and ending just before LIM, counting each tab as one byte.
-   FIXME: Should we generally be counting non printable chars?  */
-
-static size_t
-debug_width (char const *text, char const *lim)
-{
-  size_t width = mbsnwidth (text, lim - text, 0);
-  while (text < lim)
-    width += (*text++ == '\t');
-  return width;
-}
+  if (len == 0)
+    return 0;
 
-/* For debug mode, "underline" a key at the
-   specified offset and screen width.  */
+  month = alloca (len + 1);
+  for (i = 0; i < len; ++i)
+    month[i] = fold_toupper[UCHAR (s[i])];
+  len -= trailing_blanks (month, len);
+  month[len] = '\0';
 
-static void
-mark_key (size_t offset, size_t width)
-{
-  while (offset--)
-    putchar (' ');
-
-  if (!width)
-    printf (_("^ no match for key\n"));
-  else
+  do
     {
-      do
-        putchar ('_');
-      while (--width);
-
-      putchar ('\n');
-    }
-}
-
-/* Return true if KEY is a numeric key.  */
+      int ix = (lo + hi) / 2;
 
-static inline bool
-key_numeric (struct keyfield const *key)
-{
-  return key->numeric || key->general_numeric || key->human_numeric;
-}
-
-/* For LINE, output a debugging line that underlines KEY in LINE.
-   If KEY is null, underline the whole line.  */
-
-static void
-debug_key (struct line const *line, struct keyfield const *key)
-{
-  char *text = line->text;
-  char *beg = text;
-  char *lim = text + line->length - 1;
-
-  if (key)
-    {
-      if (key->sword != SIZE_MAX)
-        beg = begfield (line, key);
-      if (key->eword != SIZE_MAX)
-        lim = limfield (line, key);
-
-      if ((key->skipsblanks && key->sword == SIZE_MAX)
-          || key->month || key_numeric (key))
-        {
-          char saved = *lim;
-          *lim = '\0';
-
-          while (blanks[to_uchar (*beg)])
-            beg++;
-
-          char *tighter_lim = beg;
-
-          if (lim < beg)
-            tighter_lim = lim;
-          else if (key->month)
-            getmonth (beg, &tighter_lim);
-          else if (key->general_numeric)
-            ignore_value (strtold (beg, &tighter_lim));
-          else if (key->numeric || key->human_numeric)
-            {
-              char const *p = beg + (beg < lim && *beg == '-');
-              unsigned char max_digit = traverse_raw_number (&p);
-              if ('0' <= max_digit)
-                {
-                  unsigned char ch = *p;
-                  tighter_lim = (char *) p
-                    + (key->human_numeric && unit_order[ch]);
-                }
-            }
-          else
-            tighter_lim = lim;
-
-          *lim = saved;
-          lim = tighter_lim;
-        }
+      if (strncmp (month, monthtab[ix].name, strlen (monthtab[ix].name)) < 0)
+	hi = ix;
+      else
+	lo = ix;
     }
+  while (hi - lo > 1);
 
-  size_t offset = debug_width (text, beg);
-  size_t width = debug_width (beg, lim);
-  mark_key (offset, width);
-}
-
-/* Debug LINE by underlining its keys.  */
-
-static void
-debug_line (struct line const *line)
-{
-  struct keyfield const *key = keylist;
+  result = (!strncmp (month, monthtab[lo].name, strlen (monthtab[lo].name))
+	    ? monthtab[lo].val : 0);
 
-  do
-    debug_key (line, key);
-  while (key && ((key = key->next) || ! (unique || stable)));
-}
-
-/* Return whether sorting options specified for key.  */
-
-static bool
-default_key_compare (struct keyfield const *key)
-{
-  return ! (key->ignore
-            || key->translate
-            || key->skipsblanks
-            || key->skipeblanks
-            || key_numeric (key)
-            || key->month
-            || key->version
-            || key->random
-            /* || key->reverse */
-           );
-}
-
-/* Convert a key to the short options used to specify it.  */
-
-static void
-key_to_opts (struct keyfield const *key, char *opts)
-{
-  if (key->skipsblanks || key->skipeblanks)
-    *opts++ = 'b';/* either disables global -b  */
-  if (key->ignore == nondictionary)
-    *opts++ = 'd';
-  if (key->translate)
-    *opts++ = 'f';
-  if (key->general_numeric)
-    *opts++ = 'g';
-  if (key->human_numeric)
-    *opts++ = 'h';
-  if (key->ignore == nonprinting)
-    *opts++ = 'i';
-  if (key->month)
-    *opts++ = 'M';
-  if (key->numeric)
-    *opts++ = 'n';
-  if (key->random)
-    *opts++ = 'R';
-  if (key->reverse)
-    *opts++ = 'r';
-  if (key->version)
-    *opts++ = 'V';
-  *opts = '\0';
-}
-
-/* Output data independent key warnings to stderr.  */
-
-static void
-key_warnings (struct keyfield const *gkey, bool gkey_only)
-{
-  struct keyfield const *key;
-  struct keyfield ugkey = *gkey;
-  unsigned long keynum = 1;
-
-  for (key = keylist; key; key = key->next, keynum++)
-    {
-      if (key->traditional_used)
-        {
-          size_t sword = key->sword;
-          size_t eword = key->eword;
-          char tmp[INT_BUFSIZE_BOUND (uintmax_t)];
-          /* obsolescent syntax +A.x -B.y is equivalent to:
-               -k A+1.x+1,B.y   (when y = 0)
-               -k A+1.x+1,B+1.y (when y > 0)  */
-          char obuf[INT_BUFSIZE_BOUND (sword) * 2 + 4]; /* +# -#  */
-          char nbuf[INT_BUFSIZE_BOUND (sword) * 2 + 5]; /* -k #,#  */
-          char *po = obuf;
-          char *pn = nbuf;
-
-          if (sword == SIZE_MAX)
-            sword++;
-
-          po = stpcpy (stpcpy (po, "+"), umaxtostr (sword, tmp));
-          pn = stpcpy (stpcpy (pn, "-k "), umaxtostr (sword + 1, tmp));
-          if (key->eword != SIZE_MAX)
-            {
-              stpcpy (stpcpy (po, " -"), umaxtostr (eword + 1, tmp));
-              stpcpy (stpcpy (pn, ","),
-                      umaxtostr (eword + 1
-                                 + (key->echar == SIZE_MAX), tmp));
-            }
-          error (0, 0, _("obsolescent key %s used; consider %s instead"),
-                 quote_n (0, obuf), quote_n (1, nbuf));
-        }
-
-      /* Warn about field specs that will never match.  */
-      bool zero_width = key->sword != SIZE_MAX && key->eword < key->sword;
-      if (zero_width)
-        error (0, 0, _("key %lu has zero width and will be ignored"), keynum);
-
-      /* Warn about significant leading blanks.  */
-      bool implicit_skip = key_numeric (key) || key->month;
-      bool line_offset = key->eword == 0 && key->echar != 0; /* -k1.x,1.y  */
-      if (!zero_width && !gkey_only && tab == TAB_DEFAULT && !line_offset
-          && ((!key->skipsblanks && !implicit_skip)
-              || (!key->skipsblanks && key->schar)
-              || (!key->skipeblanks && key->echar)))
-        error (0, 0, _("leading blanks are significant in key %lu; "
-                       "consider also specifying 'b'"), keynum);
-
-      /* Warn about numeric comparisons spanning fields,
-         as field delimiters could be interpreted as part
-         of the number (maybe only in other locales).  */
-      if (!gkey_only && key_numeric (key))
-        {
-          size_t sword = key->sword + 1;
-          size_t eword = key->eword + 1;
-          if (!sword)
-            sword++;
-          if (!eword || sword < eword)
-            error (0, 0, _("key %lu is numeric and spans multiple fields"),
-                   keynum);
-        }
-
-      /* Flag global options not copied or specified in any key.  */
-      if (ugkey.ignore && (ugkey.ignore == key->ignore))
-        ugkey.ignore = NULL;
-      if (ugkey.translate && (ugkey.translate == key->translate))
-        ugkey.translate = NULL;
-      ugkey.skipsblanks &= !key->skipsblanks;
-      ugkey.skipeblanks &= !key->skipeblanks;
-      ugkey.month &= !key->month;
-      ugkey.numeric &= !key->numeric;
-      ugkey.general_numeric &= !key->general_numeric;
-      ugkey.human_numeric &= !key->human_numeric;
-      ugkey.random &= !key->random;
-      ugkey.version &= !key->version;
-      ugkey.reverse &= !key->reverse;
-    }
-
-  /* Warn about ignored global options flagged above.
-     Note if gkey is the only one in the list, all flags are cleared.  */
-  if (!default_key_compare (&ugkey)
-      || (ugkey.reverse && (stable || unique) && keylist))
-    {
-      bool ugkey_reverse = ugkey.reverse;
-      if (!(stable || unique))
-        ugkey.reverse = false;
-      /* The following is too big, but guaranteed to be "big enough".  */
-      char opts[sizeof short_options];
-      key_to_opts (&ugkey, opts);
-      error (0, 0,
-             ngettext ("option '-%s' is ignored",
-                       "options '-%s' are ignored",
-                       select_plural (strlen (opts))), opts);
-      ugkey.reverse = ugkey_reverse;
-    }
-  if (ugkey.reverse && !(stable || unique) && keylist)
-    error (0, 0, _("option '-r' only applies to last-resort comparison"));
+  return result;
 }
 
 /* Compare two lines A and B trying every key in sequence until there
    are no more keys or a difference is found. */
 
 static int
-keycompare (struct line const *a, struct line const *b)
+keycompare (const struct line *a, const struct line *b)
 {
-  struct keyfield *key = keylist;
+  struct keyfield const *key = keylist;
 
   /* For the first iteration only, the key positions have been
      precomputed for us. */
-  char *texta = a->keybeg;
-  char *textb = b->keybeg;
-  char *lima = a->keylim;
-  char *limb = b->keylim;
+  register char *texta = a->keybeg;
+  register char *textb = b->keybeg;
+  register char *lima = a->keylim;
+  register char *limb = b->keylim;
 
   int diff;
 
-  while (true)
+  for (;;)
     {
-      char const *translate = key->translate;
-      bool const *ignore = key->ignore;
-
-      /* Treat field ends before field starts as empty fields.  */
-      lima = MAX (texta, lima);
-      limb = MAX (textb, limb);
+      register char const *translate = key->translate;
+      register bool const *ignore = key->ignore;
 
       /* Find the lengths. */
-      size_t lena = lima - texta;
-      size_t lenb = limb - textb;
-
-      if (hard_LC_COLLATE || key_numeric (key)
-          || key->month || key->random || key->version)
-        {
-          char *ta;
-          char *tb;
-          size_t tlena;
-          size_t tlenb;
-
-          char enda IF_LINT (= 0);
-          char endb IF_LINT (= 0);
-          void *allocated IF_LINT (= NULL);
-          char stackbuf[4000];
-
-          if (ignore || translate)
-            {
-              /* Compute with copies of the keys, which are the result of
-                 translating or ignoring characters, and which need their
-                 own storage.  */
-
-              size_t i;
-
-              /* Allocate space for copies.  */
-              size_t size = lena + 1 + lenb + 1;
-              if (size <= sizeof stackbuf)
-                ta = stackbuf, allocated = NULL;
-              else
-                ta = allocated = xmalloc (size);
-              tb = ta + lena + 1;
-
-              /* Put into each copy a version of the key in which the
-                 requested characters are ignored or translated.  */
-              for (tlena = i = 0; i < lena; i++)
-                if (! (ignore && ignore[to_uchar (texta[i])]))
-                  ta[tlena++] = (translate
-                                 ? translate[to_uchar (texta[i])]
-                                 : texta[i]);
-              ta[tlena] = '\0';
-
-              for (tlenb = i = 0; i < lenb; i++)
-                if (! (ignore && ignore[to_uchar (textb[i])]))
-                  tb[tlenb++] = (translate
-                                 ? translate[to_uchar (textb[i])]
-                                 : textb[i]);
-              tb[tlenb] = '\0';
-            }
-          else
-            {
-              /* Use the keys in-place, temporarily null-terminated.  */
-              ta = texta; tlena = lena; enda = ta[tlena]; ta[tlena] = '\0';
-              tb = textb; tlenb = lenb; endb = tb[tlenb]; tb[tlenb] = '\0';
-            }
-
-          if (key->numeric)
-            diff = numcompare (ta, tb);
-          else if (key->general_numeric)
-            diff = general_numcompare (ta, tb);
-          else if (key->human_numeric)
-            diff = human_numcompare (ta, tb);
-          else if (key->month)
-            diff = getmonth (ta, NULL) - getmonth (tb, NULL);
-          else if (key->random)
-            diff = compare_random (ta, tlena, tb, tlenb);
-          else if (key->version)
-            diff = filevercmp (ta, tb);
-          else
-            {
-              /* Locale-dependent string sorting.  This is slower than
-                 C-locale sorting, which is implemented below.  */
-              if (tlena == 0)
-                diff = - NONZERO (tlenb);
-              else if (tlenb == 0)
-                diff = 1;
-              else
-                diff = xmemcoll0 (ta, tlena + 1, tb, tlenb + 1);
-            }
-
-          if (ignore || translate)
-            free (allocated);
-          else
-            {
-              ta[tlena] = enda;
-              tb[tlenb] = endb;
-            }
-        }
+      size_t lena = lima <= texta ? 0 : lima - texta;
+      size_t lenb = limb <= textb ? 0 : limb - textb;
+
+      if (key->skipeblanks)
+	{
+	  lena -= trailing_blanks (texta, lena);
+	  lenb -= trailing_blanks (textb, lenb);
+	}
+
+      /* Actually compare the fields. */
+      if (key->numeric | key->general_numeric)
+	{
+	  char savea = *lima, saveb = *limb;
+
+	  *lima = *limb = '\0';
+	  diff = ((key->numeric ? numcompare : general_numcompare)
+		  (texta, textb));
+	  *lima = savea, *limb = saveb;
+	}
+      else if (key->month)
+	diff = getmonth (texta, lena) - getmonth (textb, lenb);
+      /* Sorting like this may become slow, so in a simple locale the user
+         can select a faster sort that is similar to ascii sort  */
+      else if (HAVE_SETLOCALE && hard_LC_COLLATE)
+	{
+	  if (ignore || translate)
+	    {
+	      char *copy_a = alloca (lena + 1 + lenb + 1);
+	      char *copy_b = copy_a + lena + 1;
+	      size_t new_len_a, new_len_b, i;
+
+	      /* Ignore and/or translate chars before comparing.  */
+	      for (new_len_a = new_len_b = i = 0; i < MAX (lena, lenb); i++)
+		{
+		  if (i < lena)
+		    {
+		      copy_a[new_len_a] = (translate
+					   ? translate[UCHAR (texta[i])]
+					   : texta[i]);
+		      if (!ignore || !ignore[UCHAR (texta[i])])
+			++new_len_a;
+		    }
+		  if (i < lenb)
+		    {
+		      copy_b[new_len_b] = (translate
+					   ? translate[UCHAR (textb[i])]
+					   : textb [i]);
+		      if (!ignore || !ignore[UCHAR (textb[i])])
+			++new_len_b;
+		    }
+		}
+
+	      diff = xmemcoll (copy_a, new_len_a, copy_b, new_len_b);
+	    }
+	  else if (lena == 0)
+	    diff = - NONZERO (lenb);
+	  else if (lenb == 0)
+	    goto greater;
+	  else
+	    diff = xmemcoll (texta, lena, textb, lenb);
+	}
       else if (ignore)
-        {
+	{
 #define CMP_WITH_IGNORE(A, B)						\
   do									\
     {									\
-          while (true)							\
-            {								\
-              while (texta < lima && ignore[to_uchar (*texta)])		\
-                ++texta;						\
-              while (textb < limb && ignore[to_uchar (*textb)])		\
-                ++textb;						\
-              if (! (texta < lima && textb < limb))			\
-                break;							\
-              diff = to_uchar (A) - to_uchar (B);			\
-              if (diff)							\
-                goto not_equal;						\
-              ++texta;							\
-              ++textb;							\
-            }								\
-                                                                        \
-          diff = (texta < lima) - (textb < limb);			\
+	  for (;;)							\
+	    {								\
+	      while (texta < lima && ignore[UCHAR (*texta)])		\
+		++texta;						\
+	      while (textb < limb && ignore[UCHAR (*textb)])		\
+		++textb;						\
+	      if (! (texta < lima && textb < limb))			\
+		break;							\
+	      diff = UCHAR (A) - UCHAR (B);				\
+	      if (diff)							\
+		goto not_equal;						\
+	      ++texta;							\
+	      ++textb;							\
+	    }								\
+									\
+	  diff = (texta < lima) - (textb < limb);			\
     }									\
   while (0)
 
-          if (translate)
-            CMP_WITH_IGNORE (translate[to_uchar (*texta)],
-                             translate[to_uchar (*textb)]);
-          else
-            CMP_WITH_IGNORE (*texta, *textb);
-        }
+	  if (translate)
+	    CMP_WITH_IGNORE (translate[UCHAR (*texta)],
+			     translate[UCHAR (*textb)]);
+	  else
+	    CMP_WITH_IGNORE (*texta, *textb);
+	}
       else if (lena == 0)
-        diff = - NONZERO (lenb);
+	diff = - NONZERO (lenb);
       else if (lenb == 0)
-        goto greater;
+	goto greater;
       else
-        {
-          if (translate)
-            {
-              while (texta < lima && textb < limb)
-                {
-                  diff = (to_uchar (translate[to_uchar (*texta++)])
-                          - to_uchar (translate[to_uchar (*textb++)]));
-                  if (diff)
-                    goto not_equal;
-                }
-            }
-          else
-            {
-              diff = memcmp (texta, textb, MIN (lena, lenb));
-              if (diff)
-                goto not_equal;
-            }
-          diff = lena < lenb ? -1 : lena != lenb;
-        }
+	{
+	  if (translate)
+	    {
+	      while (texta < lima && textb < limb)
+		{
+		  diff = (UCHAR (translate[UCHAR (*texta++)])
+			  - UCHAR (translate[UCHAR (*textb++)]));
+		  if (diff)
+		    goto not_equal;
+		}
+	    }
+	  else
+	    {
+	      diff = memcmp (texta, textb, MIN (lena, lenb));
+	      if (diff)
+		goto not_equal;
+	    }
+	  diff = lena < lenb ? -1 : lena != lenb;
+	}
 
       if (diff)
-        goto not_equal;
+	goto not_equal;
 
       key = key->next;
       if (! key)
-        break;
+	break;
 
       /* Find the beginning and limit of the next field.  */
       if (key->eword != SIZE_MAX)
-        lima = limfield (a, key), limb = limfield (b, key);
+	lima = limfield (a, key), limb = limfield (b, key);
       else
-        lima = a->text + a->length - 1, limb = b->text + b->length - 1;
+	lima = a->text + a->length - 1, limb = b->text + b->length - 1;
 
       if (key->sword != SIZE_MAX)
-        texta = begfield (a, key), textb = begfield (b, key);
+	texta = begfield (a, key), textb = begfield (b, key);
       else
-        {
-          texta = a->text, textb = b->text;
-          if (key->skipsblanks)
-            {
-              while (texta < lima && blanks[to_uchar (*texta)])
-                ++texta;
-              while (textb < limb && blanks[to_uchar (*textb)])
-                ++textb;
-            }
-        }
+	{
+	  texta = a->text, textb = b->text;
+	  if (key->skipsblanks)
+	    {
+	      while (texta < lima && blanks[UCHAR (*texta)])
+		++texta;
+	      while (textb < limb && blanks[UCHAR (*textb)])
+		++textb;
+	    }
+	}
     }
 
   return 0;
 
  greater:
   diff = 1;
@@ -2716,263 +1530,181 @@ keycompare (struct line const *a, struct line const *b)
 }
 
 /* Compare two lines A and B, returning negative, zero, or positive
    depending on whether A compares less than, equal to, or greater than B. */
 
 static int
-compare (struct line const *a, struct line const *b)
+compare (register const struct line *a, register const struct line *b)
 {
   int diff;
   size_t alen, blen;
 
   /* First try to compare on the specified keys (if any).
      The only two cases with no key at all are unadorned sort,
      and unadorned sort -r. */
   if (keylist)
     {
       diff = keycompare (a, b);
-      if (diff || unique || stable)
-        return diff;
+      alloca (0);
+      if (diff | unique | stable)
+	return diff;
     }
 
   /* If the keys all compare equal (or no keys were specified)
      fall through to the default comparison.  */
   alen = a->length - 1, blen = b->length - 1;
 
   if (alen == 0)
     diff = - NONZERO (blen);
   else if (blen == 0)
     diff = 1;
-  else if (hard_LC_COLLATE)
-    {
-      /* Note xmemcoll0 is a performance enhancement as
-         it will not unconditionally write '\0' after the
-         passed in buffers, which was seen to give around
-         a 3% increase in performance for short lines.  */
-      diff = xmemcoll0 (a->text, alen + 1, b->text, blen + 1);
-    }
+  else if (HAVE_SETLOCALE && hard_LC_COLLATE)
+    diff = xmemcoll (a->text, alen, b->text, blen);
   else if (! (diff = memcmp (a->text, b->text, MIN (alen, blen))))
     diff = alen < blen ? -1 : alen != blen;
 
   return reverse ? -diff : diff;
 }
 
-/* Write LINE to output stream FP; the output file's name is
-   OUTPUT_FILE if OUTPUT_FILE is non-null, and is the standard output
-   otherwise.  If debugging is enabled and FP is standard output,
-   append some debugging information.  */
-
-static void
-write_line (struct line const *line, FILE *fp, char const *output_file)
-{
-  char *buf = line->text;
-  size_t n_bytes = line->length;
-  char *ebuf = buf + n_bytes;
-
-  if (!output_file && debug)
-    {
-      /* Convert TAB to '>' and EOL to \n, and then output debugging info.  */
-      char const *c = buf;
-
-      while (c < ebuf)
-        {
-          char wc = *c++;
-          if (wc == '\t')
-            wc = '>';
-          else if (c == ebuf)
-            wc = '\n';
-          if (fputc (wc, fp) == EOF)
-            sort_die (_("write failed"), output_file);
-        }
-
-      debug_line (line);
-    }
-  else
-    {
-      ebuf[-1] = eolchar;
-      if (fwrite (buf, 1, n_bytes, fp) != n_bytes)
-        sort_die (_("write failed"), output_file);
-      ebuf[-1] = '\0';
-    }
-}
-
-/* Check that the lines read from FILE_NAME come in order.  Return
-   true if they are in order.  If CHECKONLY == 'c', also print a
-   diagnostic (FILE_NAME, line number, contents of line) to stderr if
-   they are not in order.  */
+/* Check that the lines read from FILE_NAME come in order.  Print a
+   diagnostic (FILE_NAME, line number, contents of line) to stderr and return
+   false if they are not in order.  Otherwise, print no diagnostic
+   and return true.  */
 
 static bool
-check (char const *file_name, char checkonly)
+check (char const *file_name)
 {
   FILE *fp = xfopen (file_name, "r");
   struct buffer buf;		/* Input buffer. */
   struct line temp;		/* Copy of previous line. */
   size_t alloc = 0;
   uintmax_t line_number = 0;
   struct keyfield const *key = keylist;
   bool nonunique = ! unique;
   bool ordered = true;
 
   initbuf (&buf, sizeof (struct line),
-           MAX (merge_buffer_size, sort_size));
+	   MAX (merge_buffer_size, sort_size));
   temp.text = NULL;
 
   while (fillbuf (&buf, fp, file_name))
     {
       struct line const *line = buffer_linelim (&buf);
       struct line const *linebase = line - buf.nlines;
 
       /* Make sure the line saved from the old buffer contents is
-         less than or equal to the first line of the new buffer. */
+	 less than or equal to the first line of the new buffer. */
       if (alloc && nonunique <= compare (&temp, line - 1))
-        {
-        found_disorder:
-          {
-            if (checkonly == 'c')
-              {
-                struct line const *disorder_line = line - 1;
-                uintmax_t disorder_line_number =
-                  buffer_linelim (&buf) - disorder_line + line_number;
-                char hr_buf[INT_BUFSIZE_BOUND (disorder_line_number)];
-                fprintf (stderr, _("%s: %s:%s: disorder: "),
-                         program_name, file_name,
-                         umaxtostr (disorder_line_number, hr_buf));
-                write_line (disorder_line, stderr, _("standard error"));
-              }
-
-            ordered = false;
-            break;
-          }
-        }
+	{
+	found_disorder:
+	  {
+	    struct line const *disorder_line = line - 1;
+	    uintmax_t disorder_line_number =
+	      buffer_linelim (&buf) - disorder_line + line_number;
+	    char hr_buf[INT_BUFSIZE_BOUND (uintmax_t)];
+	    fprintf (stderr, _("%s: %s:%s: disorder: "),
+		     program_name, file_name,
+		     umaxtostr (disorder_line_number, hr_buf));
+	    write_bytes (disorder_line->text, disorder_line->length, stderr,
+			 _("standard error"));
+	    ordered = false;
+	    break;
+	  }
+	}
 
       /* Compare each line in the buffer with its successor.  */
       while (linebase < --line)
-        if (nonunique <= compare (line, line - 1))
-          goto found_disorder;
+	if (nonunique <= compare (line, line - 1))
+	  goto found_disorder;
 
       line_number += buf.nlines;
 
       /* Save the last line of the buffer.  */
       if (alloc < line->length)
-        {
-          do
-            {
-              alloc *= 2;
-              if (! alloc)
-                {
-                  alloc = line->length;
-                  break;
-                }
-            }
-          while (alloc < line->length);
-
-          free (temp.text);
-          temp.text = xmalloc (alloc);
-        }
+	{
+	  do
+	    {
+	      alloc *= 2;
+	      if (! alloc)
+		{
+		  alloc = line->length;
+		  break;
+		}
+	    }
+	  while (alloc < line->length);
+
+	  temp.text = xrealloc (temp.text, alloc);
+	}
       memcpy (temp.text, line->text, line->length);
       temp.length = line->length;
       if (key)
-        {
-          temp.keybeg = temp.text + (line->keybeg - line->text);
-          temp.keylim = temp.text + (line->keylim - line->text);
-        }
+	{
+	  temp.keybeg = temp.text + (line->keybeg - line->text);
+	  temp.keylim = temp.text + (line->keylim - line->text);
+	}
     }
 
   xfclose (fp, file_name);
   free (buf.buf);
-  free (temp.text);
+  if (temp.text)
+    free (temp.text);
   return ordered;
 }
 
-/* Open FILES (there are NFILES of them) and store the resulting array
-   of stream pointers into (*PFPS).  Allocate the array.  Return the
-   number of successfully opened files, setting errno if this value is
-   less than NFILES.  */
-
-static size_t
-open_input_files (struct sortfile *files, size_t nfiles, FILE ***pfps)
-{
-  FILE **fps = *pfps = xnmalloc (nfiles, sizeof *fps);
-  int i;
-
-  /* Open as many input files as we can.  */
-  for (i = 0; i < nfiles; i++)
-    {
-      fps[i] = (files[i].temp && files[i].temp->state != UNCOMPRESSED
-                ? open_temp (files[i].temp)
-                : stream_open (files[i].name, "r"));
-      if (!fps[i])
-        break;
-    }
-
-  return i;
-}
-
-/* Merge lines from FILES onto OFP.  NTEMPS is the number of temporary
-   files (all of which are at the start of the FILES array), and
-   NFILES is the number of files; 0 <= NTEMPS <= NFILES <= NMERGE.
-   FPS is the vector of open stream corresponding to the files.
-   Close input and output streams before returning.
-   OUTPUT_FILE gives the name of the output file.  If it is NULL,
-   the output file is standard output.  */
+/* Merge lines from FILES onto OFP.  NFILES cannot be greater than
+   NMERGE.  Close input and output files before returning.
+   OUTPUT_FILE gives the name of the output file; if OFP is NULL, the
+   output file has not been opened yet.  */
 
 static void
-mergefps (struct sortfile *files, size_t ntemps, size_t nfiles,
-          FILE *ofp, char const *output_file, FILE **fps)
+mergefps (char **files, register int nfiles,
+	  FILE *ofp, const char *output_file)
 {
-  struct buffer *buffer = xnmalloc (nfiles, sizeof *buffer);
-                                /* Input buffers for each file. */
+  FILE *fps[NMERGE];		/* Input streams for each file.  */
+  struct buffer buffer[NMERGE];	/* Input buffers for each file. */
   struct line saved;		/* Saved line storage for unique check. */
   struct line const *savedline = NULL;
-                                /* &saved if there is a saved line. */
+				/* &saved if there is a saved line. */
   size_t savealloc = 0;		/* Size allocated for the saved line. */
-  struct line const **cur = xnmalloc (nfiles, sizeof *cur);
-                                /* Current line in each line table. */
-  struct line const **base = xnmalloc (nfiles, sizeof *base);
-                                /* Base of each line table.  */
-  size_t *ord = xnmalloc (nfiles, sizeof *ord);
-                                /* Table representing a permutation of fps,
-                                   such that cur[ord[0]] is the smallest line
-                                   and will be next output. */
-  size_t i;
-  size_t j;
-  size_t t;
+  struct line const *cur[NMERGE]; /* Current line in each line table. */
+  struct line const *base[NMERGE]; /* Base of each line table.  */
+  int ord[NMERGE];		/* Table representing a permutation of fps,
+				   such that cur[ord[0]] is the smallest line
+				   and will be next output. */
+  register int i, j, t;
   struct keyfield const *key = keylist;
   saved.text = NULL;
 
   /* Read initial lines from each input file. */
   for (i = 0; i < nfiles; )
     {
+      fps[i] = xfopen (files[i], "r");
       initbuf (&buffer[i], sizeof (struct line),
-               MAX (merge_buffer_size, sort_size / nfiles));
-      if (fillbuf (&buffer[i], fps[i], files[i].name))
-        {
-          struct line const *linelim = buffer_linelim (&buffer[i]);
-          cur[i] = linelim - 1;
-          base[i] = linelim - buffer[i].nlines;
-          i++;
-        }
+	       MAX (merge_buffer_size, sort_size / nfiles));
+      if (fillbuf (&buffer[i], fps[i], files[i]))
+	{
+	  struct line const *linelim = buffer_linelim (&buffer[i]);
+	  cur[i] = linelim - 1;
+	  base[i] = linelim - buffer[i].nlines;
+	  i++;
+	}
       else
-        {
-          /* fps[i] is empty; eliminate it from future consideration.  */
-          xfclose (fps[i], files[i].name);
-          if (i < ntemps)
-            {
-              ntemps--;
-              zaptemp (files[i].name);
-            }
-          free (buffer[i].buf);
-          --nfiles;
-          for (j = i; j < nfiles; ++j)
-            {
-              files[j] = files[j + 1];
-              fps[j] = fps[j + 1];
-            }
-        }
+	{
+	  /* fps[i] is empty; eliminate it from future consideration.  */
+	  xfclose (fps[i], files[i]);
+	  zaptemp (files[i]);
+	  free (buffer[i].buf);
+	  --nfiles;
+	  for (j = i; j < nfiles; ++j)
+	    files[j] = files[j + 1];
+	}
     }
 
+  if (! ofp)
+    ofp = xfopen (output_file, "w");
+
   /* Set up the ord table according to comparisons among input lines.
      Since this only reorders two items if one is strictly greater than
      the other, it is stable. */
   for (i = 0; i < nfiles; ++i)
     ord[i] = i;
   for (i = 1; i < nfiles; ++i)
@@ -2982,1047 +1714,384 @@ mergefps (struct sortfile *files, size_t ntemps, size_t nfiles,
   /* Repeatedly output the smallest line until no input remains. */
   while (nfiles)
     {
       struct line const *smallest = cur[ord[0]];
 
       /* If uniquified output is turned on, output only the first of
-         an identical series of lines. */
+	 an identical series of lines. */
       if (unique)
-        {
-          if (savedline && compare (savedline, smallest))
-            {
-              savedline = NULL;
-              write_line (&saved, ofp, output_file);
-            }
-          if (!savedline)
-            {
-              savedline = &saved;
-              if (savealloc < smallest->length)
-                {
-                  do
-                    if (! savealloc)
-                      {
-                        savealloc = smallest->length;
-                        break;
-                      }
-                  while ((savealloc *= 2) < smallest->length);
-
-                  free (saved.text);
-                  saved.text = xmalloc (savealloc);
-                }
-              saved.length = smallest->length;
-              memcpy (saved.text, smallest->text, saved.length);
-              if (key)
-                {
-                  saved.keybeg =
-                    saved.text + (smallest->keybeg - smallest->text);
-                  saved.keylim =
-                    saved.text + (smallest->keylim - smallest->text);
-                }
-            }
-        }
+	{
+	  if (savedline && compare (savedline, smallest))
+	    {
+	      savedline = 0;
+	      write_bytes (saved.text, saved.length, ofp, output_file);
+	    }
+	  if (!savedline)
+	    {
+	      savedline = &saved;
+	      if (savealloc < smallest->length)
+		{
+		  do
+		    if (! savealloc)
+		      {
+			savealloc = smallest->length;
+			break;
+		      }
+		  while ((savealloc *= 2) < smallest->length);
+
+		  saved.text = xrealloc (saved.text, savealloc);
+		}
+	      saved.length = smallest->length;
+	      memcpy (saved.text, smallest->text, saved.length);
+	      if (key)
+		{
+		  saved.keybeg =
+		    saved.text + (smallest->keybeg - smallest->text);
+		  saved.keylim =
+		    saved.text + (smallest->keylim - smallest->text);
+		}
+	    }
+	}
       else
-        write_line (smallest, ofp, output_file);
+	write_bytes (smallest->text, smallest->length, ofp, output_file);
 
       /* Check if we need to read more lines into core. */
       if (base[ord[0]] < smallest)
-        cur[ord[0]] = smallest - 1;
+	cur[ord[0]] = smallest - 1;
       else
-        {
-          if (fillbuf (&buffer[ord[0]], fps[ord[0]], files[ord[0]].name))
-            {
-              struct line const *linelim = buffer_linelim (&buffer[ord[0]]);
-              cur[ord[0]] = linelim - 1;
-              base[ord[0]] = linelim - buffer[ord[0]].nlines;
-            }
-          else
-            {
-              /* We reached EOF on fps[ord[0]].  */
-              for (i = 1; i < nfiles; ++i)
-                if (ord[i] > ord[0])
-                  --ord[i];
-              --nfiles;
-              xfclose (fps[ord[0]], files[ord[0]].name);
-              if (ord[0] < ntemps)
-                {
-                  ntemps--;
-                  zaptemp (files[ord[0]].name);
-                }
-              free (buffer[ord[0]].buf);
-              for (i = ord[0]; i < nfiles; ++i)
-                {
-                  fps[i] = fps[i + 1];
-                  files[i] = files[i + 1];
-                  buffer[i] = buffer[i + 1];
-                  cur[i] = cur[i + 1];
-                  base[i] = base[i + 1];
-                }
-              for (i = 0; i < nfiles; ++i)
-                ord[i] = ord[i + 1];
-              continue;
-            }
-        }
+	{
+	  if (fillbuf (&buffer[ord[0]], fps[ord[0]], files[ord[0]]))
+	    {
+	      struct line const *linelim = buffer_linelim (&buffer[ord[0]]);
+	      cur[ord[0]] = linelim - 1;
+	      base[ord[0]] = linelim - buffer[ord[0]].nlines;
+	    }
+	  else
+	    {
+	      /* We reached EOF on fps[ord[0]]. */
+	      for (i = 1; i < nfiles; ++i)
+		if (ord[i] > ord[0])
+		  --ord[i];
+	      --nfiles;
+	      xfclose (fps[ord[0]], files[ord[0]]);
+	      zaptemp (files[ord[0]]);
+	      free (buffer[ord[0]].buf);
+	      for (i = ord[0]; i < nfiles; ++i)
+		{
+		  fps[i] = fps[i + 1];
+		  files[i] = files[i + 1];
+		  buffer[i] = buffer[i + 1];
+		  cur[i] = cur[i + 1];
+		  base[i] = base[i + 1];
+		}
+	      for (i = 0; i < nfiles; ++i)
+		ord[i] = ord[i + 1];
+	      continue;
+	    }
+	}
 
       /* The new line just read in may be larger than other lines
-         already in main memory; push it back in the queue until we
-         encounter a line larger than it.  Optimize for the common
-         case where the new line is smallest.  */
-      {
-        size_t lo = 1;
-        size_t hi = nfiles;
-        size_t probe = lo;
-        size_t ord0 = ord[0];
-        size_t count_of_smaller_lines;
-
-        while (lo < hi)
-          {
-            int cmp = compare (cur[ord0], cur[ord[probe]]);
-            if (cmp < 0 || (cmp == 0 && ord0 < ord[probe]))
-              hi = probe;
-            else
-              lo = probe + 1;
-            probe = (lo + hi) / 2;
-          }
-
-        count_of_smaller_lines = lo - 1;
-        for (j = 0; j < count_of_smaller_lines; j++)
-          ord[j] = ord[j + 1];
-        ord[count_of_smaller_lines] = ord0;
-      }
+	 already in core; push it back in the queue until we encounter
+	 a line larger than it. */
+      for (i = 1; i < nfiles; ++i)
+	{
+	  t = compare (cur[ord[0]], cur[ord[i]]);
+	  if (!t)
+	    t = ord[0] - ord[i];
+	  if (t < 0)
+	    break;
+	}
+      t = ord[0];
+      for (j = 1; j < i; ++j)
+	ord[j - 1] = ord[j];
+      ord[i - 1] = t;
     }
 
   if (unique && savedline)
     {
-      write_line (&saved, ofp, output_file);
+      write_bytes (saved.text, saved.length, ofp, output_file);
       free (saved.text);
     }
 
   xfclose (ofp, output_file);
-  free (fps);
-  free (buffer);
-  free (ord);
-  free (base);
-  free (cur);
-}
-
-/* Merge lines from FILES onto OFP.  NTEMPS is the number of temporary
-   files (all of which are at the start of the FILES array), and
-   NFILES is the number of files; 0 <= NTEMPS <= NFILES <= NMERGE.
-   Close input and output files before returning.
-   OUTPUT_FILE gives the name of the output file.
-
-   Return the number of files successfully merged.  This number can be
-   less than NFILES if we ran low on file descriptors, but in this
-   case it is never less than 2.  */
-
-static size_t
-mergefiles (struct sortfile *files, size_t ntemps, size_t nfiles,
-            FILE *ofp, char const *output_file)
-{
-  FILE **fps;
-  size_t nopened = open_input_files (files, nfiles, &fps);
-  if (nopened < nfiles && nopened < 2)
-    sort_die (_("open failed"), files[nopened].name);
-  mergefps (files, ntemps, nopened, ofp, output_file, fps);
-  return nopened;
 }
 
-/* Merge into T (of size NLINES) the two sorted arrays of lines
-   LO (with NLINES / 2 members), and
-   T - (NLINES / 2) (with NLINES - NLINES / 2 members).
-   T and LO point just past their respective arrays, and the arrays
-   are in reverse order.  NLINES must be at least 2.  */
+/* Merge into T the two sorted arrays of lines LO (with NLO members)
+   and HI (with NHI members).  T, LO, and HI point just past their
+   respective arrays, and the arrays are in reverse order.  NLO and
+   NHI must be positive, and HI - NHI must equal T - (NLO + NHI).  */
 
-static void
-mergelines (struct line *restrict t, size_t nlines,
-            struct line const *restrict lo)
+static inline void
+mergelines (struct line *t,
+	    struct line const *lo, size_t nlo,
+	    struct line const *hi, size_t nhi)
 {
-  size_t nlo = nlines / 2;
-  size_t nhi = nlines - nlo;
-  struct line *hi = t - nlo;
-
-  while (true)
+  for (;;)
     if (compare (lo - 1, hi - 1) <= 0)
       {
-        *--t = *--lo;
-        if (! --nlo)
-          {
-            /* HI must equal T now, and there is no need to copy from
-               HI to T. */
-            return;
-          }
+	*--t = *--lo;
+	if (! --nlo)
+	  {
+	    /* HI - NHI equalled T - (NLO + NHI) when this function
+	       began.  Therefore HI must equal T now, and there is no
+	       need to copy from HI to T.  */
+	    return;
+	  }
       }
     else
       {
-        *--t = *--hi;
-        if (! --nhi)
-          {
-            do
-              *--t = *--lo;
-            while (--nlo);
-
-            return;
-          }
+	*--t = *--hi;
+	if (! --nhi)
+	  {
+	    do
+	      *--t = *--lo;
+	    while (--nlo);
+
+	    return;
+	  }
       }
 }
 
 /* Sort the array LINES with NLINES members, using TEMP for temporary space.
-   Do this all within one thread.  NLINES must be at least 2.
-   If TO_TEMP, put the sorted output into TEMP, and TEMP is as large as LINES.
-   Otherwise the sort is in-place and TEMP is half-sized.
+   NLINES must be at least 2.
    The input and output arrays are in reverse order, and LINES and
    TEMP point just past the end of their respective arrays.
 
    Use a recursive divide-and-conquer algorithm, in the style
    suggested by Knuth volume 3 (2nd edition), exercise 5.2.4-23.  Use
    the optimization suggested by exercise 5.2.4-10; this requires room
    for only 1.5*N lines, rather than the usual 2*N lines.  Knuth
    writes that this memory optimization was originally published by
    D. A. Bell, Comp J. 1 (1958), 75.  */
 
 static void
-sequential_sort (struct line *restrict lines, size_t nlines,
-                 struct line *restrict temp, bool to_temp)
+sortlines (struct line *lines, size_t nlines, struct line *temp)
 {
   if (nlines == 2)
     {
-      /* Declare 'swap' as int, not bool, to work around a bug
-         <http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html>
-         in the IBM xlc 6.0.0.0 compiler in 64-bit mode.  */
-      int swap = (0 < compare (&lines[-1], &lines[-2]));
-      if (to_temp)
-        {
-          temp[-1] = lines[-1 - swap];
-          temp[-2] = lines[-2 + swap];
-        }
-      else if (swap)
-        {
-          temp[-1] = lines[-1];
-          lines[-1] = lines[-2];
-          lines[-2] = temp[-1];
-        }
+      if (0 < compare (&lines[-1], &lines[-2]))
+	{
+	  struct line tmp = lines[-1];
+	  lines[-1] = lines[-2];
+	  lines[-2] = tmp;
+	}
     }
   else
     {
       size_t nlo = nlines / 2;
       size_t nhi = nlines - nlo;
       struct line *lo = lines;
       struct line *hi = lines - nlo;
+      struct line *sorted_lo = temp;
 
-      sequential_sort (hi, nhi, temp - (to_temp ? nlo : 0), to_temp);
+      sortlines (hi, nhi, temp);
       if (1 < nlo)
-        sequential_sort (lo, nlo, temp, !to_temp);
-      else if (!to_temp)
-        temp[-1] = lo[-1];
-
-      struct line *dest;
-      struct line const *sorted_lo;
-      if (to_temp)
-        {
-          dest = temp;
-          sorted_lo = lines;
-        }
+	sortlines_temp (lo, nlo, sorted_lo);
       else
-        {
-          dest = lines;
-          sorted_lo = temp;
-        }
-      mergelines (dest, nlines, sorted_lo);
-    }
-}
-
-static struct merge_node *init_node (struct merge_node *restrict,
-                                     struct merge_node *restrict,
-                                     struct line *, size_t, size_t, bool);
+	sorted_lo[-1] = lo[-1];
 
-
-/* Create and return a merge tree for NTHREADS threads, sorting NLINES
-   lines, with destination DEST.  */
-static struct merge_node *
-merge_tree_init (size_t nthreads, size_t nlines, struct line *dest)
-{
-  struct merge_node *merge_tree = xmalloc (2 * sizeof *merge_tree * nthreads);
-
-  struct merge_node *root = merge_tree;
-  root->lo = root->hi = root->end_lo = root->end_hi = NULL;
-  root->dest = NULL;
-  root->nlo = root->nhi = nlines;
-  root->parent = NULL;
-  root->level = MERGE_END;
-  root->queued = false;
-  pthread_mutex_init (&root->lock, NULL);
-
-  init_node (root, root + 1, dest, nthreads, nlines, false);
-  return merge_tree;
-}
-
-/* Destroy the merge tree. */
-static void
-merge_tree_destroy (size_t nthreads, struct merge_node *merge_tree)
-{
-  size_t n_nodes = nthreads * 2;
-  struct merge_node *node = merge_tree;
-
-  while (n_nodes--)
-    {
-      pthread_mutex_destroy (&node->lock);
-      node++;
-    }
-
-  free (merge_tree);
-}
-
-/* Initialize a merge tree node and its descendants.  The node's
-   parent is PARENT.  The node and its descendants are taken from the
-   array of nodes NODE_POOL.  Their destination starts at DEST; they
-   will consume NTHREADS threads.  The total number of sort lines is
-   TOTAL_LINES.  IS_LO_CHILD is true if the node is the low child of
-   its parent.  */
-
-static struct merge_node *
-init_node (struct merge_node *restrict parent,
-           struct merge_node *restrict node_pool,
-           struct line *dest, size_t nthreads,
-           size_t total_lines, bool is_lo_child)
-{
-  size_t nlines = (is_lo_child ? parent->nlo : parent->nhi);
-  size_t nlo = nlines / 2;
-  size_t nhi = nlines - nlo;
-  struct line *lo = dest - total_lines;
-  struct line *hi = lo - nlo;
-  struct line **parent_end = (is_lo_child ? &parent->end_lo : &parent->end_hi);
-
-  struct merge_node *node = node_pool++;
-  node->lo = node->end_lo = lo;
-  node->hi = node->end_hi = hi;
-  node->dest = parent_end;
-  node->nlo = nlo;
-  node->nhi = nhi;
-  node->parent = parent;
-  node->level = parent->level + 1;
-  node->queued = false;
-  pthread_mutex_init (&node->lock, NULL);
-
-  if (nthreads > 1)
-    {
-      size_t lo_threads = nthreads / 2;
-      size_t hi_threads = nthreads - lo_threads;
-      node->lo_child = node_pool;
-      node_pool = init_node (node, node_pool, lo, lo_threads,
-                             total_lines, true);
-      node->hi_child = node_pool;
-      node_pool = init_node (node, node_pool, hi, hi_threads,
-                             total_lines, false);
-    }
-  else
-    {
-      node->lo_child = NULL;
-      node->hi_child = NULL;
-    }
-  return node_pool;
-}
-
-
-/* Compare two merge nodes A and B for priority.  */
-
-static int
-compare_nodes (void const *a, void const *b)
-{
-  struct merge_node const *nodea = a;
-  struct merge_node const *nodeb = b;
-  if (nodea->level == nodeb->level)
-      return (nodea->nlo + nodea->nhi) < (nodeb->nlo + nodeb->nhi);
-  return nodea->level < nodeb->level;
-}
-
-/* Lock a merge tree NODE.  */
-
-static inline void
-lock_node (struct merge_node *node)
-{
-  pthread_mutex_lock (&node->lock);
-}
-
-/* Unlock a merge tree NODE. */
-
-static inline void
-unlock_node (struct merge_node *node)
-{
-  pthread_mutex_unlock (&node->lock);
-}
-
-/* Destroy merge QUEUE. */
-
-static void
-queue_destroy (struct merge_node_queue *queue)
-{
-  heap_free (queue->priority_queue);
-  pthread_cond_destroy (&queue->cond);
-  pthread_mutex_destroy (&queue->mutex);
-}
-
-/* Initialize merge QUEUE, allocating space suitable for a maximum of
-   NTHREADS threads.  */
-
-static void
-queue_init (struct merge_node_queue *queue, size_t nthreads)
-{
-  /* Though it's highly unlikely all nodes are in the heap at the same
-     time, the heap should accommodate all of them.  Counting a NULL
-     dummy head for the heap, reserve 2 * NTHREADS nodes.  */
-  queue->priority_queue = heap_alloc (compare_nodes, 2 * nthreads);
-  pthread_mutex_init (&queue->mutex, NULL);
-  pthread_cond_init (&queue->cond, NULL);
-}
-
-/* Insert NODE into QUEUE.  The caller either holds a lock on NODE, or
-   does not need to lock NODE.  */
-
-static void
-queue_insert (struct merge_node_queue *queue, struct merge_node *node)
-{
-  pthread_mutex_lock (&queue->mutex);
-  heap_insert (queue->priority_queue, node);
-  node->queued = true;
-  pthread_cond_signal (&queue->cond);
-  pthread_mutex_unlock (&queue->mutex);
-}
-
-/* Pop the top node off the priority QUEUE, lock the node, return it.  */
-
-static struct merge_node *
-queue_pop (struct merge_node_queue *queue)
-{
-  struct merge_node *node;
-  pthread_mutex_lock (&queue->mutex);
-  while (! (node = heap_remove_top (queue->priority_queue)))
-    pthread_cond_wait (&queue->cond, &queue->mutex);
-  pthread_mutex_unlock (&queue->mutex);
-  lock_node (node);
-  node->queued = false;
-  return node;
-}
-
-/* Output LINE to TFP, unless -u is specified and the line compares
-   equal to the previous line.  TEMP_OUTPUT is the name of TFP, or
-   is null if TFP is standard output.
-
-   This function does not save the line for comparison later, so it is
-   appropriate only for internal sort.  */
-
-static void
-write_unique (struct line const *line, FILE *tfp, char const *temp_output)
-{
-  if (unique)
-    {
-      if (saved_line.text && ! compare (line, &saved_line))
-        return;
-      saved_line = *line;
+      mergelines (lines, sorted_lo, nlo, hi, nhi);
     }
-
-  write_line (line, tfp, temp_output);
 }
 
-/* Merge the lines currently available to a NODE in the binary
-   merge tree.  Merge a number of lines appropriate for this merge
-   level, assuming TOTAL_LINES is the total number of lines.
-
-   If merging at the top level, send output to TFP.  TEMP_OUTPUT is
-   the name of TFP, or is null if TFP is standard output.  */
+/* Like sortlines (LINES, NLINES, TEMP), except output into TEMP
+   rather than sorting in place.  */
 
 static void
-mergelines_node (struct merge_node *restrict node, size_t total_lines,
-                 FILE *tfp, char const *temp_output)
+sortlines_temp (struct line *lines, size_t nlines, struct line *temp)
 {
-  struct line *lo_orig = node->lo;
-  struct line *hi_orig = node->hi;
-  size_t to_merge = MAX_MERGE (total_lines, node->level);
-  size_t merged_lo;
-  size_t merged_hi;
-
-  if (node->level > MERGE_ROOT)
+  if (nlines == 2)
     {
-      /* Merge to destination buffer. */
-      struct line *dest = *node->dest;
-      while (node->lo != node->end_lo && node->hi != node->end_hi && to_merge--)
-        if (compare (node->lo - 1, node->hi - 1) <= 0)
-          *--dest = *--node->lo;
-        else
-          *--dest = *--node->hi;
-
-      merged_lo = lo_orig - node->lo;
-      merged_hi = hi_orig - node->hi;
-
-      if (node->nhi == merged_hi)
-        while (node->lo != node->end_lo && to_merge--)
-          *--dest = *--node->lo;
-      else if (node->nlo == merged_lo)
-        while (node->hi != node->end_hi && to_merge--)
-          *--dest = *--node->hi;
-      *node->dest = dest;
+      bool swap = (0 < compare (&lines[-1], &lines[-2]));
+      temp[-1] = lines[-1 - swap];
+      temp[-2] = lines[-2 + swap];
     }
   else
     {
-      /* Merge directly to output. */
-      while (node->lo != node->end_lo && node->hi != node->end_hi && to_merge--)
-        {
-          if (compare (node->lo - 1, node->hi - 1) <= 0)
-            write_unique (--node->lo, tfp, temp_output);
-          else
-            write_unique (--node->hi, tfp, temp_output);
-        }
-
-      merged_lo = lo_orig - node->lo;
-      merged_hi = hi_orig - node->hi;
-
-      if (node->nhi == merged_hi)
-        {
-          while (node->lo != node->end_lo && to_merge--)
-            write_unique (--node->lo, tfp, temp_output);
-        }
-      else if (node->nlo == merged_lo)
-        {
-          while (node->hi != node->end_hi && to_merge--)
-            write_unique (--node->hi, tfp, temp_output);
-        }
-    }
-
-  /* Update NODE. */
-  merged_lo = lo_orig - node->lo;
-  merged_hi = hi_orig - node->hi;
-  node->nlo -= merged_lo;
-  node->nhi -= merged_hi;
-}
-
-/* Into QUEUE, insert NODE if it is not already queued, and if one of
-   NODE's children has available lines and the other either has
-   available lines or has exhausted its lines.  */
-
-static void
-queue_check_insert (struct merge_node_queue *queue, struct merge_node *node)
-{
-  if (! node->queued)
-    {
-      bool lo_avail = (node->lo - node->end_lo) != 0;
-      bool hi_avail = (node->hi - node->end_hi) != 0;
-      if (lo_avail ? hi_avail || ! node->nhi : hi_avail && ! node->nlo)
-        queue_insert (queue, node);
-    }
-}
-
-/* Into QUEUE, insert NODE's parent if the parent can now be worked on.  */
-
-static void
-queue_check_insert_parent (struct merge_node_queue *queue,
-                           struct merge_node *node)
-{
-  if (node->level > MERGE_ROOT)
-    {
-      lock_node (node->parent);
-      queue_check_insert (queue, node->parent);
-      unlock_node (node->parent);
-    }
-  else if (node->nlo + node->nhi == 0)
-    {
-      /* If the MERGE_ROOT NODE has finished merging, insert the
-         MERGE_END node.  */
-      queue_insert (queue, node->parent);
-    }
-}
-
-/* Repeatedly pop QUEUE for a node with lines to merge, and merge at least
-   some of those lines, until the MERGE_END node is popped.
-   TOTAL_LINES is the total number of lines.  If merging at the top
-   level, send output to TFP.  TEMP_OUTPUT is the name of TFP, or is
-   null if TFP is standard output.  */
-
-static void
-merge_loop (struct merge_node_queue *queue,
-            size_t total_lines, FILE *tfp, char const *temp_output)
-{
-  while (1)
-    {
-      struct merge_node *node = queue_pop (queue);
-
-      if (node->level == MERGE_END)
-        {
-          unlock_node (node);
-          /* Reinsert so other threads can pop it. */
-          queue_insert (queue, node);
-          break;
-        }
-      mergelines_node (node, total_lines, tfp, temp_output);
-      queue_check_insert (queue, node);
-      queue_check_insert_parent (queue, node);
-
-      unlock_node (node);
-    }
-}
-
-
-static void sortlines (struct line *restrict, size_t, size_t,
-                       struct merge_node *, struct merge_node_queue *,
-                       FILE *, char const *);
-
-/* Thread arguments for sortlines_thread. */
-
-struct thread_args
-{
-  /* Source, i.e., the array of lines to sort.  This points just past
-     the end of the array.  */
-  struct line *lines;
-
-  /* Number of threads to use.  If 0 or 1, sort single-threaded.  */
-  size_t nthreads;
-
-  /* Number of lines in LINES and DEST.  */
-  size_t const total_lines;
-
-  /* Merge node. Lines from this node and this node's sibling will merged
-     to this node's parent. */
-  struct merge_node *const node;
-
-  /* The priority queue controlling available work for the entire
-     internal sort.  */
-  struct merge_node_queue *const queue;
-
-  /* If at the top level, the file to output to, and the file's name.
-     If the file is standard output, the file's name is null.  */
-  FILE *tfp;
-  char const *output_temp;
-};
-
-/* Like sortlines, except with a signature acceptable to pthread_create.  */
-
-static void *
-sortlines_thread (void *data)
-{
-  struct thread_args const *args = data;
-  sortlines (args->lines, args->nthreads, args->total_lines,
-             args->node, args->queue, args->tfp,
-             args->output_temp);
-  return NULL;
-}
-
-/* Sort lines, possibly in parallel.  The arguments are as in struct
-   thread_args above.
-
-   The algorithm has three phases: node creation, sequential sort,
-   and binary merge.
-
-   During node creation, sortlines recursively visits each node in the
-   binary merge tree and creates a NODE structure corresponding to all the
-   future line merging NODE is responsible for. For each call to
-   sortlines, half the available threads are assigned to each recursive
-   call, until a leaf node having only 1 available thread is reached.
-
-   Each leaf node then performs two sequential sorts, one on each half of
-   the lines it is responsible for. It records in its NODE structure that
-   there are two sorted sublists available to merge from, and inserts its
-   NODE into the priority queue.
-
-   The binary merge phase then begins. Each thread drops into a loop
-   where the thread retrieves a NODE from the priority queue, merges lines
-   available to that NODE, and potentially insert NODE or its parent back
-   into the queue if there are sufficient available lines for them to
-   merge. This continues until all lines at all nodes of the merge tree
-   have been merged. */
-
-static void
-sortlines (struct line *restrict lines, size_t nthreads,
-           size_t total_lines, struct merge_node *node,
-           struct merge_node_queue *queue, FILE *tfp, char const *temp_output)
-{
-  size_t nlines = node->nlo + node->nhi;
-
-  /* Calculate thread arguments. */
-  size_t lo_threads = nthreads / 2;
-  size_t hi_threads = nthreads - lo_threads;
-  pthread_t thread;
-  struct thread_args args = {lines, lo_threads, total_lines,
-                             node->lo_child, queue, tfp, temp_output};
+      size_t nlo = nlines / 2;
+      size_t nhi = nlines - nlo;
+      struct line *lo = lines;
+      struct line *hi = lines - nlo;
+      struct line *sorted_hi = temp - nlo;
 
-  if (nthreads > 1 && SUBTHREAD_LINES_HEURISTIC <= nlines
-      && pthread_create (&thread, NULL, sortlines_thread, &args) == 0)
-    {
-      sortlines (lines - node->nlo, hi_threads, total_lines,
-                 node->hi_child, queue, tfp, temp_output);
-      pthread_join (thread, NULL);
-    }
-  else
-    {
-      /* Nthreads = 1, this is a leaf NODE, or pthread_create failed.
-         Sort with 1 thread. */
-      size_t nlo = node->nlo;
-      size_t nhi = node->nhi;
-      struct line *temp = lines - total_lines;
-      if (1 < nhi)
-        sequential_sort (lines - nlo, nhi, temp - nlo / 2, false);
+      sortlines_temp (hi, nhi, sorted_hi);
       if (1 < nlo)
-        sequential_sort (lines, nlo, temp, false);
+	sortlines (lo, nlo, temp);
 
-      /* Update merge NODE. No need to lock yet. */
-      node->lo = lines;
-      node->hi = lines - nlo;
-      node->end_lo = lines - nlo;
-      node->end_hi = lines - nlo - nhi;
-
-      queue_insert (queue, node);
-      merge_loop (queue, total_lines, tfp, temp_output);
+      mergelines (temp, lo, nlo, sorted_hi, nhi);
     }
 }
 
-/* Scan through FILES[NTEMPS .. NFILES-1] looking for files that are
-   the same as OUTFILE.  If found, replace each with the same
-   temporary copy that can be merged into OUTFILE without destroying
-   OUTFILE before it is completely read.  This temporary copy does not
-   count as a merge temp, so don't worry about incrementing NTEMPS in
-   the caller; final cleanup will remove it, not zaptemp.
-
-   This test ensures that an otherwise-erroneous use like
-   "sort -m -o FILE ... FILE ..." copies FILE before writing to it.
-   It's not clear that POSIX requires this nicety.
-   Detect common error cases, but don't try to catch obscure cases like
-   "cat ... FILE ... | sort -m -o FILE"
-   where traditional "sort" doesn't copy the input and where
-   people should know that they're getting into trouble anyway.
-   Catching these obscure cases would slow down performance in
-   common cases.  */
+/* Return the index of the first of NFILES FILES that is the same file
+   as OUTFILE.  If none can be the same, return NFILES.  Consider an
+   input pipe to be the same as OUTFILE, since the pipe might be the
+   output of a command like "cat OUTFILE".  */
 
-static void
-avoid_trashing_input (struct sortfile *files, size_t ntemps,
-                      size_t nfiles, char const *outfile)
+static int
+first_same_file (char * const *files, int nfiles, char const *outfile)
 {
-  size_t i;
+  int i;
   bool got_outstat = false;
-  struct stat outstat;
-  struct tempnode *tempcopy = NULL;
-
-  for (i = ntemps; i < nfiles; i++)
-    {
-      bool is_stdin = STREQ (files[i].name, "-");
-      bool same;
-      struct stat instat;
-
-      if (outfile && STREQ (outfile, files[i].name) && !is_stdin)
-        same = true;
-      else
-        {
-          if (! got_outstat)
-            {
-              if (fstat (STDOUT_FILENO, &outstat) != 0)
-                break;
-              got_outstat = true;
-            }
-
-          same = (((is_stdin
-                    ? fstat (STDIN_FILENO, &instat)
-                    : stat (files[i].name, &instat))
-                   == 0)
-                  && SAME_INODE (instat, outstat));
-        }
-
-      if (same)
-        {
-          if (! tempcopy)
-            {
-              FILE *tftp;
-              tempcopy = create_temp (&tftp);
-              mergefiles (&files[i], 0, 1, tftp, tempcopy->name);
-            }
-
-          files[i].name = tempcopy->name;
-          files[i].temp = tempcopy;
-        }
-    }
-}
-
-/* Scan the input files to ensure all are accessible.
-   Otherwise exit with a diagnostic.
-
-   Note this will catch common issues with permissions etc.
-   but will fail to notice issues where you can open() but not read(),
-   like when a directory is specified on some systems.
-   Catching these obscure cases could slow down performance in
-   common cases.  */
+  struct stat instat, outstat;
 
-static void
-check_inputs (char *const *files, size_t nfiles)
-{
-  size_t i;
   for (i = 0; i < nfiles; i++)
     {
-      if (STREQ (files[i], "-"))
-        continue;
+      bool standard_input = STREQ (files[i], "-");
 
-      if (euidaccess (files[i], R_OK) != 0)
-        sort_die (_("cannot read"), files[i]);
-    }
-}
+      if (STREQ (outfile, files[i]) && ! standard_input)
+	return i;
 
-/* Ensure a specified output file can be created or written to,
-   and point stdout to it.  Do not truncate the file.
-   Exit with a diagnostic on failure.  */
+      if (! got_outstat)
+	{
+	  got_outstat = true;
+	  if ((STREQ (outfile, "-")
+	       ? fstat (STDOUT_FILENO, &outstat)
+	       : stat (outfile, &outstat))
+	      != 0)
+	    return nfiles;
+	}
 
-static void
-check_output (char const *outfile)
-{
-  if (outfile)
-    {
-      int outfd = open (outfile, O_WRONLY | O_CREAT | O_BINARY, MODE_RW_UGO);
-      if (outfd < 0)
-        sort_die (_("open failed"), outfile);
-      move_fd_or_die (outfd, STDOUT_FILENO);
+      if (((standard_input
+	    ? fstat (STDIN_FILENO, &instat)
+	    : stat (files[i], &instat))
+	   == 0)
+	  && (S_ISFIFO (instat.st_mode) || SAME_INODE (instat, outstat)))
+	return i;
     }
+
+  return nfiles;
 }
 
-/* Merge the input FILES.  NTEMPS is the number of files at the
-   start of FILES that are temporary; it is zero at the top level.
-   NFILES is the total number of files.  Put the output in
-   OUTPUT_FILE; a null OUTPUT_FILE stands for standard output.  */
+/* Merge NFILES FILES onto OUTPUT_FILE.  However, merge at most
+   MAX_MERGE input files directly onto OUTPUT_FILE.  MAX_MERGE cannot
+   exceed NMERGE.  */
 
 static void
-merge (struct sortfile *files, size_t ntemps, size_t nfiles,
-       char const *output_file)
+merge (char **files, int nfiles, int max_merge, char const *output_file)
 {
-  while (nmerge < nfiles)
+  while (max_merge < nfiles)
     {
-      /* Number of input files processed so far.  */
-      size_t in;
-
-      /* Number of output files generated so far.  */
-      size_t out;
-
-      /* nfiles % NMERGE; this counts input files that are left over
-         after all full-sized merges have been done.  */
-      size_t remainder;
-
-      /* Number of easily-available slots at the next loop iteration.  */
-      size_t cheap_slots;
-
-      /* Do as many NMERGE-size merges as possible. In the case that
-         nmerge is bogus, increment by the maximum number of file
-         descriptors allowed.  */
-      for (out = in = 0; nmerge <= nfiles - in; out++)
-        {
-          FILE *tfp;
-          struct tempnode *temp = create_temp (&tfp);
-          size_t num_merged = mergefiles (&files[in], MIN (ntemps, nmerge),
-                                          nmerge, tfp, temp->name);
-          ntemps -= MIN (ntemps, num_merged);
-          files[out].name = temp->name;
-          files[out].temp = temp;
-          in += num_merged;
-        }
-
-      remainder = nfiles - in;
-      cheap_slots = nmerge - out % nmerge;
-
-      if (cheap_slots < remainder)
-        {
-          /* So many files remain that they can't all be put into the last
-             NMERGE-sized output window.  Do one more merge.  Merge as few
-             files as possible, to avoid needless I/O.  */
-          size_t nshortmerge = remainder - cheap_slots + 1;
-          FILE *tfp;
-          struct tempnode *temp = create_temp (&tfp);
-          size_t num_merged = mergefiles (&files[in], MIN (ntemps, nshortmerge),
-                                          nshortmerge, tfp, temp->name);
-          ntemps -= MIN (ntemps, num_merged);
-          files[out].name = temp->name;
-          files[out++].temp = temp;
-          in += num_merged;
-        }
-
-      /* Put the remaining input files into the last NMERGE-sized output
-         window, so they will be merged in the next pass.  */
-      memmove (&files[out], &files[in], (nfiles - in) * sizeof *files);
-      ntemps += out;
-      nfiles -= in - out;
-    }
-
-  avoid_trashing_input (files, ntemps, nfiles, output_file);
-
-  /* We aren't guaranteed that this final mergefiles will work, therefore we
-     try to merge into the output, and then merge as much as we can into a
-     temp file if we can't. Repeat.  */
-
-  while (true)
-    {
-      /* Merge directly into the output file if possible.  */
-      FILE **fps;
-      size_t nopened = open_input_files (files, nfiles, &fps);
-
-      if (nopened == nfiles)
-        {
-          FILE *ofp = stream_open (output_file, "w");
-          if (ofp)
-            {
-              mergefps (files, ntemps, nfiles, ofp, output_file, fps);
-              break;
-            }
-          if (errno != EMFILE || nopened <= 2)
-            sort_die (_("open failed"), output_file);
-        }
-      else if (nopened <= 2)
-        sort_die (_("open failed"), files[nopened].name);
-
-      /* We ran out of file descriptors.  Close one of the input
-         files, to gain a file descriptor.  Then create a temporary
-         file with our spare file descriptor.  Retry if that failed
-         (e.g., some other process could open a file between the time
-         we closed and tried to create).  */
       FILE *tfp;
-      struct tempnode *temp;
-      do
-        {
-          nopened--;
-          xfclose (fps[nopened], files[nopened].name);
-          temp = maybe_create_temp (&tfp, ! (nopened <= 2));
-        }
-      while (!temp);
-
-      /* Merge into the newly allocated temporary.  */
-      mergefps (&files[0], MIN (ntemps, nopened), nopened, tfp, temp->name,
-                fps);
-      ntemps -= MIN (ntemps, nopened);
-      files[0].name = temp->name;
-      files[0].temp = temp;
-
-      memmove (&files[1], &files[nopened], (nfiles - nopened) * sizeof *files);
-      ntemps++;
-      nfiles -= nopened - 1;
+      int i, t = 0;
+      char *temp;
+      for (i = 0; i < nfiles / NMERGE; ++i)
+	{
+	  temp = create_temp_file (&tfp);
+	  mergefps (&files[i * NMERGE], NMERGE, tfp, temp);
+	  files[t++] = temp;
+	}
+      temp = create_temp_file (&tfp);
+      mergefps (&files[i * NMERGE], nfiles % NMERGE, tfp, temp);
+      files[t++] = temp;
+      nfiles = t;
+      if (nfiles == 1)
+	break;
     }
+
+  mergefps (files, nfiles, NULL, output_file);
 }
 
-/* Sort NFILES FILES onto OUTPUT_FILE.  Use at most NTHREADS threads.  */
+/* Sort NFILES FILES onto OUTPUT_FILE. */
 
 static void
-sort (char *const *files, size_t nfiles, char const *output_file,
-      size_t nthreads)
+sort (char * const *files, int nfiles, char const *output_file)
 {
   struct buffer buf;
-  IF_LINT (buf.buf = NULL);
-  size_t ntemps = 0;
+  int n_temp_files = 0;
   bool output_file_created = false;
 
   buf.alloc = 0;
 
   while (nfiles)
     {
       char const *temp_output;
       char const *file = *files;
       FILE *fp = xfopen (file, "r");
       FILE *tfp;
-
-      size_t bytes_per_line;
-      if (nthreads > 1)
-        {
-          /* Get log P. */
-          size_t tmp = 1;
-          size_t mult = 1;
-          while (tmp < nthreads)
-            {
-              tmp *= 2;
-              mult++;
-            }
-          bytes_per_line = (mult * sizeof (struct line));
-        }
-      else
-        bytes_per_line = sizeof (struct line) * 3 / 2;
+      size_t bytes_per_line = (2 * sizeof (struct line)
+			       - sizeof (struct line) / 2);
 
       if (! buf.alloc)
-        initbuf (&buf, bytes_per_line,
-                 sort_buffer_size (&fp, 1, files, nfiles, bytes_per_line));
+	initbuf (&buf, bytes_per_line,
+		 sort_buffer_size (&fp, 1, files, nfiles, bytes_per_line));
       buf.eof = false;
       files++;
       nfiles--;
 
       while (fillbuf (&buf, fp, file))
-        {
-          struct line *line;
-
-          if (buf.eof && nfiles
-              && (bytes_per_line + 1
-                  < (buf.alloc - buf.used - bytes_per_line * buf.nlines)))
-            {
-              /* End of file, but there is more input and buffer room.
-                 Concatenate the next input file; this is faster in
-                 the usual case.  */
-              buf.left = buf.used;
-              break;
-            }
-
-          saved_line.text = NULL;
-          line = buffer_linelim (&buf);
-          if (buf.eof && !nfiles && !ntemps && !buf.left)
-            {
-              xfclose (fp, file);
-              tfp = xfopen (output_file, "w");
-              temp_output = output_file;
-              output_file_created = true;
-            }
-          else
-            {
-              ++ntemps;
-              temp_output = create_temp (&tfp)->name;
-            }
-          if (1 < buf.nlines)
-            {
-              struct merge_node_queue queue;
-              queue_init (&queue, nthreads);
-              struct merge_node *merge_tree =
-                merge_tree_init (nthreads, buf.nlines, line);
-
-              sortlines (line, nthreads, buf.nlines, merge_tree + 1,
-                         &queue, tfp, temp_output);
-
-#ifdef lint
-              merge_tree_destroy (nthreads, merge_tree);
-              queue_destroy (&queue);
-#endif
-            }
-          else
-            write_unique (line - 1, tfp, temp_output);
-
-          xfclose (tfp, temp_output);
-
-          if (output_file_created)
-            goto finish;
-        }
+	{
+	  struct line *line;
+	  struct line *linebase;
+
+	  if (buf.eof && nfiles
+	      && (bytes_per_line + 1
+		  < (buf.alloc - buf.used - bytes_per_line * buf.nlines)))
+	    {
+	      /* End of file, but there is more input and buffer room.
+		 Concatenate the next input file; this is faster in
+		 the usual case.  */
+	      buf.left = buf.used;
+	      break;
+	    }
+
+	  line = buffer_linelim (&buf);
+	  linebase = line - buf.nlines;
+	  if (1 < buf.nlines)
+	    sortlines (line, buf.nlines, linebase);
+	  if (buf.eof && !nfiles && !n_temp_files && !buf.left)
+	    {
+	      xfclose (fp, file);
+	      tfp = xfopen (output_file, "w");
+	      temp_output = output_file;
+	      output_file_created = true;
+	    }
+	  else
+	    {
+	      ++n_temp_files;
+	      temp_output = create_temp_file (&tfp);
+	    }
+
+	  do
+	    {
+	      line--;
+	      write_bytes (line->text, line->length, tfp, temp_output);
+	      if (unique)
+		while (linebase < line && compare (line, line - 1) == 0)
+		  line--;
+	    }
+	  while (linebase < line);
+
+	  xfclose (tfp, temp_output);
+
+	  if (output_file_created)
+	    goto finish;
+	}
       xfclose (fp, file);
     }
 
  finish:
   free (buf.buf);
 
   if (! output_file_created)
     {
-      size_t i;
-      struct tempnode *node = temphead;
-      struct sortfile *tempfiles = xnmalloc (ntemps, sizeof *tempfiles);
-      for (i = 0; node; i++)
-        {
-          tempfiles[i].name = node->name;
-          tempfiles[i].temp = node;
-          node = node->next;
-        }
-      merge (tempfiles, ntemps, ntemps, output_file);
+      int i = n_temp_files;
+      struct tempnode *node;
+      char **tempfiles = xnmalloc (n_temp_files, sizeof *tempfiles);
+      for (node = temphead; i > 0; node = node->next)
+	tempfiles[--i] = node->name;
+      merge (tempfiles, n_temp_files, NMERGE, output_file);
       free (tempfiles);
     }
-
-  reap_all ();
 }
 
-/* Insert a malloc'd copy of key KEY_ARG at the end of the key list.  */
+/* Insert key KEY at the end of the key list.  */
 
 static void
-insertkey (struct keyfield *key_arg)
+insertkey (struct keyfield *key)
 {
   struct keyfield **p;
-  struct keyfield *key = xmemdup (key_arg, sizeof *key);
 
   for (p = &keylist; *p; p = &(*p)->next)
     continue;
   *p = key;
   key->next = NULL;
 }
@@ -4031,49 +2100,20 @@ insertkey (struct keyfield *key_arg)
 
 static void badfieldspec (char const *, char const *)
      ATTRIBUTE_NORETURN;
 static void
 badfieldspec (char const *spec, char const *msgid)
 {
-  die (SORT_FAILURE, 0, _("%s: invalid field specification %s"),
-       _(msgid), quote (spec));
-}
-
-/* Report incompatible options.  */
-
-static void incompatible_options (char const *) ATTRIBUTE_NORETURN;
-static void
-incompatible_options (char const *opts)
-{
-  die (SORT_FAILURE, 0, _("options '-%s' are incompatible"), (opts));
-}
-
-/* Check compatibility of ordering options.  */
-
-static void
-check_ordering_compatibility (void)
-{
-  struct keyfield *key;
-
-  for (key = keylist; key; key = key->next)
-    if (1 < (key->numeric + key->general_numeric + key->human_numeric
-             + key->month + (key->version | key->random | !!key->ignore)))
-      {
-        /* The following is too big, but guaranteed to be "big enough".  */
-        char opts[sizeof short_options];
-        /* Clear flags we're not interested in.  */
-        key->skipsblanks = key->skipeblanks = key->reverse = false;
-        key_to_opts (key, opts);
-        incompatible_options (opts);
-      }
+  error (SORT_FAILURE, 0, _("%s: invalid field specification `%s'"),
+	 _(msgid), spec);
+  abort ();
 }
 
 /* Parse the leading integer in STRING and store the resulting value
    (which must fit into size_t) into *VAL.  Return the address of the
-   suffix after the integer.  If the value is too large, silently
-   substitute SIZE_MAX.  If MSGID is NULL, return NULL after
+   suffix after the integer.  If MSGID is NULL, return NULL after
    failure; otherwise, report MSGID and exit on failure.  */
 
 static char const *
 parse_field_count (char const *string, size_t *val, char const *msgid)
 {
   char *suffix;
@@ -4082,703 +2122,482 @@ parse_field_count (char const *string, size_t *val, char const *msgid)
   switch (xstrtoumax (string, &suffix, 10, &n, ""))
     {
     case LONGINT_OK:
     case LONGINT_INVALID_SUFFIX_CHAR:
       *val = n;
       if (*val == n)
-        break;
+	break;
       /* Fall through.  */
     case LONGINT_OVERFLOW:
     case LONGINT_OVERFLOW | LONGINT_INVALID_SUFFIX_CHAR:
-      *val = SIZE_MAX;
-      break;
+      if (msgid)
+	error (SORT_FAILURE, 0, _("%s: count `%.*s' too large"),
+	       _(msgid), (int) (suffix - string), string);
+      return NULL;
 
     case LONGINT_INVALID:
       if (msgid)
-        die (SORT_FAILURE, 0, _("%s: invalid count at start of %s"),
-             _(msgid), quote (string));
+	error (SORT_FAILURE, 0, _("%s: invalid count at start of `%s'"),
+	       _(msgid), string);
       return NULL;
     }
 
   return suffix;
 }
 
 /* Handle interrupts and hangups. */
 
 static void
 sighandler (int sig)
 {
-  if (! SA_NOCLDSTOP)
-    signal (sig, SIG_IGN);
+#ifndef SA_NOCLDSTOP
+  signal (sig, SIG_IGN);
+#endif
 
   cleanup ();
 
+#ifdef SA_NOCLDSTOP
+  {
+    struct sigaction sigact;
+
+    sigact.sa_handler = SIG_DFL;
+    sigemptyset (&sigact.sa_mask);
+    sigact.sa_flags = 0;
+    sigaction (sig, &sigact, NULL);
+  }
+#else
   signal (sig, SIG_DFL);
+#endif
+
   raise (sig);
 }
 
 /* Set the ordering options for KEY specified in S.
    Return the address of the first character in S that
    is not a valid ordering option.
    BLANKTYPE is the kind of blanks that 'b' should skip. */
 
 static char *
-set_ordering (char const *s, struct keyfield *key, enum blanktype blanktype)
+set_ordering (register const char *s, struct keyfield *key,
+	      enum blanktype blanktype)
 {
   while (*s)
     {
       switch (*s)
-        {
-        case 'b':
-          if (blanktype == bl_start || blanktype == bl_both)
-            key->skipsblanks = true;
-          if (blanktype == bl_end || blanktype == bl_both)
-            key->skipeblanks = true;
-          break;
-        case 'd':
-          key->ignore = nondictionary;
-          break;
-        case 'f':
-          key->translate = fold_toupper;
-          break;
-        case 'g':
-          key->general_numeric = true;
-          break;
-        case 'h':
-          key->human_numeric = true;
-          break;
-        case 'i':
-          /* Option order should not matter, so don't let -i override
-             -d.  -d implies -i, but -i does not imply -d.  */
-          if (! key->ignore)
-            key->ignore = nonprinting;
-          break;
-        case 'M':
-          key->month = true;
-          break;
-        case 'n':
-          key->numeric = true;
-          break;
-        case 'R':
-          key->random = true;
-          break;
-        case 'r':
-          key->reverse = true;
-          break;
-        case 'V':
-          key->version = true;
-          break;
-        default:
-          return (char *) s;
-        }
+	{
+	case 'b':
+	  if (blanktype == bl_start || blanktype == bl_both)
+	    key->skipsblanks = true;
+	  if (blanktype == bl_end || blanktype == bl_both)
+	    key->skipeblanks = true;
+	  break;
+	case 'd':
+	  key->ignore = nondictionary;
+	  break;
+	case 'f':
+	  key->translate = fold_toupper;
+	  break;
+	case 'g':
+	  key->general_numeric = true;
+	  break;
+	case 'i':
+	  /* Option order should not matter, so don't let -i override
+	     -d.  -d implies -i, but -i does not imply -d.  */
+	  if (! key->ignore)
+	    key->ignore = nonprinting;
+	  break;
+	case 'M':
+	  key->month = true;
+	  break;
+	case 'n':
+	  key->numeric = true;
+	  break;
+	case 'r':
+	  key->reverse = true;
+	  break;
+	default:
+	  return (char *) s;
+	}
       ++s;
     }
   return (char *) s;
 }
 
-/* Initialize KEY.  */
-
 static struct keyfield *
-key_init (struct keyfield *key)
+new_key (void)
 {
-  memset (key, 0, sizeof *key);
+  struct keyfield *key = xzalloc (sizeof *key);
   key->eword = SIZE_MAX;
   return key;
 }
 
 int
 main (int argc, char **argv)
 {
   struct keyfield *key;
-  struct keyfield key_buf;
   struct keyfield gkey;
-  bool gkey_only = false;
   char const *s;
   int c = 0;
-  char checkonly = 0;
+  bool checkonly = false;
   bool mergeonly = false;
-  char *random_source = NULL;
-  bool need_random = false;
-  size_t nthreads = 0;
-  size_t nfiles = 0;
+  int nfiles = 0;
   bool posixly_correct = (getenv ("POSIXLY_CORRECT") != NULL);
-  int posix_ver = posix2_version ();
-  bool traditional_usage = ! (200112 <= posix_ver && posix_ver < 200809);
-  char **files;
-  char *files_from = NULL;
-  struct Tokens tok;
-  char const *outfile = NULL;
-  bool locale_ok;
+  bool obsolete_usage = (posix2_version () < 200112);
+  char const *short_options = (obsolete_usage
+			       ? COMMON_SHORT_OPTIONS "y::"
+			       : COMMON_SHORT_OPTIONS "y:");
+  char *minus = "-", **files;
+  char const *outfile = minus;
+#if defined __amigaos__ && defined __CLIB2__ /* AmigaOS using CLIB2 */
+  static int const sigs[] = { SIGINT, SIGTERM };
+#else
+  static int const sigs[] = { SIGHUP, SIGINT, SIGPIPE, SIGTERM };
+#endif
+  unsigned int nsigs = sizeof sigs / sizeof *sigs;
+#ifdef SA_NOCLDSTOP
+  struct sigaction oldact, newact;
+#endif
 
   initialize_main (&argc, &argv);
-  set_program_name (argv[0]);
-  locale_ok = !! setlocale (LC_ALL, "");
+  program_name = argv[0];
+  setlocale (LC_ALL, "");
   bindtextdomain (PACKAGE, LOCALEDIR);
   textdomain (PACKAGE);
 
+  atexit (cleanup);
+
   initialize_exit_failure (SORT_FAILURE);
+#if defined __amigaos__ && defined __CLIB2__ /* AmigaOS using CLIB2 */
+  atexit (my_close_stdout);
+#else
+  atexit (close_stdout);
+#endif
 
   hard_LC_COLLATE = hard_locale (LC_COLLATE);
 #if HAVE_NL_LANGINFO
   hard_LC_TIME = hard_locale (LC_TIME);
 #endif
 
-  /* Get locale's representation of the decimal point.  */
+#if HAVE_SETLOCALE
+  /* Let's get locale's representation of the decimal point */
   {
-    struct lconv const *locale = localeconv ();
+    struct lconv const *lconvp = localeconv ();
 
     /* If the locale doesn't define a decimal point, or if the decimal
-       point is multibyte, use the C locale's decimal point.  FIXME:
-       add support for multibyte decimal points.  */
-    decimal_point = to_uchar (locale->decimal_point[0]);
-    if (! decimal_point || locale->decimal_point[1])
-      decimal_point = '.';
-
-    /* FIXME: add support for multibyte thousands separators.  */
-    thousands_sep = to_uchar (*locale->thousands_sep);
-    if (! thousands_sep || locale->thousands_sep[1])
-      thousands_sep = -1;
+       point is multibyte, use the C decimal point.  We don't support
+       multibyte decimal points yet.  */
+    decimal_point = *lconvp->decimal_point;
+    if (! decimal_point || lconvp->decimal_point[1])
+      decimal_point = C_DECIMAL_POINT;
+
+    /* We don't support multibyte thousands separators yet.  */
+    th_sep = *lconvp->thousands_sep;
+    if (! th_sep || lconvp->thousands_sep[1])
+      th_sep = CHAR_MAX + 1;
   }
+#endif
 
   have_read_stdin = false;
   inittables ();
 
+#ifdef SA_NOCLDSTOP
   {
-    size_t i;
-    static int const sig[] =
-      {
-        /* The usual suspects.  */
-        SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
-#ifdef SIGPOLL
-        SIGPOLL,
-#endif
-#ifdef SIGPROF
-        SIGPROF,
-#endif
-#ifdef SIGVTALRM
-        SIGVTALRM,
-#endif
-#ifdef SIGXCPU
-        SIGXCPU,
-#endif
-#ifdef SIGXFSZ
-        SIGXFSZ,
-#endif
-      };
-    enum { nsigs = ARRAY_CARDINALITY (sig) };
-
-#if SA_NOCLDSTOP
-    struct sigaction act;
-
+    unsigned int i;
     sigemptyset (&caught_signals);
     for (i = 0; i < nsigs; i++)
-      {
-        sigaction (sig[i], NULL, &act);
-        if (act.sa_handler != SIG_IGN)
-          sigaddset (&caught_signals, sig[i]);
-      }
-
-    act.sa_handler = sighandler;
-    act.sa_mask = caught_signals;
-    act.sa_flags = 0;
+      sigaddset (&caught_signals, sigs[i]);
+    newact.sa_handler = sighandler;
+    newact.sa_mask = caught_signals;
+    newact.sa_flags = 0;
+  }
+#endif
 
+  {
+    unsigned int i;
     for (i = 0; i < nsigs; i++)
-      if (sigismember (&caught_signals, sig[i]))
-        sigaction (sig[i], &act, NULL);
+      {
+	int sig = sigs[i];
+#ifdef SA_NOCLDSTOP
+	sigaction (sig, NULL, &oldact);
+	if (oldact.sa_handler != SIG_IGN)
+	  sigaction (sig, &newact, NULL);
 #else
-    for (i = 0; i < nsigs; i++)
-      if (signal (sig[i], SIG_IGN) != SIG_IGN)
-        {
-          signal (sig[i], sighandler);
-          siginterrupt (sig[i], 1);
-        }
+	if (signal (sig, SIG_IGN) != SIG_IGN)
+	  signal (sig, sighandler);
 #endif
+      }
   }
-  signal (SIGCHLD, SIG_DFL); /* Don't inherit CHLD handling from parent.  */
 
-  /* The signal mask is known, so it is safe to invoke exit_cleanup.  */
-  atexit (exit_cleanup);
-
-  key_init (&gkey);
-  gkey.sword = SIZE_MAX;
+  gkey.sword = gkey.eword = SIZE_MAX;
+  gkey.ignore = NULL;
+  gkey.translate = NULL;
+  gkey.numeric = gkey.general_numeric = gkey.month = gkey.reverse = false;
+  gkey.skipsblanks = gkey.skipeblanks = false;
 
   files = xnmalloc (argc, sizeof *files);
 
-  while (true)
+  for (;;)
     {
       /* Parse an operand as a file after "--" was seen; or if
          pedantic and a file was seen, unless the POSIX version
-         is not 1003.1-2001 and -c was not seen and the operand is
+         predates 1003.1-2001 and -c was not seen and the operand is
          "-o FILE" or "-oFILE".  */
-      int oi = -1;
 
       if (c == -1
-          || (posixly_correct && nfiles != 0
-              && ! (traditional_usage
-                    && ! checkonly
-                    && optind != argc
-                    && argv[optind][0] == '-' && argv[optind][1] == 'o'
-                    && (argv[optind][2] || optind + 1 != argc)))
-          || ((c = getopt_long (argc, argv, short_options,
-                                long_options, &oi))
-              == -1))
-        {
-          if (argc <= optind)
-            break;
-          files[nfiles++] = argv[optind++];
-        }
+	  || (posixly_correct && nfiles != 0
+	      && ! (obsolete_usage
+		    && ! checkonly
+		    && optind != argc
+		    && argv[optind][0] == '-' && argv[optind][1] == 'o'
+		    && (argv[optind][2] || optind + 1 != argc)))
+	  || ((c = getopt_long (argc, argv, short_options,
+				long_options, NULL))
+	      == -1))
+	{
+	  if (argc <= optind)
+	    break;
+	  files[nfiles++] = argv[optind++];
+	}
       else switch (c)
-        {
-        case 1:
-          key = NULL;
-          if (optarg[0] == '+')
-            {
-              bool minus_pos_usage = (optind != argc && argv[optind][0] == '-'
-                                      && ISDIGIT (argv[optind][1]));
-              traditional_usage |= minus_pos_usage && !posixly_correct;
-              if (traditional_usage)
-                {
-                  /* Treat +POS1 [-POS2] as a key if possible; but silently
-                     treat an operand as a file if it is not a valid +POS1.  */
-                  key = key_init (&key_buf);
-                  s = parse_field_count (optarg + 1, &key->sword, NULL);
-                  if (s && *s == '.')
-                    s = parse_field_count (s + 1, &key->schar, NULL);
-                  if (! (key->sword || key->schar))
-                    key->sword = SIZE_MAX;
-                  if (! s || *set_ordering (s, key, bl_start))
-                    key = NULL;
-                  else
-                    {
-                      if (minus_pos_usage)
-                        {
-                          char const *optarg1 = argv[optind++];
-                          s = parse_field_count (optarg1 + 1, &key->eword,
-                                             N_("invalid number after '-'"));
-                          /* When called with a non-NULL message ID,
-                             parse_field_count cannot return NULL.  Tell static
-                             analysis tools that dereferencing S is safe.  */
-                          assert (s);
-                          if (*s == '.')
-                            s = parse_field_count (s + 1, &key->echar,
-                                               N_("invalid number after '.'"));
-                          if (!key->echar && key->eword)
-                            {
-                              /* obsolescent syntax +A.x -B.y is equivalent to:
-                                   -k A+1.x+1,B.y   (when y = 0)
-                                   -k A+1.x+1,B+1.y (when y > 0)
-                                 So eword is decremented as in the -k case
-                                 only when the end field (B) is specified and
-                                 echar (y) is 0.  */
-                              key->eword--;
-                            }
-                          if (*set_ordering (s, key, bl_end))
-                            badfieldspec (optarg1,
-                                      N_("stray character in field spec"));
-                        }
-                      key->traditional_used = true;
-                      insertkey (key);
-                    }
-                }
-            }
-          if (! key)
-            files[nfiles++] = optarg;
-          break;
-
-        case SORT_OPTION:
-          c = XARGMATCH ("--sort", optarg, sort_args, sort_types);
-          /* Fall through. */
-        case 'b':
-        case 'd':
-        case 'f':
-        case 'g':
-        case 'h':
-        case 'i':
-        case 'M':
-        case 'n':
-        case 'r':
-        case 'R':
-        case 'V':
-          {
-            char str[2];
-            str[0] = c;
-            str[1] = '\0';
-            set_ordering (str, &gkey, bl_both);
-          }
-          break;
-
-        case CHECK_OPTION:
-          c = (optarg
-               ? XARGMATCH ("--check", optarg, check_args, check_types)
-               : 'c');
-          /* Fall through.  */
-        case 'c':
-        case 'C':
-          if (checkonly && checkonly != c)
-            incompatible_options ("cC");
-          checkonly = c;
-          break;
-
-        case COMPRESS_PROGRAM_OPTION:
-          if (compress_program && !STREQ (compress_program, optarg))
-            die (SORT_FAILURE, 0, _("multiple compress programs specified"));
-          compress_program = optarg;
-          break;
-
-        case DEBUG_PROGRAM_OPTION:
-          debug = true;
-          break;
-
-        case FILES0_FROM_OPTION:
-          files_from = optarg;
-          break;
-
-        case 'k':
-          key = key_init (&key_buf);
-
-          /* Get POS1. */
-          s = parse_field_count (optarg, &key->sword,
-                                 N_("invalid number at field start"));
-          if (! key->sword--)
-            {
-              /* Provoke with 'sort -k0' */
-              badfieldspec (optarg, N_("field number is zero"));
-            }
-          if (*s == '.')
-            {
-              s = parse_field_count (s + 1, &key->schar,
-                                     N_("invalid number after '.'"));
-              if (! key->schar--)
-                {
-                  /* Provoke with 'sort -k1.0' */
-                  badfieldspec (optarg, N_("character offset is zero"));
-                }
-            }
-          if (! (key->sword || key->schar))
-            key->sword = SIZE_MAX;
-          s = set_ordering (s, key, bl_start);
-          if (*s != ',')
-            {
-              key->eword = SIZE_MAX;
-              key->echar = 0;
-            }
-          else
-            {
-              /* Get POS2. */
-              s = parse_field_count (s + 1, &key->eword,
-                                     N_("invalid number after ','"));
-              if (! key->eword--)
-                {
-                  /* Provoke with 'sort -k1,0' */
-                  badfieldspec (optarg, N_("field number is zero"));
-                }
-              if (*s == '.')
-                {
-                  s = parse_field_count (s + 1, &key->echar,
-                                         N_("invalid number after '.'"));
-                }
-              s = set_ordering (s, key, bl_end);
-            }
-          if (*s)
-            badfieldspec (optarg, N_("stray character in field spec"));
-          insertkey (key);
-          break;
-
-        case 'm':
-          mergeonly = true;
-          break;
-
-        case NMERGE_OPTION:
-          specify_nmerge (oi, c, optarg);
-          break;
-
-        case 'o':
-          if (outfile && !STREQ (outfile, optarg))
-            die (SORT_FAILURE, 0, _("multiple output files specified"));
-          outfile = optarg;
-          break;
-
-        case RANDOM_SOURCE_OPTION:
-          if (random_source && !STREQ (random_source, optarg))
-            die (SORT_FAILURE, 0, _("multiple random sources specified"));
-          random_source = optarg;
-          break;
-
-        case 's':
-          stable = true;
-          break;
-
-        case 'S':
-          specify_sort_size (oi, c, optarg);
-          break;
-
-        case 't':
-          {
-            char newtab = optarg[0];
-            if (! newtab)
-              die (SORT_FAILURE, 0, _("empty tab"));
-            if (optarg[1])
-              {
-                if (STREQ (optarg, "\\0"))
-                  newtab = '\0';
-                else
-                  {
-                    /* Provoke with 'sort -txx'.  Complain about
-                       "multi-character tab" instead of "multibyte tab", so
-                       that the diagnostic's wording does not need to be
-                       changed once multibyte characters are supported.  */
-                    die (SORT_FAILURE, 0, _("multi-character tab %s"),
-                         quote (optarg));
-                  }
-              }
-            if (tab != TAB_DEFAULT && tab != newtab)
-              die (SORT_FAILURE, 0, _("incompatible tabs"));
-            tab = newtab;
-          }
-          break;
-
-        case 'T':
-          add_temp_dir (optarg);
-          break;
-
-        case PARALLEL_OPTION:
-          nthreads = specify_nthreads (oi, c, optarg);
-          break;
-
-        case 'u':
-          unique = true;
-          break;
-
-        case 'y':
-          /* Accept and ignore e.g. -y0 for compatibility with Solaris 2.x
-             through Solaris 7.  It is also accepted by many non-Solaris
-             "sort" implementations, e.g., AIX 5.2, HP-UX 11i v2, IRIX 6.5.
-             -y is marked as obsolete starting with Solaris 8 (1999), but is
-             still accepted as of Solaris 10 prerelease (2004).
-
-             Solaris 2.5.1 "sort -y 100" reads the input file "100", but
-             emulate Solaris 8 and 9 "sort -y 100" which ignores the "100",
-             and which in general ignores the argument after "-y" if it
-             consists entirely of digits (it can even be empty).  */
-          if (optarg == argv[optind - 1])
-            {
-              char const *p;
-              for (p = optarg; ISDIGIT (*p); p++)
-                continue;
-              optind -= (*p != '\0');
-            }
-          break;
-
-        case 'z':
-          eolchar = 0;
-          break;
-
-        case_GETOPT_HELP_CHAR;
-
-        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
-
-        default:
-          usage (SORT_FAILURE);
-        }
-    }
-
-  if (files_from)
-    {
-      FILE *stream;
-
-      /* When using --files0-from=F, you may not specify any files
-         on the command-line.  */
-      if (nfiles)
-        {
-          error (0, 0, _("extra operand %s"), quoteaf (files[0]));
-          fprintf (stderr, "%s\n",
-                   _("file operands cannot be combined with --files0-from"));
-          usage (SORT_FAILURE);
-        }
-
-      if (STREQ (files_from, "-"))
-        stream = stdin;
-      else
-        {
-          stream = fopen (files_from, "r");
-          if (stream == NULL)
-            die (SORT_FAILURE, errno, _("cannot open %s for reading"),
-                 quoteaf (files_from));
-        }
-
-      readtokens0_init (&tok);
-
-      if (! readtokens0 (stream, &tok) || fclose (stream) != 0)
-        die (SORT_FAILURE, 0, _("cannot read file names from %s"),
-             quoteaf (files_from));
-
-      if (tok.n_tok)
-        {
-          size_t i;
-          free (files);
-          files = tok.tok;
-          nfiles = tok.n_tok;
-          for (i = 0; i < nfiles; i++)
-            {
-              if (STREQ (files[i], "-"))
-                die (SORT_FAILURE, 0, _("when reading file names from stdin, "
-                                        "no file name of %s allowed"),
-                     quoteaf (files[i]));
-              else if (files[i][0] == '\0')
-                {
-                  /* Using the standard 'filename:line-number:' prefix here is
-                     not totally appropriate, since NUL is the separator,
-                     not NL, but it might be better than nothing.  */
-                  unsigned long int file_number = i + 1;
-                  die (SORT_FAILURE, 0,
-                       _("%s:%lu: invalid zero-length file name"),
-                       quotef (files_from), file_number);
-                }
-            }
-        }
-      else
-        die (SORT_FAILURE, 0, _("no input from %s"),
-             quoteaf (files_from));
+	{
+	case 1:
+	  key = NULL;
+	  if (obsolete_usage && optarg[0] == '+')
+	    {
+	      /* Treat +POS1 [-POS2] as a key if possible; but silently
+		 treat an operand as a file if it is not a valid +POS1.  */
+	      key = new_key ();
+	      s = parse_field_count (optarg + 1, &key->sword, NULL);
+	      if (s && *s == '.')
+		s = parse_field_count (s + 1, &key->schar, NULL);
+	      if (! (key->sword | key->schar))
+		key->sword = SIZE_MAX;
+	      if (! s || *set_ordering (s, key, bl_start))
+		{
+		  free (key);
+		  key = NULL;
+		}
+	      else
+		{
+		  if (optind != argc && argv[optind][0] == '-'
+		      && ISDIGIT (argv[optind][1]))
+		    {
+		      char const *optarg1 = argv[optind++];
+		      s = parse_field_count (optarg1 + 1, &key->eword,
+					     N_("invalid number after `-'"));
+		      if (*s == '.')
+			s = parse_field_count (s + 1, &key->echar,
+					       N_("invalid number after `.'"));
+		      if (*set_ordering (s, key, bl_end))
+			badfieldspec (optarg1,
+				      N_("stray character in field spec"));
+		    }
+		  insertkey (key);
+		}
+	    }
+	  if (! key)
+	    files[nfiles++] = optarg;
+	  break;
+
+	case 'b':
+	case 'd':
+	case 'f':
+	case 'g':
+	case 'i':
+	case 'M':
+	case 'n':
+	case 'r':
+	  {
+	    char str[2];
+	    str[0] = c;
+	    str[1] = '\0';
+	    set_ordering (str, &gkey, bl_both);
+	  }
+	  break;
+
+	case 'c':
+	  checkonly = true;
+	  break;
+
+	case 'k':
+	  key = new_key ();
+
+	  /* Get POS1. */
+	  s = parse_field_count (optarg, &key->sword,
+				 N_("invalid number at field start"));
+	  if (! key->sword--)
+	    {
+	      /* Provoke with `sort -k0' */
+	      badfieldspec (optarg, N_("field number is zero"));
+	    }
+	  if (*s == '.')
+	    {
+	      s = parse_field_count (s + 1, &key->schar,
+				     N_("invalid number after `.'"));
+	      if (! key->schar--)
+		{
+		  /* Provoke with `sort -k1.0' */
+		  badfieldspec (optarg, N_("character offset is zero"));
+		}
+	    }
+	  if (! (key->sword | key->schar))
+	    key->sword = SIZE_MAX;
+	  s = set_ordering (s, key, bl_start);
+	  if (*s != ',')
+	    {
+	      key->eword = SIZE_MAX;
+	      key->echar = 0;
+	    }
+	  else
+	    {
+	      /* Get POS2. */
+	      s = parse_field_count (s + 1, &key->eword,
+				     N_("invalid number after `,'"));
+	      if (! key->eword--)
+		{
+		  /* Provoke with `sort -k1,0' */
+		  badfieldspec (optarg, N_("field number is zero"));
+		}
+	      if (*s == '.')
+		s = parse_field_count (s + 1, &key->echar,
+				       N_("invalid number after `.'"));
+	      else
+		{
+		  /* `-k 2,3' is equivalent to `+1 -3'.  */
+		  key->eword++;
+		}
+	      s = set_ordering (s, key, bl_end);
+	    }
+	  if (*s)
+	    badfieldspec (optarg, N_("stray character in field spec"));
+	  insertkey (key);
+	  break;
+
+	case 'm':
+	  mergeonly = true;
+	  break;
+
+	case 'o':
+	  if (outfile != minus && strcmp (outfile, optarg) != 0)
+	    error (SORT_FAILURE, 0, _("multiple output files specified"));
+	  outfile = optarg;
+	  break;
+
+	case 's':
+	  stable = true;
+	  break;
+
+	case 'S':
+	  specify_sort_size (optarg);
+	  break;
+
+	case 't':
+	  {
+	    int newtab = optarg[0];
+	    if (! newtab)
+	      error (SORT_FAILURE, 0, _("empty tab"));
+	    if (optarg[1])
+	      {
+		if (strcmp (optarg, "\\0") == 0)
+		  newtab = '\0';
+		else
+		  {
+		    /* Provoke with `sort -txx'.  Complain about
+		       "multi-character tab" instead of "multibyte tab", so
+		       that the diagnostic's wording does not need to be
+		       changed once multibyte characters are supported.  */
+		    error (SORT_FAILURE, 0, _("multi-character tab `%s'"),
+			   optarg);
+		  }
+	      }
+	    if (tab != TAB_DEFAULT && tab != newtab)
+	      error (SORT_FAILURE, 0, _("incompatible tabs"));
+	    tab = newtab;
+	  }
+	  break;
+
+	case 'T':
+	  add_temp_dir (optarg);
+	  break;
+
+	case 'u':
+	  unique = true;
+	  break;
+
+	case 'y':
+	  /* Accept and ignore e.g. -y0 for compatibility with Solaris
+	     2.x through Solaris 7.  -y is marked as obsolete starting
+	     with Solaris 8.  */
+	  break;
+
+	case 'z':
+	  eolchar = 0;
+	  break;
+
+	case_GETOPT_HELP_CHAR;
+
+	case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
+
+	default:
+	  usage (SORT_FAILURE);
+	}
     }
 
   /* Inheritance of global options to individual keys. */
   for (key = keylist; key; key = key->next)
-    {
-      if (default_key_compare (key) && !key->reverse)
-        {
-          key->ignore = gkey.ignore;
-          key->translate = gkey.translate;
-          key->skipsblanks = gkey.skipsblanks;
-          key->skipeblanks = gkey.skipeblanks;
-          key->month = gkey.month;
-          key->numeric = gkey.numeric;
-          key->general_numeric = gkey.general_numeric;
-          key->human_numeric = gkey.human_numeric;
-          key->version = gkey.version;
-          key->random = gkey.random;
-          key->reverse = gkey.reverse;
-        }
-
-      need_random |= key->random;
-    }
-
-  if (!keylist && !default_key_compare (&gkey))
-    {
-      gkey_only = true;
-      insertkey (&gkey);
-      need_random |= gkey.random;
-    }
-
-  check_ordering_compatibility ();
-
-  if (debug)
-    {
-      if (checkonly || outfile)
-        {
-          static char opts[] = "X --debug";
-          opts[0] = (checkonly ? checkonly : 'o');
-          incompatible_options (opts);
-        }
-
-      /* Always output the locale in debug mode, since this
-         is such a common source of confusion.  */
-      if (hard_LC_COLLATE)
-        error (0, 0, _("using %s sorting rules"),
-               quote (setlocale (LC_COLLATE, NULL)));
-      else
-        {
-          /* OpenBSD can only set some categories with LC_ALL above,
-             so set LC_COLLATE explicitly to flag errors.  */
-          if (locale_ok)
-            locale_ok = !! setlocale (LC_COLLATE, "");
-          error (0, 0, "%s%s", locale_ok ? "" : _("failed to set locale; "),
-                 _("using simple byte comparison"));
-        }
-      key_warnings (&gkey, gkey_only);
-    }
+    if (! (key->ignore || key->translate
+	   || (key->skipsblanks | key->reverse
+	       | key->skipeblanks | key->month | key->numeric
+	       | key->general_numeric)))
+      {
+	key->ignore = gkey.ignore;
+	key->translate = gkey.translate;
+	key->skipsblanks = gkey.skipsblanks;
+	key->skipeblanks = gkey.skipeblanks;
+	key->month = gkey.month;
+	key->numeric = gkey.numeric;
+	key->general_numeric = gkey.general_numeric;
+	key->reverse = gkey.reverse;
+      }
 
+  if (!keylist && (gkey.ignore || gkey.translate
+		   || (gkey.skipsblanks | gkey.skipeblanks | gkey.month
+		       | gkey.numeric | gkey.general_numeric)))
+    insertkey (&gkey);
   reverse = gkey.reverse;
 
-  if (need_random)
-    random_md5_state_init (random_source);
-
   if (temp_dir_count == 0)
     {
       char const *tmp_dir = getenv ("TMPDIR");
       add_temp_dir (tmp_dir ? tmp_dir : DEFAULT_TMPDIR);
     }
 
   if (nfiles == 0)
     {
       nfiles = 1;
-      free (files);
-      files = xmalloc (sizeof *files);
-      *files = (char *) "-";
+      files = &minus;
     }
 
-  /* Need to re-check that we meet the minimum requirement for memory
-     usage with the final value for NMERGE. */
-  if (0 < sort_size)
-    sort_size = MAX (sort_size, MIN_SORT_SIZE);
-
   if (checkonly)
     {
       if (nfiles > 1)
-        die (SORT_FAILURE, 0, _("extra operand %s not allowed with -%c"),
-             quoteaf (files[1]), checkonly);
-
-      if (outfile)
-        {
-          static char opts[] = {0, 'o', 0};
-          opts[0] = checkonly;
-          incompatible_options (opts);
-        }
-
-      /* POSIX requires that sort return 1 IFF invoked with -c or -C and the
-         input is not properly sorted.  */
-      return check (files[0], checkonly) ? EXIT_SUCCESS : SORT_OUT_OF_ORDER;
-    }
-
-  /* Check all inputs are accessible, or exit immediately.  */
-  check_inputs (files, nfiles);
+	error (SORT_FAILURE, 0, _("extra operand `%s' not allowed with -c"),
+	       files[1]);
 
-  /* Check output is writable, or exit immediately.  */
-  check_output (outfile);
+      /* POSIX requires that sort return 1 IFF invoked with -c and the
+	 input is not properly sorted.  */
+      exit (check (files[0]) ? EXIT_SUCCESS : SORT_OUT_OF_ORDER);
+    }
 
   if (mergeonly)
     {
-      struct sortfile *sortfiles = xcalloc (nfiles, sizeof *sortfiles);
-      size_t i;
-
-      for (i = 0; i < nfiles; ++i)
-        sortfiles[i].name = files[i];
-
-      merge (sortfiles, 0, nfiles, outfile);
-      IF_LINT (free (sortfiles));
-    }
-  else
-    {
-      if (!nthreads)
-        {
-          unsigned long int np = num_processors (NPROC_CURRENT_OVERRIDABLE);
-          nthreads = MIN (np, DEFAULT_MAX_THREADS);
-        }
-
-      /* Avoid integer overflow later.  */
-      size_t nthreads_max = SIZE_MAX / (2 * sizeof (struct merge_node));
-      nthreads = MIN (nthreads, nthreads_max);
-
-      sort (files, nfiles, outfile, nthreads);
+      int max_merge = first_same_file (files, MIN (nfiles, NMERGE), outfile);
+      merge (files, nfiles, max_merge, outfile);
     }
-
-#ifdef lint
-  if (files_from)
-    readtokens0_free (&tok);
   else
-    free (files);
-#endif
+    sort (files, nfiles, outfile);
 
   if (have_read_stdin && fclose (stdin) == EOF)
-    sort_die (_("close failed"), "-");
+    die (_("close failed"), "-");
 
-  return EXIT_SUCCESS;
+  exit (EXIT_SUCCESS);
 }
diff --git a/src/split.c b/src/split.c
index 96623369198566131c699d9f4171900a12e5131d..46370a7e2bb2d58bf44a97a7d11ec625fe269986 100644
--- a/src/split.c
+++ b/src/split.c
@@ -1,1650 +1,584 @@
 /* split.c -- split a file into pieces.
-   Copyright (C) 1988-2017 Free Software Foundation, Inc.
+   Copyright (C) 88, 91, 1995-2004 Free Software Foundation, Inc.
 
-   This program is free software: you can redistribute it and/or modify
+   This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
 /* By tege@sics.se, with rms.
 
-   TODO:
-   * support -p REGEX as in BSD's split.
-   * support --suppress-matched as in csplit.  */
+   To do:
+   * Implement -t CHAR or -t REGEX to specify break characters other
+     than newline. */
+
 #include <config.h>
 
-#include <assert.h>
 #include <stdio.h>
 #include <getopt.h>
-#include <signal.h>
 #include <sys/types.h>
-#include <sys/wait.h>
 
 #include "system.h"
-#include "die.h"
+#include "dirname.h"
 #include "error.h"
-#include "fd-reopen.h"
-#include "fcntl--.h"
+#include "full-read.h"
 #include "full-write.h"
-#include "ioblksize.h"
-#include "quote.h"
+#include "inttostr.h"
+#include "posixver.h"
 #include "safe-read.h"
-#include "sig2str.h"
-#include "xbinary-io.h"
-#include "xdectoint.h"
 #include "xstrtol.h"
+#include "binary-io.h"
+#include "stat-size.h"
 
-/* The official name of this program (e.g., no 'g' prefix).  */
+/* The official name of this program (e.g., no `g' prefix).  */
 #define PROGRAM_NAME "split"
 
-#define AUTHORS \
-  proper_name ("Torbjorn Granlund"), \
-  proper_name ("Richard M. Stallman")
-
-/* Shell command to filter through, instead of creating files.  */
-static char const *filter_command;
-
-/* Process ID of the filter.  */
-static int filter_pid;
+#define AUTHORS "Torbjorn Granlund", "Richard M. Stallman"
 
-/* Array of open pipes.  */
-static int *open_pipes;
-static size_t open_pipes_alloc;
-static size_t n_open_pipes;
-
-/* Blocked signals.  */
-static sigset_t oldblocked;
-static sigset_t newblocked;
+#define DEFAULT_SUFFIX_LENGTH 2
 
 /* Base name of output files.  */
 static char const *outbase;
 
 /* Name of output files.  */
 static char *outfile;
 
 /* Pointer to the end of the prefix in OUTFILE.
    Suffixes are inserted here.  */
 static char *outfile_mid;
 
-/* Generate new suffix when suffixes are exhausted.  */
-static bool suffix_auto = true;
-
 /* Length of OUTFILE's suffix.  */
-static size_t suffix_length;
+static size_t suffix_length = DEFAULT_SUFFIX_LENGTH;
 
 /* Alphabet of characters to use in suffix.  */
 static char const *suffix_alphabet = "abcdefghijklmnopqrstuvwxyz";
 
-/* Numerical suffix start value.  */
-static const char *numeric_suffix_start;
-
-/* Additional suffix to append to output file names.  */
-static char const *additional_suffix;
-
 /* Name of input file.  May be "-".  */
 static char *infile;
 
-/* stat buf for input file.  */
-static struct stat in_stat_buf;
+/* Descriptor on which input file is open.  */
+static int input_desc;
 
 /* Descriptor on which output file is open.  */
-static int output_desc = -1;
+static int output_desc;
 
-/* If true, print a diagnostic on standard error just before each
+/* If nonzero, print a diagnostic on standard error just before each
    output file is opened. */
-static bool verbose;
-
-/* If true, don't generate zero length output files. */
-static bool elide_empty_files;
-
-/* If true, in round robin mode, immediately copy
-   input to output, which is much slower, so disabled by default.  */
-static bool unbuffered;
-
-/* The character marking end of line.  Defaults to \n below.  */
-static int eolchar = -1;
-
-/* The split mode to use.  */
-enum Split_type
-{
-  type_undef, type_bytes, type_byteslines, type_lines, type_digits,
-  type_chunk_bytes, type_chunk_lines, type_rr
-};
-
-/* For long options that have no equivalent short option, use a
-   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
-enum
-{
-  VERBOSE_OPTION = CHAR_MAX + 1,
-  FILTER_OPTION,
-  IO_BLKSIZE_OPTION,
-  ADDITIONAL_SUFFIX_OPTION
-};
+static int verbose;
 
 static struct option const longopts[] =
 {
   {"bytes", required_argument, NULL, 'b'},
   {"lines", required_argument, NULL, 'l'},
   {"line-bytes", required_argument, NULL, 'C'},
-  {"number", required_argument, NULL, 'n'},
-  {"elide-empty-files", no_argument, NULL, 'e'},
-  {"unbuffered", no_argument, NULL, 'u'},
   {"suffix-length", required_argument, NULL, 'a'},
-  {"additional-suffix", required_argument, NULL,
-   ADDITIONAL_SUFFIX_OPTION},
-  {"numeric-suffixes", optional_argument, NULL, 'd'},
-  {"filter", required_argument, NULL, FILTER_OPTION},
-  {"verbose", no_argument, NULL, VERBOSE_OPTION},
-  {"separator", required_argument, NULL, 't'},
-  {"-io-blksize", required_argument, NULL,
-   IO_BLKSIZE_OPTION}, /* do not document */
+  {"numeric-suffixes", no_argument, NULL, 'd'},
+  {"verbose", no_argument, &verbose, 1},
   {GETOPT_HELP_OPTION_DECL},
   {GETOPT_VERSION_OPTION_DECL},
   {NULL, 0, NULL, 0}
 };
 
-/* Return true if the errno value, ERR, is ignorable.  */
-static inline bool
-ignorable (int err)
-{
-  return filter_command && err == EPIPE;
-}
-
-static void
-set_suffix_length (uintmax_t n_units, enum Split_type split_type)
-{
-#define DEFAULT_SUFFIX_LENGTH 2
-
-  uintmax_t suffix_needed = 0;
-
-  /* The suffix auto length feature is incompatible with
-     a user specified start value as the generated suffixes
-     are not all consecutive.  */
-  if (numeric_suffix_start)
-    suffix_auto = false;
-
-  /* Auto-calculate the suffix length if the number of files is given.  */
-  if (split_type == type_chunk_bytes || split_type == type_chunk_lines
-      || split_type == type_rr)
-    {
-      uintmax_t n_units_end = n_units;
-      if (numeric_suffix_start)
-        {
-          uintmax_t n_start;
-          strtol_error e = xstrtoumax (numeric_suffix_start, NULL, 10,
-                                       &n_start, "");
-          if (e == LONGINT_OK && n_start <= UINTMAX_MAX - n_units)
-            {
-              /* Restrict auto adjustment so we don't keep
-                 incrementing a suffix size arbitrarily,
-                 as that would break sort order for files
-                 generated from multiple split runs.  */
-              if (n_start < n_units)
-                n_units_end += n_start;
-            }
-
-        }
-      size_t alphabet_len = strlen (suffix_alphabet);
-      bool alphabet_slop = (n_units_end % alphabet_len) != 0;
-      while (n_units_end /= alphabet_len)
-        suffix_needed++;
-      suffix_needed += alphabet_slop;
-      suffix_auto = false;
-    }
-
-  if (suffix_length)            /* set by user */
-    {
-      if (suffix_length < suffix_needed)
-        {
-          die (EXIT_FAILURE, 0,
-               _("the suffix length needs to be at least %"PRIuMAX),
-               suffix_needed);
-        }
-      suffix_auto = false;
-      return;
-    }
-  else
-    suffix_length = MAX (DEFAULT_SUFFIX_LENGTH, suffix_needed);
-}
-
 void
 usage (int status)
 {
   if (status != EXIT_SUCCESS)
-    emit_try_help ();
+    fprintf (stderr, _("Try `%s --help' for more information.\n"),
+	     program_name);
   else
     {
       printf (_("\
-Usage: %s [OPTION]... [FILE [PREFIX]]\n\
+Usage: %s [OPTION] [INPUT [PREFIX]]\n\
 "),
-              program_name);
+	      program_name);
+    fputs (_("\
+Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default\n\
+PREFIX is `x'.  With no INPUT, or when INPUT is -, read standard input.\n\
+\n\
+"), stdout);
       fputs (_("\
-Output pieces of FILE to PREFIXaa, PREFIXab, ...;\n\
-default size is 1000 lines, and default PREFIX is 'x'.\n\
+Mandatory arguments to long options are mandatory for short options too.\n\
 "), stdout);
-
-      emit_stdin_note ();
-      emit_mandatory_arg_note ();
-
       fprintf (stdout, _("\
-  -a, --suffix-length=N   generate suffixes of length N (default %d)\n\
-      --additional-suffix=SUFFIX  append an additional SUFFIX to file names\n\
+  -a, --suffix-length=N   use suffixes of length N (default %d)\n\
   -b, --bytes=SIZE        put SIZE bytes per output file\n\
-  -C, --line-bytes=SIZE   put at most SIZE bytes of records per output file\n\
-  -d                      use numeric suffixes starting at 0, not alphabetic\n\
-      --numeric-suffixes[=FROM]  same as -d, but allow setting the start value\
-\n\
-  -e, --elide-empty-files  do not generate empty output files with '-n'\n\
-      --filter=COMMAND    write to shell COMMAND; file name is $FILE\n\
-  -l, --lines=NUMBER      put NUMBER lines/records per output file\n\
-  -n, --number=CHUNKS     generate CHUNKS output files; see explanation below\n\
-  -t, --separator=SEP     use SEP instead of newline as the record separator;\n\
-                            '\\0' (zero) specifies the NUL character\n\
-  -u, --unbuffered        immediately copy input to output with '-n r/...'\n\
+  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file\n\
+  -d, --numeric-suffixes  use numeric suffixes instead of alphabetic\n\
+  -l, --lines=NUMBER      put NUMBER lines per output file\n\
 "), DEFAULT_SUFFIX_LENGTH);
       fputs (_("\
-      --verbose           print a diagnostic just before each\n\
-                            output file is opened\n\
+      --verbose           print a diagnostic to standard error just\n\
+                            before each output file is opened\n\
 "), stdout);
       fputs (HELP_OPTION_DESCRIPTION, stdout);
       fputs (VERSION_OPTION_DESCRIPTION, stdout);
-      emit_size_note ();
-      fputs (_("\n\
-CHUNKS may be:\n\
-  N       split into N files based on size of input\n\
-  K/N     output Kth of N to stdout\n\
-  l/N     split into N files without splitting lines/records\n\
-  l/K/N   output Kth of N to stdout without splitting lines/records\n\
-  r/N     like 'l' but use round robin distribution\n\
-  r/K/N   likewise but only output Kth of N to stdout\n\
+      fputs (_("\
+\n\
+SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n\
 "), stdout);
-      emit_ancillary_info (PROGRAM_NAME);
+      printf (_("\nReport bugs to <%s>.\n"), PACKAGE_BUGREPORT);
     }
   exit (status);
 }
 
-/* Return the number of bytes that can be read from FD with status ST.
-   Store up to the first BUFSIZE bytes of the file's data into BUF,
-   and advance the file position by the number of bytes read.  On
-   input error, set errno and return -1.  */
-
-static off_t
-input_file_size (int fd, struct stat const *st, char *buf, size_t bufsize)
-{
-  off_t cur = lseek (fd, 0, SEEK_CUR);
-  if (cur < 0)
-    {
-      if (errno == ESPIPE)
-        errno = 0; /* Suppress confusing seek error.  */
-      return -1;
-    }
-
-  off_t size = 0;
-  do
-    {
-      size_t n_read = safe_read (fd, buf + size, bufsize - size);
-      if (n_read == 0)
-        return size;
-      if (n_read == SAFE_READ_ERROR)
-        return -1;
-      size += n_read;
-    }
-  while (size < bufsize);
-
-  /* Note we check st_size _after_ the read() above
-     because /proc files on GNU/Linux are seekable
-     but have st_size == 0.  */
-  if (st->st_size == 0)
-    {
-      /* We've filled the buffer, from a seekable file,
-         which has an st_size==0, E.g., /dev/zero on GNU/Linux.
-         Assume there is no limit to file size.  */
-      errno = EOVERFLOW;
-      return -1;
-    }
-
-  cur += size;
-  off_t end;
-  if (usable_st_size (st) && cur <= st->st_size)
-    end = st->st_size;
-  else
-    {
-      end = lseek (fd, 0, SEEK_END);
-      if (end < 0)
-        return -1;
-      if (end != cur)
-        {
-          if (lseek (fd, cur, SEEK_SET) < 0)
-            return -1;
-          if (end < cur)
-            end = cur;
-        }
-    }
-
-  size += end - cur;
-  if (size == OFF_T_MAX)
-    {
-      /* E.g., /dev/zero on GNU/Hurd.  */
-      errno = EOVERFLOW;
-      return -1;
-    }
-
-  return size;
-}
-
 /* Compute the next sequential output file name and store it into the
-   string 'outfile'.  */
+   string `outfile'.  */
 
 static void
 next_file_name (void)
 {
   /* Index in suffix_alphabet of each character in the suffix.  */
   static size_t *sufindex;
-  static size_t outbase_length;
-  static size_t outfile_length;
-  static size_t addsuf_length;
 
   if (! outfile)
     {
-      bool widen;
-
-new_name:
-      widen = !! outfile_length;
-
-      if (! widen)
-        {
-          /* Allocate and initialize the first file name.  */
-
-          outbase_length = strlen (outbase);
-          addsuf_length = additional_suffix ? strlen (additional_suffix) : 0;
-          outfile_length = outbase_length + suffix_length + addsuf_length;
-        }
-      else
-        {
-          /* Reallocate and initialize a new wider file name.
-             We do this by subsuming the unchanging part of
-             the generated suffix into the prefix (base), and
-             reinitializing the now one longer suffix.  */
-
-          outfile_length += 2;
-          suffix_length++;
-        }
+      /* Allocate and initialize the first file name.  */
 
+      size_t outbase_length = strlen (outbase);
+      size_t outfile_length = outbase_length + suffix_length;
       if (outfile_length + 1 < outbase_length)
-        xalloc_die ();
-      outfile = xrealloc (outfile, outfile_length + 1);
-
-      if (! widen)
-        memcpy (outfile, outbase, outbase_length);
-      else
-        {
-          /* Append the last alphabet character to the file name prefix.  */
-          outfile[outbase_length] = suffix_alphabet[sufindex[0]];
-          outbase_length++;
-        }
-
+	xalloc_die ();
+      outfile = xmalloc (outfile_length + 1);
       outfile_mid = outfile + outbase_length;
+      memcpy (outfile, outbase, outbase_length);
       memset (outfile_mid, suffix_alphabet[0], suffix_length);
-      if (additional_suffix)
-        memcpy (outfile_mid + suffix_length, additional_suffix, addsuf_length);
       outfile[outfile_length] = 0;
-
-      free (sufindex);
       sufindex = xcalloc (suffix_length, sizeof *sufindex);
 
-      if (numeric_suffix_start)
-        {
-          assert (! widen);
-
-          /* Update the output file name.  */
-          size_t i = strlen (numeric_suffix_start);
-          memcpy (outfile_mid + suffix_length - i, numeric_suffix_start, i);
-
-          /* Update the suffix index.  */
-          size_t *sufindex_end = sufindex + suffix_length;
-          while (i-- != 0)
-            *--sufindex_end = numeric_suffix_start[i] - '0';
-        }
-
 #if ! _POSIX_NO_TRUNC && HAVE_PATHCONF && defined _PC_NAME_MAX
       /* POSIX requires that if the output file name is too long for
-         its directory, 'split' must fail without creating any files.
-         This must be checked for explicitly on operating systems that
-         silently truncate file names.  */
+	 its directory, `split' must fail without creating any files.
+	 This must be checked for explicitly on operating systems that
+	 silently truncate file names.  */
       {
-        char *dir = dir_name (outfile);
-        long name_max = pathconf (dir, _PC_NAME_MAX);
-        if (0 <= name_max && name_max < base_len (last_component (outfile)))
-          die (EXIT_FAILURE, ENAMETOOLONG, "%s", quotef (outfile));
-        free (dir);
+	char *dir = dir_name (outfile);
+	long name_max = pathconf (dir, _PC_NAME_MAX);
+	if (0 <= name_max && name_max < base_len (base_name (outfile)))
+	  error (EXIT_FAILURE, ENAMETOOLONG, "%s", outfile);
+	free (dir);
       }
 #endif
     }
   else
     {
       /* Increment the suffix in place, if possible.  */
 
       size_t i = suffix_length;
       while (i-- != 0)
-        {
-          sufindex[i]++;
-          if (suffix_auto && i == 0 && ! suffix_alphabet[sufindex[0] + 1])
-            goto new_name;
-          outfile_mid[i] = suffix_alphabet[sufindex[i]];
-          if (outfile_mid[i])
-            return;
-          sufindex[i] = 0;
-          outfile_mid[i] = suffix_alphabet[sufindex[i]];
-        }
-      die (EXIT_FAILURE, 0, _("output file suffixes exhausted"));
-    }
-}
-
-/* Create or truncate a file.  */
-
-static int
-create (const char *name)
-{
-  if (!filter_command)
-    {
-      if (verbose)
-        fprintf (stdout, _("creating file %s\n"), quoteaf (name));
-
-      int fd = open (name, O_WRONLY | O_CREAT | O_BINARY, MODE_RW_UGO);
-      if (fd < 0)
-        return fd;
-      struct stat out_stat_buf;
-      if (fstat (fd, &out_stat_buf) != 0)
-        die (EXIT_FAILURE, errno, _("failed to stat %s"), quoteaf (name));
-      if (SAME_INODE (in_stat_buf, out_stat_buf))
-        die (EXIT_FAILURE, 0, _("%s would overwrite input; aborting"),
-             quoteaf (name));
-      if (ftruncate (fd, 0) != 0)
-        die (EXIT_FAILURE, errno, _("%s: error truncating"), quotef (name));
-
-      return fd;
-    }
-  else
-    {
-      int fd_pair[2];
-      pid_t child_pid;
-      char const *shell_prog = getenv ("SHELL");
-      if (shell_prog == NULL)
-        shell_prog = "/bin/sh";
-      if (setenv ("FILE", name, 1) != 0)
-        die (EXIT_FAILURE, errno,
-             _("failed to set FILE environment variable"));
-      if (verbose)
-        fprintf (stdout, _("executing with FILE=%s\n"), quotef (name));
-      if (pipe (fd_pair) != 0)
-        die (EXIT_FAILURE, errno, _("failed to create pipe"));
-      child_pid = fork ();
-      if (child_pid == 0)
-        {
-          /* This is the child process.  If an error occurs here, the
-             parent will eventually learn about it after doing a wait,
-             at which time it will emit its own error message.  */
-          int j;
-          /* We have to close any pipes that were opened during an
-             earlier call, otherwise this process will be holding a
-             write-pipe that will prevent the earlier process from
-             reading an EOF on the corresponding read-pipe.  */
-          for (j = 0; j < n_open_pipes; ++j)
-            if (close (open_pipes[j]) != 0)
-              die (EXIT_FAILURE, errno, _("closing prior pipe"));
-          if (close (fd_pair[1]))
-            die (EXIT_FAILURE, errno, _("closing output pipe"));
-          if (fd_pair[0] != STDIN_FILENO)
-            {
-              if (dup2 (fd_pair[0], STDIN_FILENO) != STDIN_FILENO)
-                die (EXIT_FAILURE, errno, _("moving input pipe"));
-              if (close (fd_pair[0]) != 0)
-                die (EXIT_FAILURE, errno, _("closing input pipe"));
-            }
-          sigprocmask (SIG_SETMASK, &oldblocked, NULL);
-          execl (shell_prog, last_component (shell_prog), "-c",
-                 filter_command, (char *) NULL);
-          die (EXIT_FAILURE, errno, _("failed to run command: \"%s -c %s\""),
-               shell_prog, filter_command);
-        }
-      if (child_pid == -1)
-        die (EXIT_FAILURE, errno, _("fork system call failed"));
-      if (close (fd_pair[0]) != 0)
-        die (EXIT_FAILURE, errno, _("failed to close input pipe"));
-      filter_pid = child_pid;
-      if (n_open_pipes == open_pipes_alloc)
-        open_pipes = x2nrealloc (open_pipes, &open_pipes_alloc,
-                                 sizeof *open_pipes);
-      open_pipes[n_open_pipes++] = fd_pair[1];
-      return fd_pair[1];
-    }
-}
-
-/* Close the output file, and do any associated cleanup.
-   If FP and FD are both specified, they refer to the same open file;
-   in this case FP is closed, but FD is still used in cleanup.  */
-static void
-closeout (FILE *fp, int fd, pid_t pid, char const *name)
-{
-  if (fp != NULL && fclose (fp) != 0 && ! ignorable (errno))
-    die (EXIT_FAILURE, errno, "%s", quotef (name));
-  if (fd >= 0)
-    {
-      if (fp == NULL && close (fd) < 0)
-        die (EXIT_FAILURE, errno, "%s", quotef (name));
-      int j;
-      for (j = 0; j < n_open_pipes; ++j)
-        {
-          if (open_pipes[j] == fd)
-            {
-              open_pipes[j] = open_pipes[--n_open_pipes];
-              break;
-            }
-        }
-    }
-  if (pid > 0)
-    {
-      int wstatus = 0;
-      if (waitpid (pid, &wstatus, 0) == -1 && errno != ECHILD)
-        die (EXIT_FAILURE, errno, _("waiting for child process"));
-      if (WIFSIGNALED (wstatus))
-        {
-          int sig = WTERMSIG (wstatus);
-          if (sig != SIGPIPE)
-            {
-              char signame[MAX (SIG2STR_MAX, INT_BUFSIZE_BOUND (int))];
-              if (sig2str (sig, signame) != 0)
-                sprintf (signame, "%d", sig);
-              error (sig + 128, 0,
-                     _("with FILE=%s, signal %s from command: %s"),
-                     quotef (name), signame, filter_command);
-            }
-        }
-      else if (WIFEXITED (wstatus))
-        {
-          int ex = WEXITSTATUS (wstatus);
-          if (ex != 0)
-            error (ex, 0, _("with FILE=%s, exit %d from command: %s"),
-                   quotef (name), ex, filter_command);
-        }
-      else
-        {
-          /* shouldn't happen.  */
-          die (EXIT_FAILURE, 0,
-               _("unknown status from command (0x%X)"), wstatus + 0u);
-        }
+	{
+	  sufindex[i]++;
+	  outfile_mid[i] = suffix_alphabet[sufindex[i]];
+	  if (outfile_mid[i])
+	    return;
+	  sufindex[i] = 0;
+	  outfile_mid[i] = suffix_alphabet[sufindex[i]];
+	}
+      error (EXIT_FAILURE, 0, _("Output file suffixes exhausted"));
     }
 }
 
 /* Write BYTES bytes at BP to an output file.
-   If NEW_FILE_FLAG is true, open the next output file.
-   Otherwise add to the same output file already in use.
-   Return true if successful.  */
+   If NEW_FILE_FLAG is nonzero, open the next output file.
+   Otherwise add to the same output file already in use.  */
 
-static bool
-cwrite (bool new_file_flag, const char *bp, size_t bytes)
+static void
+cwrite (int new_file_flag, const char *bp, size_t bytes)
 {
   if (new_file_flag)
     {
-      if (!bp && bytes == 0 && elide_empty_files)
-        return true;
-      closeout (NULL, output_desc, filter_pid, outfile);
+      if (output_desc >= 0 && close (output_desc) < 0)
+	error (EXIT_FAILURE, errno, "%s", outfile);
+
       next_file_name ();
-      output_desc = create (outfile);
+      if (verbose)
+	fprintf (stderr, _("creating file `%s'\n"), outfile);
+      output_desc = open (outfile,
+			  O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);
       if (output_desc < 0)
-        die (EXIT_FAILURE, errno, "%s", quotef (outfile));
-    }
-
-  if (full_write (output_desc, bp, bytes) == bytes)
-    return true;
-  else
-    {
-      if (! ignorable (errno))
-        die (EXIT_FAILURE, errno, "%s", quotef (outfile));
-      return false;
+	error (EXIT_FAILURE, errno, "%s", outfile);
     }
+  if (full_write (output_desc, bp, bytes) != bytes)
+    error (EXIT_FAILURE, errno, "%s", outfile);
 }
 
 /* Split into pieces of exactly N_BYTES bytes.
-   Use buffer BUF, whose size is BUFSIZE.
-   BUF contains the first INITIAL_READ input bytes.  */
+   Use buffer BUF, whose size is BUFSIZE.  */
 
 static void
-bytes_split (uintmax_t n_bytes, char *buf, size_t bufsize, size_t initial_read,
-             uintmax_t max_files)
+bytes_split (uintmax_t n_bytes, char *buf, size_t bufsize)
 {
   size_t n_read;
-  bool new_file_flag = true;
+  int new_file_flag = 1;
+  size_t to_read;
   uintmax_t to_write = n_bytes;
-  uintmax_t opened = 0;
-  bool eof;
+  char *bp_out;
 
   do
     {
-      if (initial_read != SIZE_MAX)
-        {
-          n_read = initial_read;
-          initial_read = SIZE_MAX;
-          eof = n_read < bufsize;
-        }
-      else
-        {
-          n_read = safe_read (STDIN_FILENO, buf, bufsize);
-          if (n_read == SAFE_READ_ERROR)
-            die (EXIT_FAILURE, errno, "%s", quotef (infile));
-          eof = n_read == 0;
-        }
-      char *bp_out = buf;
-      size_t to_read = n_read;
-      while (to_write <= to_read)
-        {
-          size_t w = to_write;
-          bool cwrite_ok = cwrite (new_file_flag, bp_out, w);
-          opened += new_file_flag;
-          new_file_flag = !max_files || (opened < max_files);
-          if (!new_file_flag && !cwrite_ok)
-            {
-              /* If filter no longer accepting input, stop reading.  */
-              n_read = to_read = 0;
-              break;
-            }
-          bp_out += w;
-          to_read -= w;
-          to_write = n_bytes;
-        }
-      if (to_read != 0)
-        {
-          bool cwrite_ok = cwrite (new_file_flag, bp_out, to_read);
-          opened += new_file_flag;
-          to_write -= to_read;
-          new_file_flag = false;
-          if (!cwrite_ok)
-            {
-              /* If filter no longer accepting input, stop reading.  */
-              n_read = 0;
-              break;
-            }
-        }
-    }
-  while (! eof);
-
-  /* Ensure NUMBER files are created, which truncates
-     any existing files or notifies any consumers on fifos.
-     FIXME: Should we do this before EXIT_FAILURE?  */
-  while (opened++ < max_files)
-    cwrite (true, NULL, 0);
+      n_read = full_read (input_desc, buf, bufsize);
+      if (n_read == SAFE_READ_ERROR)
+        error (EXIT_FAILURE, errno, "%s", infile);
+      bp_out = buf;
+      to_read = n_read;
+      for (;;)
+	{
+	  if (to_read < to_write)
+	    {
+	      if (to_read)	/* do not write 0 bytes! */
+		{
+		  cwrite (new_file_flag, bp_out, to_read);
+		  to_write -= to_read;
+		  new_file_flag = 0;
+		}
+	      break;
+	    }
+	  else
+	    {
+	      size_t w = to_write;
+	      cwrite (new_file_flag, bp_out, w);
+	      bp_out += w;
+	      to_read -= w;
+	      new_file_flag = 1;
+	      to_write = n_bytes;
+	    }
+	}
+    }
+  while (n_read == bufsize);
 }
 
 /* Split into pieces of exactly N_LINES lines.
    Use buffer BUF, whose size is BUFSIZE.  */
 
 static void
 lines_split (uintmax_t n_lines, char *buf, size_t bufsize)
 {
   size_t n_read;
   char *bp, *bp_out, *eob;
-  bool new_file_flag = true;
+  int new_file_flag = 1;
   uintmax_t n = 0;
 
   do
     {
-      n_read = safe_read (STDIN_FILENO, buf, bufsize);
+      n_read = full_read (input_desc, buf, bufsize);
       if (n_read == SAFE_READ_ERROR)
-        die (EXIT_FAILURE, errno, "%s", quotef (infile));
+	error (EXIT_FAILURE, errno, "%s", infile);
       bp = bp_out = buf;
       eob = bp + n_read;
-      *eob = eolchar;
-      while (true)
-        {
-          bp = memchr (bp, eolchar, eob - bp + 1);
-          if (bp == eob)
-            {
-              if (eob != bp_out) /* do not write 0 bytes! */
-                {
-                  size_t len = eob - bp_out;
-                  cwrite (new_file_flag, bp_out, len);
-                  new_file_flag = false;
-                }
-              break;
-            }
-
-          ++bp;
-          if (++n >= n_lines)
-            {
-              cwrite (new_file_flag, bp_out, bp - bp_out);
-              bp_out = bp;
-              new_file_flag = true;
-              n = 0;
-            }
-        }
-    }
-  while (n_read);
+      *eob = '\n';
+      for (;;)
+	{
+	  bp = memchr (bp, '\n', eob - bp + 1);
+	  if (bp == eob)
+	    {
+	      if (eob != bp_out) /* do not write 0 bytes! */
+		{
+		  size_t len = eob - bp_out;
+		  cwrite (new_file_flag, bp_out, len);
+		  new_file_flag = 0;
+		}
+	      break;
+	    }
+
+	  ++bp;
+	  if (++n >= n_lines)
+	    {
+	      cwrite (new_file_flag, bp_out, bp - bp_out);
+	      bp_out = bp;
+	      new_file_flag = 1;
+	      n = 0;
+	    }
+	}
+    }
+  while (n_read == bufsize);
 }
-
+
 /* Split into pieces that are as large as possible while still not more
    than N_BYTES bytes, and are split on line boundaries except
-   where lines longer than N_BYTES bytes occur. */
+   where lines longer than N_BYTES bytes occur.
+   FIXME: Allow N_BYTES to be any uintmax_t value, and don't require a
+   buffer of size N_BYTES, in case N_BYTES is very large.  */
 
 static void
-line_bytes_split (uintmax_t n_bytes, char *buf, size_t bufsize)
+line_bytes_split (size_t n_bytes)
 {
   size_t n_read;
-  uintmax_t n_out = 0;      /* for each split.  */
-  size_t n_hold = 0;
-  char *hold = NULL;        /* for lines > bufsize.  */
-  size_t hold_size = 0;
-  bool split_line = false;  /* Whether a \n was output in a split.  */
+  char *bp;
+  int eof = 0;
+  size_t n_buffered = 0;
+  char *buf = xmalloc (n_bytes);
 
   do
     {
-      n_read = safe_read (STDIN_FILENO, buf, bufsize);
-      if (n_read == SAFE_READ_ERROR)
-        die (EXIT_FAILURE, errno, "%s", quotef (infile));
-      size_t n_left = n_read;
-      char *sob = buf;
-      while (n_left)
-        {
-          size_t split_rest = 0;
-          char *eoc = NULL;
-          char *eol;
-
-          /* Determine End Of Chunk and/or End of Line,
-             which are used below to select what to write or buffer.  */
-          if (n_bytes - n_out - n_hold <= n_left)
-            {
-              /* Have enough for split.  */
-              split_rest = n_bytes - n_out - n_hold;
-              eoc = sob + split_rest - 1;
-              eol = memrchr (sob, eolchar, split_rest);
-            }
-          else
-            eol = memrchr (sob, eolchar, n_left);
-
-          /* Output hold space if possible.  */
-          if (n_hold && !(!eol && n_out))
-            {
-              cwrite (n_out == 0, hold, n_hold);
-              n_out += n_hold;
-              if (n_hold > bufsize)
-                hold = xrealloc (hold, bufsize);
-              n_hold = 0;
-              hold_size = bufsize;
-            }
-
-          /* Output to eol if present.  */
-          if (eol)
-            {
-              split_line = true;
-              size_t n_write = eol - sob + 1;
-              cwrite (n_out == 0, sob, n_write);
-              n_out += n_write;
-              n_left -= n_write;
-              sob += n_write;
-              if (eoc)
-                split_rest -= n_write;
-            }
-
-          /* Output to eoc or eob if possible.  */
-          if (n_left && !split_line)
-            {
-              size_t n_write = eoc ? split_rest : n_left;
-              cwrite (n_out == 0, sob, n_write);
-              n_out += n_write;
-              n_left -= n_write;
-              sob += n_write;
-              if (eoc)
-                split_rest -= n_write;
-            }
-
-          /* Update hold if needed.  */
-          if ((eoc && split_rest) || (!eoc && n_left))
-            {
-              size_t n_buf = eoc ? split_rest : n_left;
-              if (hold_size - n_hold < n_buf)
-                {
-                  if (hold_size <= SIZE_MAX - bufsize)
-                    hold_size += bufsize;
-                  else
-                    xalloc_die ();
-                  hold = xrealloc (hold, hold_size);
-                }
-              memcpy (hold + n_hold, sob, n_buf);
-              n_hold += n_buf;
-              n_left -= n_buf;
-              sob += n_buf;
-            }
-
-          /* Reset for new split.  */
-          if (eoc)
-            {
-              n_out = 0;
-              split_line = false;
-            }
-        }
-    }
-  while (n_read);
-
-  /* Handle no eol at end of file.  */
-  if (n_hold)
-    cwrite (n_out == 0, hold, n_hold);
-
-  free (hold);
-}
-
-/* -n l/[K/]N: Write lines to files of approximately file size / N.
-   The file is partitioned into file size / N sized portions, with the
-   last assigned any excess.  If a line _starts_ within a partition
-   it is written completely to the corresponding file.  Since lines
-   are not split even if they overlap a partition, the files written
-   can be larger or smaller than the partition size, and even empty
-   if a line is so long as to completely overlap the partition.  */
-
-static void
-lines_chunk_split (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,
-                   size_t initial_read, off_t file_size)
-{
-  assert (n && k <= n && n <= file_size);
-
-  const off_t chunk_size = file_size / n;
-  uintmax_t chunk_no = 1;
-  off_t chunk_end = chunk_size - 1;
-  off_t n_written = 0;
-  bool new_file_flag = true;
-  bool chunk_truncated = false;
-
-  if (k > 1)
-    {
-      /* Start reading 1 byte before kth chunk of file.  */
-      off_t start = (k - 1) * chunk_size - 1;
-      if (start < initial_read)
-        {
-          memmove (buf, buf + start, initial_read - start);
-          initial_read -= start;
-        }
-      else
-        {
-          if (lseek (STDIN_FILENO, start - initial_read, SEEK_CUR) < 0)
-            die (EXIT_FAILURE, errno, "%s", quotef (infile));
-          initial_read = SIZE_MAX;
-        }
-      n_written = start;
-      chunk_no = k - 1;
-      chunk_end = chunk_no * chunk_size - 1;
-    }
-
-  while (n_written < file_size)
-    {
-      char *bp = buf, *eob;
-      size_t n_read;
-      if (initial_read != SIZE_MAX)
-        {
-          n_read = initial_read;
-          initial_read = SIZE_MAX;
-        }
-      else
-        {
-          n_read = safe_read (STDIN_FILENO, buf, bufsize);
-          if (n_read == SAFE_READ_ERROR)
-            die (EXIT_FAILURE, errno, "%s", quotef (infile));
-        }
-      if (n_read == 0)
-        break; /* eof.  */
-      n_read = MIN (n_read, file_size - n_written);
-      chunk_truncated = false;
-      eob = buf + n_read;
-
-      while (bp != eob)
-        {
-          size_t to_write;
-          bool next = false;
-
-          /* Begin looking for '\n' at last byte of chunk.  */
-          off_t skip = MIN (n_read, MAX (0, chunk_end - n_written));
-          char *bp_out = memchr (bp + skip, eolchar, n_read - skip);
-          if (bp_out++)
-            next = true;
-          else
-            bp_out = eob;
-          to_write = bp_out - bp;
-
-          if (k == chunk_no)
-            {
-              /* We don't use the stdout buffer here since we're writing
-                 large chunks from an existing file, so it's more efficient
-                 to write out directly.  */
-              if (full_write (STDOUT_FILENO, bp, to_write) != to_write)
-                die (EXIT_FAILURE, errno, "%s", _("write error"));
-            }
-          else if (! k)
-            cwrite (new_file_flag, bp, to_write);
-          n_written += to_write;
-          bp += to_write;
-          n_read -= to_write;
-          new_file_flag = next;
-
-          /* A line could have been so long that it skipped
-             entire chunks. So create empty files in that case.  */
-          while (next || chunk_end <= n_written - 1)
-            {
-              if (!next && bp == eob)
-                {
-                  /* replenish buf, before going to next chunk.  */
-                  chunk_truncated = true;
-                  break;
-                }
-              chunk_no++;
-              if (k && chunk_no > k)
-                return;
-              if (chunk_no == n)
-                chunk_end = file_size - 1; /* >= chunk_size.  */
-              else
-                chunk_end += chunk_size;
-              if (chunk_end <= n_written - 1)
-                {
-                  if (! k)
-                    cwrite (true, NULL, 0);
-                }
-              else
-                next = false;
-            }
-        }
-    }
-
-  if (chunk_truncated)
-    chunk_no++;
-
-  /* Ensure NUMBER files are created, which truncates
-     any existing files or notifies any consumers on fifos.
-     FIXME: Should we do this before EXIT_FAILURE?  */
-  while (!k && chunk_no++ <= n)
-    cwrite (true, NULL, 0);
-}
-
-/* -n K/N: Extract Kth of N chunks.  */
-
-static void
-bytes_chunk_extract (uintmax_t k, uintmax_t n, char *buf, size_t bufsize,
-                     size_t initial_read, off_t file_size)
-{
-  off_t start;
-  off_t end;
-
-  assert (k && n && k <= n && n <= file_size);
-
-  start = (k - 1) * (file_size / n);
-  end = (k == n) ? file_size : k * (file_size / n);
-
-  if (start < initial_read)
-    {
-      memmove (buf, buf + start, initial_read - start);
-      initial_read -= start;
-    }
-  else
-    {
-      if (lseek (STDIN_FILENO, start, SEEK_CUR) < 0)
-        die (EXIT_FAILURE, errno, "%s", quotef (infile));
-      initial_read = SIZE_MAX;
-    }
-
-  while (start < end)
-    {
-      size_t n_read;
-      if (initial_read != SIZE_MAX)
-        {
-          n_read = initial_read;
-          initial_read = SIZE_MAX;
-        }
-      else
-        {
-          n_read = safe_read (STDIN_FILENO, buf, bufsize);
-          if (n_read == SAFE_READ_ERROR)
-            die (EXIT_FAILURE, errno, "%s", quotef (infile));
-        }
-      if (n_read == 0)
-        break; /* eof.  */
-      n_read = MIN (n_read, end - start);
-      if (full_write (STDOUT_FILENO, buf, n_read) != n_read
-          && ! ignorable (errno))
-        die (EXIT_FAILURE, errno, "%s", quotef ("-"));
-      start += n_read;
-    }
-}
-
-typedef struct of_info
-{
-  char *of_name;
-  int ofd;
-  FILE *ofile;
-  int opid;
-} of_t;
-
-enum
-{
-  OFD_NEW = -1,
-  OFD_APPEND = -2
-};
-
-/* Rotate file descriptors when we're writing to more output files than we
-   have available file descriptors.
-   Return whether we came under file resource pressure.
-   If so, it's probably best to close each file when finished with it.  */
-
-static bool
-ofile_open (of_t *files, size_t i_check, size_t nfiles)
-{
-  bool file_limit = false;
-
-  if (files[i_check].ofd <= OFD_NEW)
-    {
-      int fd;
-      size_t i_reopen = i_check ? i_check - 1 : nfiles - 1;
-
-      /* Another process could have opened a file in between the calls to
-         close and open, so we should keep trying until open succeeds or
-         we've closed all of our files.  */
-      while (true)
-        {
-          if (files[i_check].ofd == OFD_NEW)
-            fd = create (files[i_check].of_name);
-          else /* OFD_APPEND  */
-            {
-              /* Attempt to append to previously opened file.
-                 We use O_NONBLOCK to support writing to fifos,
-                 where the other end has closed because of our
-                 previous close.  In that case we'll immediately
-                 get an error, rather than waiting indefinitely.
-                 In specialised cases the consumer can keep reading
-                 from the fifo, terminating on conditions in the data
-                 itself, or perhaps never in the case of 'tail -f'.
-                 I.e., for fifos it is valid to attempt this reopen.
-
-                 We don't handle the filter_command case here, as create()
-                 will exit if there are not enough files in that case.
-                 I.e., we don't support restarting filters, as that would
-                 put too much burden on users specifying --filter commands.  */
-              fd = open (files[i_check].of_name,
-                         O_WRONLY | O_BINARY | O_APPEND | O_NONBLOCK);
-            }
-
-          if (-1 < fd)
-            break;
-
-          if (!(errno == EMFILE || errno == ENFILE))
-            die (EXIT_FAILURE, errno, "%s", quotef (files[i_check].of_name));
-
-          file_limit = true;
-
-          /* Search backwards for an open file to close.  */
-          while (files[i_reopen].ofd < 0)
-            {
-              i_reopen = i_reopen ? i_reopen - 1 : nfiles - 1;
-              /* No more open files to close, exit with E[NM]FILE.  */
-              if (i_reopen == i_check)
-                die (EXIT_FAILURE, errno, "%s",
-                     quotef (files[i_check].of_name));
-            }
-
-          if (fclose (files[i_reopen].ofile) != 0)
-            die (EXIT_FAILURE, errno, "%s", quotef (files[i_reopen].of_name));
-          files[i_reopen].ofile = NULL;
-          files[i_reopen].ofd = OFD_APPEND;
-        }
-
-      files[i_check].ofd = fd;
-      if (!(files[i_check].ofile = fdopen (fd, "a")))
-        die (EXIT_FAILURE, errno, "%s", quotef (files[i_check].of_name));
-      files[i_check].opid = filter_pid;
-      filter_pid = 0;
-    }
+      /* Fill up the full buffer size from the input file.  */
 
-  return file_limit;
-}
-
-/* -n r/[K/]N: Divide file into N chunks in round robin fashion.
-   When K == 0, we try to keep the files open in parallel.
-   If we run out of file resources, then we revert
-   to opening and closing each file for each line.  */
-
-static void
-lines_rr (uintmax_t k, uintmax_t n, char *buf, size_t bufsize)
-{
-  bool wrapped = false;
-  bool wrote = false;
-  bool file_limit;
-  size_t i_file;
-  of_t *files IF_LINT (= NULL);
-  uintmax_t line_no;
-
-  if (k)
-    line_no = 1;
-  else
-    {
-      if (SIZE_MAX < n)
-        xalloc_die ();
-      files = xnmalloc (n, sizeof *files);
-
-      /* Generate output file names. */
-      for (i_file = 0; i_file < n; i_file++)
-        {
-          next_file_name ();
-          files[i_file].of_name = xstrdup (outfile);
-          files[i_file].ofd = OFD_NEW;
-          files[i_file].ofile = NULL;
-          files[i_file].opid = 0;
-        }
-      i_file = 0;
-      file_limit = false;
-    }
-
-  while (true)
-    {
-      char *bp = buf, *eob;
-      size_t n_read = safe_read (STDIN_FILENO, buf, bufsize);
+      n_read = full_read (input_desc, buf + n_buffered, n_bytes - n_buffered);
       if (n_read == SAFE_READ_ERROR)
-        die (EXIT_FAILURE, errno, "%s", quotef (infile));
-      else if (n_read == 0)
-        break; /* eof.  */
-      eob = buf + n_read;
-
-      while (bp != eob)
-        {
-          size_t to_write;
-          bool next = false;
-
-          /* Find end of line. */
-          char *bp_out = memchr (bp, eolchar, eob - bp);
-          if (bp_out)
-            {
-              bp_out++;
-              next = true;
-            }
-          else
-            bp_out = eob;
-          to_write = bp_out - bp;
-
-          if (k)
-            {
-              if (line_no == k && unbuffered)
-                {
-                  if (full_write (STDOUT_FILENO, bp, to_write) != to_write)
-                    die (EXIT_FAILURE, errno, "%s", _("write error"));
-                }
-              else if (line_no == k && fwrite (bp, to_write, 1, stdout) != 1)
-                {
-                  clearerr (stdout); /* To silence close_stdout().  */
-                  die (EXIT_FAILURE, errno, "%s", _("write error"));
-                }
-              if (next)
-                line_no = (line_no == n) ? 1 : line_no + 1;
-            }
-          else
-            {
-              /* Secure file descriptor. */
-              file_limit |= ofile_open (files, i_file, n);
-              if (unbuffered)
-                {
-                  /* Note writing to fd, rather than flushing the FILE gives
-                     an 8% performance benefit, due to reduced data copying.  */
-                  if (full_write (files[i_file].ofd, bp, to_write) != to_write
-                      && ! ignorable (errno))
-                    {
-                      die (EXIT_FAILURE, errno, "%s",
-                           quotef (files[i_file].of_name));
-                    }
-                }
-              else if (fwrite (bp, to_write, 1, files[i_file].ofile) != 1
-                       && ! ignorable (errno))
-                {
-                  die (EXIT_FAILURE, errno, "%s",
-                       quotef (files[i_file].of_name));
-                }
-
-              if (! ignorable (errno))
-                wrote = true;
-
-              if (file_limit)
-                {
-                  if (fclose (files[i_file].ofile) != 0)
-                    {
-                      die (EXIT_FAILURE, errno, "%s",
-                           quotef (files[i_file].of_name));
-                    }
-                  files[i_file].ofile = NULL;
-                  files[i_file].ofd = OFD_APPEND;
-                }
-              if (next && ++i_file == n)
-                {
-                  wrapped = true;
-                  /* If no filters are accepting input, stop reading.  */
-                  if (! wrote)
-                    goto no_filters;
-                  wrote = false;
-                  i_file = 0;
-                }
-            }
-
-          bp = bp_out;
-        }
-    }
-
-no_filters:
-  /* Ensure all files created, so that any existing files are truncated,
-     and to signal any waiting fifo consumers.
-     Also, close any open file descriptors.
-     FIXME: Should we do this before EXIT_FAILURE?  */
-  if (!k)
-    {
-      int ceiling = (wrapped ? n : i_file);
-      for (i_file = 0; i_file < n; i_file++)
-        {
-          if (i_file >= ceiling && !elide_empty_files)
-            file_limit |= ofile_open (files, i_file, n);
-          if (files[i_file].ofd >= 0)
-            closeout (files[i_file].ofile, files[i_file].ofd,
-                      files[i_file].opid, files[i_file].of_name);
-          files[i_file].ofd = OFD_APPEND;
-        }
-    }
-  IF_LINT (free (files));
+	error (EXIT_FAILURE, errno, "%s", infile);
+
+      n_buffered += n_read;
+      if (n_buffered != n_bytes)
+	eof = 1;
+
+      /* Find where to end this chunk.  */
+      bp = buf + n_buffered;
+      if (n_buffered == n_bytes)
+	{
+	  while (bp > buf && bp[-1] != '\n')
+	    bp--;
+	}
+
+      /* If chunk has no newlines, use all the chunk.  */
+      if (bp == buf)
+	bp = buf + n_buffered;
+
+      /* Output the chars as one output file.  */
+      cwrite (1, buf, bp - buf);
+
+      /* Discard the chars we just output; move rest of chunk
+	 down to be the start of the next chunk.  Source and
+	 destination probably overlap.  */
+      n_buffered -= bp - buf;
+      if (n_buffered > 0)
+	memmove (buf, bp, n_buffered);
+    }
+  while (!eof);
+  free (buf);
 }
 
 #define FAIL_ONLY_ONE_WAY()					\
   do								\
     {								\
       error (0, 0, _("cannot split in more than one way"));	\
       usage (EXIT_FAILURE);					\
     }								\
   while (0)
 
-
-/* Parse K/N syntax of chunk options.  */
-
-static void
-parse_chunk (uintmax_t *k_units, uintmax_t *n_units, char *slash)
-{
-  *n_units = xdectoumax (slash + 1, 1, UINTMAX_MAX, "",
-                         _("invalid number of chunks"), 0);
-  if (slash != optarg)           /* a leading number is specified.  */
-    {
-      *slash = '\0';
-      *k_units = xdectoumax (optarg, 1, *n_units, "",
-                             _("invalid chunk number"), 0);
-    }
-}
-
-
 int
 main (int argc, char **argv)
 {
-  enum Split_type split_type = type_undef;
-  size_t in_blk_size = 0;	/* optimal block size of input file device */
-  size_t page_size = getpagesize ();
-  uintmax_t k_units = 0;
-  uintmax_t n_units = 0;
-
-  static char const multipliers[] = "bEGKkMmPTYZ0";
+  struct stat stat_buf;
+  enum
+    {
+      type_undef, type_bytes, type_byteslines, type_lines, type_digits
+    } split_type = type_undef;
+  size_t in_blk_size;		/* optimal block size of input file device */
+  char *buf;			/* file i/o buffer */
+  uintmax_t n_units;
   int c;
   int digits_optind = 0;
-  off_t file_size = OFF_T_MAX;
 
   initialize_main (&argc, &argv);
-  set_program_name (argv[0]);
+  program_name = argv[0];
   setlocale (LC_ALL, "");
   bindtextdomain (PACKAGE, LOCALEDIR);
   textdomain (PACKAGE);
 
   atexit (close_stdout);
 
   /* Parse command line options.  */
 
-  infile = bad_cast ("-");
-  outbase = bad_cast ("x");
+  infile = "-";
+  outbase = "x";
 
-  while (true)
+  while (1)
     {
       /* This is the argv-index of the option we will read next.  */
       int this_optind = optind ? optind : 1;
-      char *slash;
 
-      c = getopt_long (argc, argv, "0123456789C:a:b:del:n:t:u",
-                       longopts, NULL);
+      c = getopt_long (argc, argv, "0123456789C:a:b:dl:", longopts, NULL);
       if (c == -1)
-        break;
+	break;
 
       switch (c)
-        {
-        case 'a':
-          suffix_length = xdectoumax (optarg, 0, SIZE_MAX / sizeof (size_t),
-                                      "", _("invalid suffix length"), 0);
-          break;
-
-        case ADDITIONAL_SUFFIX_OPTION:
-          if (last_component (optarg) != optarg)
-            {
-              error (0, 0,
-                     _("invalid suffix %s, contains directory separator"),
-                     quote (optarg));
-              usage (EXIT_FAILURE);
-            }
-          additional_suffix = optarg;
-          break;
-
-        case 'b':
-          if (split_type != type_undef)
-            FAIL_ONLY_ONE_WAY ();
-          split_type = type_bytes;
-          /* Limit to OFF_T_MAX, because if input is a pipe, we could get more
-             data than is possible to write to a single file, so indicate that
-             immediately rather than having possibly future invocations fail. */
-          n_units = xdectoumax (optarg, 1, OFF_T_MAX, multipliers,
-                                _("invalid number of bytes"), 0);
-          break;
-
-        case 'l':
-          if (split_type != type_undef)
-            FAIL_ONLY_ONE_WAY ();
-          split_type = type_lines;
-          n_units = xdectoumax (optarg, 1, UINTMAX_MAX, "",
-                                _("invalid number of lines"), 0);
-          break;
-
-        case 'C':
-          if (split_type != type_undef)
-            FAIL_ONLY_ONE_WAY ();
-          split_type = type_byteslines;
-          n_units = xdectoumax (optarg, 1, MIN (SIZE_MAX, OFF_T_MAX),
-                                multipliers, _("invalid number of bytes"), 0);
-          break;
-
-        case 'n':
-          if (split_type != type_undef)
-            FAIL_ONLY_ONE_WAY ();
-          /* skip any whitespace */
-          while (isspace (to_uchar (*optarg)))
-            optarg++;
-          if (STRNCMP_LIT (optarg, "r/") == 0)
-            {
-              split_type = type_rr;
-              optarg += 2;
-            }
-          else if (STRNCMP_LIT (optarg, "l/") == 0)
-            {
-              split_type = type_chunk_lines;
-              optarg += 2;
-            }
-          else
-            split_type = type_chunk_bytes;
-          if ((slash = strchr (optarg, '/')))
-            parse_chunk (&k_units, &n_units, slash);
-          else
-            n_units = xdectoumax (optarg, 1, UINTMAX_MAX, "",
-                                  _("invalid number of chunks"), 0);
-          break;
-
-        case 'u':
-          unbuffered = true;
-          break;
-
-        case 't':
-          {
-            char neweol = optarg[0];
-            if (! neweol)
-              die (EXIT_FAILURE, 0, _("empty record separator"));
-            if (optarg[1])
-              {
-                if (STREQ (optarg, "\\0"))
-                  neweol = '\0';
-                else
-                  {
-                    /* Provoke with 'split -txx'.  Complain about
-                       "multi-character tab" instead of "multibyte tab", so
-                       that the diagnostic's wording does not need to be
-                       changed once multibyte characters are supported.  */
-                    die (EXIT_FAILURE, 0, _("multi-character separator %s"),
-                         quote (optarg));
-                  }
-              }
-            /* Make it explicit we don't support multiple separators.  */
-            if (0 <= eolchar && neweol != eolchar)
-              {
-                die (EXIT_FAILURE, 0,
-                     _("multiple separator characters specified"));
-              }
-
-            eolchar = neweol;
-          }
-          break;
-
-        case '0':
-        case '1':
-        case '2':
-        case '3':
-        case '4':
-        case '5':
-        case '6':
-        case '7':
-        case '8':
-        case '9':
-          if (split_type == type_undef)
-            {
-              split_type = type_digits;
-              n_units = 0;
-            }
-          if (split_type != type_undef && split_type != type_digits)
-            FAIL_ONLY_ONE_WAY ();
-          if (digits_optind != 0 && digits_optind != this_optind)
-            n_units = 0;	/* More than one number given; ignore other. */
-          digits_optind = this_optind;
-          if (!DECIMAL_DIGIT_ACCUMULATE (n_units, c - '0', uintmax_t))
-            {
-              char buffer[INT_BUFSIZE_BOUND (uintmax_t)];
-              die (EXIT_FAILURE, 0,
-                   _("line count option -%s%c... is too large"),
-                   umaxtostr (n_units, buffer), c);
-            }
-          break;
-
-        case 'd':
-          suffix_alphabet = "0123456789";
-          if (optarg)
-            {
-              if (strlen (optarg) != strspn (optarg, suffix_alphabet))
-                {
-                  error (0, 0,
-                         _("%s: invalid start value for numerical suffix"),
-                         quote (optarg));
-                  usage (EXIT_FAILURE);
-                }
-              else
-                {
-                  /* Skip any leading zero.  */
-                  while (*optarg == '0' && *(optarg + 1) != '\0')
-                    optarg++;
-                  numeric_suffix_start = optarg;
-                }
-            }
-          break;
-
-        case 'e':
-          elide_empty_files = true;
-          break;
-
-        case FILTER_OPTION:
-          filter_command = optarg;
-          break;
-
-        case IO_BLKSIZE_OPTION:
-          in_blk_size = xdectoumax (optarg, 1, SIZE_MAX - page_size,
-                                    multipliers, _("invalid IO block size"), 0);
-          break;
-
-        case VERBOSE_OPTION:
-          verbose = true;
-          break;
-
-        case_GETOPT_HELP_CHAR;
-
-        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
-
-        default:
-          usage (EXIT_FAILURE);
-        }
-    }
-
-  if (k_units != 0 && filter_command)
-    {
-      error (0, 0, _("--filter does not process a chunk extracted to stdout"));
+	{
+	case 0:
+	  break;
+
+	case 'a':
+	  {
+	    unsigned long tmp;
+	    if (xstrtoul (optarg, NULL, 10, &tmp, "") != LONGINT_OK
+		|| SIZE_MAX / sizeof (size_t) < tmp)
+	      {
+		error (0, 0, _("%s: invalid suffix length"), optarg);
+		usage (EXIT_FAILURE);
+	      }
+	    suffix_length = tmp;
+	  }
+	  break;
+
+	case 'b':
+	  if (split_type != type_undef)
+	    FAIL_ONLY_ONE_WAY ();
+	  split_type = type_bytes;
+	  if (xstrtoumax (optarg, NULL, 10, &n_units, "bkm") != LONGINT_OK
+	      || n_units == 0)
+	    {
+	      error (0, 0, _("%s: invalid number of bytes"), optarg);
+	      usage (EXIT_FAILURE);
+	    }
+	  break;
+
+	case 'l':
+	  if (split_type != type_undef)
+	    FAIL_ONLY_ONE_WAY ();
+	  split_type = type_lines;
+	  if (xstrtoumax (optarg, NULL, 10, &n_units, "") != LONGINT_OK
+	      || n_units == 0)
+	    {
+	      error (0, 0, _("%s: invalid number of lines"), optarg);
+	      usage (EXIT_FAILURE);
+	    }
+	  break;
+
+	case 'C':
+	  if (split_type != type_undef)
+	    FAIL_ONLY_ONE_WAY ();
+	  split_type = type_byteslines;
+	  if (xstrtoumax (optarg, NULL, 10, &n_units, "bkm") != LONGINT_OK
+	      || n_units == 0 || SIZE_MAX < n_units)
+	    {
+	      error (0, 0, _("%s: invalid number of bytes"), optarg);
+	      usage (EXIT_FAILURE);
+	    }
+	  break;
+
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  if (split_type == type_undef)
+	    {
+	      split_type = type_digits;
+	      n_units = 0;
+	    }
+	  if (split_type != type_undef && split_type != type_digits)
+	    FAIL_ONLY_ONE_WAY ();
+	  if (digits_optind != 0 && digits_optind != this_optind)
+	    n_units = 0;	/* More than one number given; ignore other. */
+	  digits_optind = this_optind;
+	  if (UINTMAX_MAX / 10 < n_units
+	      || n_units * 10 + c - '0' < n_units * 10)
+	    {
+	      char buffer[INT_BUFSIZE_BOUND (uintmax_t)];
+	      error (EXIT_FAILURE, 0,
+		     _("line count option -%s%c... is too large"),
+		     umaxtostr (n_units, buffer), c);
+	    }
+	  n_units = n_units * 10 + c - '0';
+	  break;
+
+	case 'd':
+	  suffix_alphabet = "0123456789";
+	  break;
+
+	case_GETOPT_HELP_CHAR;
+
+	case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
+
+	default:
+	  usage (EXIT_FAILURE);
+	}
+    }
+
+  if (digits_optind && 200112 <= posix2_version ())
+    {
+      char buffer[INT_BUFSIZE_BOUND (uintmax_t)];
+      char const *a = umaxtostr (n_units, buffer);
+      error (0, 0, _("`-%s' option is obsolete; use `-l %s'"), a, a);
       usage (EXIT_FAILURE);
     }
 
   /* Handle default case.  */
   if (split_type == type_undef)
     {
       split_type = type_lines;
       n_units = 1000;
     }
 
   if (n_units == 0)
     {
-      error (0, 0, "%s: %s", _("invalid number of lines"), quote ("0"));
+      /* FIXME: be sure to remove this block when removing
+	 support for obsolete options like `-10'.  */
+      error (0, 0, _("invalid number of lines: 0"));
       usage (EXIT_FAILURE);
     }
 
-  if (eolchar < 0)
-    eolchar = '\n';
-
-  set_suffix_length (n_units, split_type);
-
   /* Get out the filename arguments.  */
 
   if (optind < argc)
     infile = argv[optind++];
 
   if (optind < argc)
     outbase = argv[optind++];
 
   if (optind < argc)
     {
-      error (0, 0, _("extra operand %s"), quote (argv[optind]));
+      error (0, 0, _("too many arguments"));
       usage (EXIT_FAILURE);
     }
 
-  /* Check that the suffix length is large enough for the numerical
-     suffix start value.  */
-  if (numeric_suffix_start && strlen (numeric_suffix_start) > suffix_length)
+  /* Open the input file.  */
+  if (STREQ (infile, "-"))
+    input_desc = STDIN_FILENO;
+  else
     {
-      error (0, 0, _("numerical suffix start value is too large "
-                     "for the suffix length"));
-      usage (EXIT_FAILURE);
+      input_desc = open (infile, O_RDONLY);
+      if (input_desc < 0)
+	error (EXIT_FAILURE, errno, "%s", infile);
     }
+  /* Binary I/O is safer when bytecounts are used.  */
+  SET_BINARY (input_desc);
 
-  /* Open the input file.  */
-  if (! STREQ (infile, "-")
-      && fd_reopen (STDIN_FILENO, infile, O_RDONLY, 0) < 0)
-    die (EXIT_FAILURE, errno, _("cannot open %s for reading"),
-         quoteaf (infile));
-
-  /* Binary I/O is safer when byte counts are used.  */
-  xset_binary_mode (STDIN_FILENO, O_BINARY);
+  /* No output file is open now.  */
+  output_desc = -1;
 
   /* Get the optimal block size of input device and make a buffer.  */
 
-  if (fstat (STDIN_FILENO, &in_stat_buf) != 0)
-    die (EXIT_FAILURE, errno, "%s", quotef (infile));
-
-  bool specified_buf_size = !! in_blk_size;
-  if (! specified_buf_size)
-    in_blk_size = io_blksize (in_stat_buf);
-
-  void *b = xmalloc (in_blk_size + 1 + page_size - 1);
-  char *buf = ptr_align (b, page_size);
-  size_t initial_read = SIZE_MAX;
+  if (fstat (input_desc, &stat_buf) < 0)
+    error (EXIT_FAILURE, errno, "%s", infile);
+  in_blk_size = ST_BLKSIZE (stat_buf);
 
-  if (split_type == type_chunk_bytes || split_type == type_chunk_lines)
-    {
-      file_size = input_file_size (STDIN_FILENO, &in_stat_buf,
-                                   buf, in_blk_size);
-      if (file_size < 0)
-        die (EXIT_FAILURE, errno, _("%s: cannot determine file size"),
-             quotef (infile));
-      initial_read = MIN (file_size, in_blk_size);
-      /* Overflow, and sanity checking.  */
-      if (OFF_T_MAX < n_units)
-        {
-          char buffer[INT_BUFSIZE_BOUND (uintmax_t)];
-          die (EXIT_FAILURE, EOVERFLOW, "%s: %s",
-               _("invalid number of chunks"),
-               quote (umaxtostr (n_units, buffer)));
-        }
-      /* increase file_size to n_units here, so that we still process
-         any input data, and create empty files for the rest.  */
-      file_size = MAX (file_size, n_units);
-    }
-
-  /* When filtering, closure of one pipe must not terminate the process,
-     as there may still be other streams expecting input from us.  */
-  if (filter_command)
-    {
-      struct sigaction act;
-      sigemptyset (&newblocked);
-      sigaction (SIGPIPE, NULL, &act);
-      if (act.sa_handler != SIG_IGN)
-        sigaddset (&newblocked, SIGPIPE);
-      sigprocmask (SIG_BLOCK, &newblocked, &oldblocked);
-    }
+  buf = xmalloc (in_blk_size + 1);
 
   switch (split_type)
     {
     case type_digits:
     case type_lines:
       lines_split (n_units, buf, in_blk_size);
       break;
 
     case type_bytes:
-      bytes_split (n_units, buf, in_blk_size, SIZE_MAX, 0);
+      bytes_split (n_units, buf, in_blk_size);
       break;
 
     case type_byteslines:
-      line_bytes_split (n_units, buf, in_blk_size);
-      break;
-
-    case type_chunk_bytes:
-      if (k_units == 0)
-        bytes_split (file_size / n_units, buf, in_blk_size, initial_read,
-                     n_units);
-      else
-        bytes_chunk_extract (k_units, n_units, buf, in_blk_size, initial_read,
-                             file_size);
-      break;
-
-    case type_chunk_lines:
-      lines_chunk_split (k_units, n_units, buf, in_blk_size, initial_read,
-                         file_size);
-      break;
-
-    case type_rr:
-      /* Note, this is like 'sed -n ${k}~${n}p' when k > 0,
-         but the functionality is provided for symmetry.  */
-      lines_rr (k_units, n_units, buf, in_blk_size);
+      line_bytes_split (n_units);
       break;
 
     default:
       abort ();
     }
 
-  IF_LINT (free (b));
-
-  if (close (STDIN_FILENO) != 0)
-    die (EXIT_FAILURE, errno, "%s", quotef (infile));
-  closeout (NULL, output_desc, filter_pid, outfile);
+  if (close (input_desc) < 0)
+    error (EXIT_FAILURE, errno, "%s", infile);
+  if (output_desc >= 0 && close (output_desc) < 0)
+    error (EXIT_FAILURE, errno, "%s", outfile);
 
-  return EXIT_SUCCESS;
+  exit (EXIT_SUCCESS);
 }
diff --git a/src/stat.c b/src/stat.c
index d085cd059c2b9748cf41d042ae5afb46279075d5..396b073dfcbb3c9d44fc6c1a6bcb75dc52fa8280 100644
--- a/src/stat.c
+++ b/src/stat.c
@@ -217,12 +217,15 @@ static size_t decimal_point_len;
    Others have statfs.f_fstypename[MFSNAMELEN] (NetBSD 1.5.2).
    Still others have neither and have to get by with f_type (GNU/Linux).
    But f_type may only exist in statfs (Cygwin).  */
 static char const * ATTRIBUTE_WARN_UNUSED_RESULT
 human_fstype (STRUCT_STATVFS const *statfsbuf)
 {
+#if defined __amigaos__ && defined __CLIB2__ /* AmigaOS using CLIB2 */
+  return statfsbuf->f_fstypename;
+#else
 #ifdef STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME
   return statfsbuf->STATXFS_FILE_SYSTEM_TYPE_MEMBER_NAME;
 #else
   switch (statfsbuf->f_type)
     {
 # if defined __linux__
@@ -561,12 +564,13 @@ human_fstype (STRUCT_STATVFS const *statfsbuf)
                         + (sizeof type * CHAR_BIT + 3) / 4];
         sprintf (buf, "UNKNOWN (0x%lx)", type);
         return buf;
       }
     }
 #endif
+#endif
 }
 
 static char * ATTRIBUTE_WARN_UNUSED_RESULT
 human_access (struct stat const *statbuf)
 {
   static char modebuf[12];
diff --git a/src/stdbuf.c b/src/stdbuf.c
index 5342a26a13cb47df22bd8da95c66b4bc9c6d15e3..48e8bf63205a4c4c9e4a135a99174284dbc4ae38 100644
--- a/src/stdbuf.c
+++ b/src/stdbuf.c
@@ -28,12 +28,18 @@
 #include "filenamecat.h"
 #include "quote.h"
 #include "xreadlink.h"
 #include "xstrtol.h"
 #include "c-ctype.h"
 
+#if defined __amigaos__ && defined __CLIB2__ /* AmigaOS using CLIB2 */
+# define __USE_INLINE__
+# include <dos.h>
+# include <proto/dos.h>
+#endif
+
 /* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "stdbuf"
 #define LIB_NAME "libstdbuf.so" /* FIXME: don't hardcode  */
 
 #define AUTHORS proper_name ("Padraig Brady")
 
@@ -137,15 +143,29 @@ set_program_path (const char *arg)
   if (strchr (arg, '/'))        /* Use absolute or relative paths directly.  */
     {
       program_path = dir_name (arg);
     }
   else
     {
+#if defined __amigaos__ && defined __CLIB2__ /* AmigaOS using CLIB2 */
+      char *path;
+
+      if (NameFromLock(GetProgramDir(), path, PATH_MAX))
+      {
+        const char *amigapath = path;
+        struct name_translation_info nti;
+
+        __translate_amiga_to_unix_path_name(&amigapath,&nti);
+	path = strdup(amigapath);
+        program_path = dir_name (path);
+      }
+#else
       char *path = xreadlink ("/proc/self/exe");
       if (path)
         program_path = dir_name (path);
+#endif
       else if ((path = getenv ("PATH")))
         {
           char *dir;
           path = xstrdup (path);
           for (dir = strtok (path, ":"); dir != NULL; dir = strtok (NULL, ":"))
             {
diff --git a/src/tee.c b/src/tee.c
index 4a6885ce5ed45fc98a0a23f29172aa858fa63655..390468a4ba9cf56ecd30192832ce5869b99c0a88 100644
--- a/src/tee.c
+++ b/src/tee.c
@@ -160,14 +160,16 @@ main (int argc, char **argv)
         }
     }
 
   if (ignore_interrupts)
     signal (SIGINT, SIG_IGN);
 
+#if !(defined __amigaos__ && defined __CLIB2__) /* AmigaOS using CLIB2 */
   if (output_error != output_error_sigpipe)
     signal (SIGPIPE, SIG_IGN);
+#endif
 
   /* Do *not* warn if tee is given no file arguments.
      POSIX requires that it work when given no arguments.  */
 
   ok = tee_files (argc - optind, &argv[optind]);
   if (close (STDIN_FILENO) != 0)
-- 
2.17.1

